# Section 20 — Model Selection & Routing (2026)

## Plain English

Model selection and routing answers this question:

**"Which model should handle this request, right now, under these conditions?"**

In 2026:
- there is no single "best" model
- costs vary wildly
- latency matters
- reliability fluctuates
- different tasks need different intelligence

Routing is how you turn **many models into one reliable system**.

---

## Why Model Routing Exists

Early-stage systems:
- hardcode one model
- hope it works
- absorb cost spikes

At scale:
- that approach fails immediately

Model routing exists to:
- optimize quality
- control cost
- manage latency
- improve reliability
- handle failures gracefully

Routing is **strategy encoded in software**.

---

## Core Idea (2026)

**Models are interchangeable components, not sacred choices.**

Your system owns the decision.
The model is just a worker.

---

## Dimensions That Drive Model Choice

Every routing decision balances **five dimensions**:

1. Quality (capability, reasoning, accuracy)
2. Latency (speed, streaming, responsiveness)
3. Cost (tokens, compute, margins)
4. Reliability (timeouts, failures, rate limits)
5. Risk (hallucinations, safety, compliance)

Routing is multi-objective optimization.

---

## Task-Based Model Selection

Different tasks require different models.

Examples:
- simple extraction → small fast model
- classification → cheap deterministic model
- reasoning → higher-capability model
- planning → stronger reasoning model
- fallback → conservative reliable model

You do not overpay for intelligence you don't need.

---

## Policy-Driven Routing

In mature systems, routing is governed by **policies**, not code.

Policies define:
- which models are allowed
- cost ceilings
- latency budgets
- risk tolerance

Policies can vary by:
- product
- tenant
- geography
- compliance tier

Policy separation enables flexibility without chaos.

---

## Dynamic Routing (2026 Standard)

Routing decisions are made **at runtime** based on:

- task type
- input complexity
- user tier
- current system load
- model health
- budget status

Static routing is considered outdated.

---

## Fallback & Degradation Strategies

Every routing system must handle failure.

Fallback patterns include:
- retry with same model
- retry with cheaper model
- retry with more reliable model
- degrade functionality gracefully
- escalate to human

Failure without fallback is negligence.

---

## Latency-Aware Routing

Some tasks are latency-critical:
- voice
- chat
- real-time agents

Others are not:
- batch analysis
- background jobs

Routing must respect:
- SLA targets
- user expectations
- streaming capabilities

Fast models for fast paths.
Slow models for deep thinking.

---

## Cost-Aware Routing

Cost must be:
- visible
- enforceable
- bounded

Cost-aware routing includes:
- per-request budgets
- daily spend caps
- tenant-level quotas
- dynamic downgrades

If routing ignores cost, finance will stop the product.

---

## Reliability-Aware Routing

Models fluctuate:
- outages
- rate limits
- degraded performance

Routing systems monitor:
- error rates
- timeouts
- saturation
- provider health

Healthy systems reroute automatically.

---

## Quality-Aware Routing

Quality signals feed routing decisions.

Examples:
- eval scores
- recent regressions
- task success rates

If quality drops:
- route away
- reduce exposure
- trigger investigation

Routing closes the eval loop.

---

## Multi-Model Architectures

In 2026, serious systems run:
- multiple vendors
- multiple model sizes
- multiple specializations

Benefits:
- vendor independence
- resilience
- cost leverage
- quality optimization

Single-model dependence is a risk.

---

## Routing for RAG Systems

RAG routing considers:
- retrieval complexity
- grounding requirements
- citation needs

Examples:
- cheap model for retrieval rewrite
- stronger model for synthesis
- fallback model for ambiguous queries

RAG without routing wastes money.

---

## Routing for Agent Systems

Agents introduce:
- multi-step reasoning
- tool calling
- long context

Routing patterns include:
- lightweight planner → heavy executor
- cheap reasoning → strong verification
- conservative safety model for approvals

Agent routing prevents runaway cost and errors.

---

## Routing for Voice Systems

Voice routing prioritizes:
- low latency
- streaming support
- stability

Common pattern:
- fast model for turn-taking
- stronger model for reasoning
- fallback model for silence or noise

Voice users feel routing mistakes immediately.

---

## Observability for Routing

Routing decisions must be observable.

Track:
- which model handled what
- why it was chosen
- cost impact
- outcome quality

Opaque routing systems become unmanageable.

---

## Governance & Routing

Routing policies must:
- be documented
- be reviewed
- support audits

Enterprises ask:
- why was this model used?
- was it approved?
- was risk acceptable?

Governance and routing are inseparable.

---

## Founder Perspective

For founders:
- routing protects margins
- enables premium tiers
- supports enterprise SLAs
- reduces dependency on any vendor

Routing is leverage.

---

## Interview-Grade Talking Points

You should be able to explain:

- why routing exists
- how policies control routing
- how cost and quality trade off
- how fallback works
- how routing uses eval signals

This is **Staff / Principal / Platform mastery**.

---

## Completion Checklist

You are done with this section when you can:

- design a routing policy
- explain task-based selection
- explain fallback strategies
- reason about cost vs quality
- integrate routing with evals

If this is clear, you can run AI systems economically and safely.

---

## What Comes Next

Now that models are chosen intelligently, the next challenge is:

**How prompts, tools, and orchestration are structured as a system.**

That is Section 21 — Prompt & Tool Architecture.
