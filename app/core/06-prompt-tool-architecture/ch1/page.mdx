# Chapter 1 — Prompt Architecture Foundations

Prompt architecture is software architecture. The distinction between writing a clever prompt and architecting a production prompt system is the same distinction between writing a shell script and building a scalable API. One works once; the other works every time, at scale, with observability, rollback, and governance.

---

## What This Chapter Covers

- **1.1** — Why Prompt Architecture Is Software Architecture
- **1.2** — Anatomy of a Production Prompt: System, User, Assistant, and Tool Roles
- **1.3** — Single-Shot vs Multi-Turn Prompt Design
- **1.4** — Temperature, Top-P, and Sampling Strategy as Architecture Decisions
- **1.5** — Model-Specific Prompt Design: Claude, GPT, Gemini, Llama, Mistral
- **1.6** — Prompt Latency Budgets and Token Economics
- **1.7** — The Prompt as Contract: Inputs, Outputs, and Failure Modes
- **1.8** — When Prompts Fail: Taxonomy of Prompt Failures in Production
- **1.9** — Prompt Complexity vs Prompt Fragility Tradeoffs
- **1.10** — The Role of Examples: Zero-Shot, Few-Shot, and Many-Shot
- **1.11** — Prompt Decomposition: Breaking Complex Tasks Into Prompt Chains
- **1.12** — Prompt Architecture Patterns Across Risk Tiers

---

*Start by treating prompts like the infrastructure they are.*
