# 10.16 â€” Long-Running Agents: Suspend, Resume, and Cancel

In March 2025, a financial services company launched an agent that analyzed loan applications and prepared approval recommendations. The agent typically completed its work in three to five minutes, but complex cases involving multiple credit sources and manual document review could take up to forty minutes. In the first week, 63 loan officers opened the agent interface, started the analysis, then switched to other work while the agent processed. The agent UI showed a spinner with no progress indication. Twelve officers assumed the system had frozen and reloaded the page, terminating the agent mid-analysis. The agent had no suspend mechanism, no state persistence, and no way to resume after a reload. Each reload started the analysis from scratch. The engineering team had optimized for fast completions and never considered that users would context-switch during long operations. The result was wasted compute, frustrated users, and a six-week retrofit to add suspend-resume capability with progress tracking and session persistence.

Long-running agents require explicit lifecycle management. Users do not sit and watch a spinner for minutes or hours. They start the agent, switch to other tasks, return later to check progress, and may decide to pause or cancel the work entirely. Without suspend-resume-cancel primitives, long-running agents become user-hostile black boxes. Implementing these primitives requires session persistence, progress tracking, interruptible execution, state machine design, and user interface patterns that communicate status and enable control. This subchapter covers the architecture and operational practices for managing agent lifecycles that span minutes, hours, or even days.

## Designing for Interruptible Execution

Agents must be architecturally interruptible, meaning the runtime can pause execution at any point, save the state, and resume later without losing progress or correctness. This requires breaking the agent's work into discrete, resumable steps. Each step represents a coherent unit of progress: a single tool call, a reasoning phase, a decision point, or a user interaction. After completing each step, the agent runtime writes a checkpoint containing the step result and the next step pointer. If the user suspends the agent, the runtime saves the current checkpoint and terminates the process. When the user resumes, the runtime loads the checkpoint and continues from the next step.

Step granularity determines the maximum suspend latency. If steps are large, the agent may continue running for seconds or minutes after the user clicks suspend, because the runtime must wait for the current step to complete before checkpointing. If steps are small, the agent responds to suspend requests within milliseconds, but checkpoint overhead increases. Target step durations between one and ten seconds for user-facing agents. This provides responsive suspend without excessive checkpoint churn. For background agents that run without user supervision, longer step durations are acceptable because suspend latency does not affect user experience.

Tool calls are natural step boundaries. The agent decides to call a tool, the runtime writes a checkpoint with the decision, the tool executes, the runtime writes a checkpoint with the result, and the agent proceeds to the next decision. If the user suspends during tool execution, the runtime allows the tool to complete, writes the result checkpoint, and then pauses. This ensures that the agent never loses a completed tool call result and never re-executes a side-effecting tool on resume. The tool execution itself may be long-running, so tools must also support cancellation. If the user suspends and the tool is still executing, the runtime sends a cancel signal to the tool. The tool acknowledges the cancel, cleans up any partial work, and returns a cancelled status. The runtime writes a checkpoint indicating cancellation and stops the agent.

Reasoning steps are harder to interrupt because language model inference is not natively cancellable. The agent submits a prompt to the model, and the model generates tokens until completion. Streaming APIs provide partial results, but they do not support mid-generation cancellation in a way that preserves semantic coherence. The practical approach is to treat model inference as an atomic step. The agent submits the prompt, waits for completion, writes the result checkpoint, and then checks for suspend signals. If the user suspends while the model is generating, the runtime waits for generation to complete, writes the checkpoint, and then pauses. This means suspend latency equals the time to complete the current inference, which may be several seconds for long outputs. Users must understand that suspend is not instantaneous; it happens at the next step boundary.

## Suspend and Resume User Experience

The user interface must clearly indicate that an agent is running, show progress, and provide suspend and cancel controls. The running indicator is a persistent status bar that shows the agent's current step, elapsed time, and estimated time remaining. The status bar updates in real time as the agent progresses. Users should be able to minimize the agent window and see the status in a notification tray or background tasks list. This allows users to start an agent, switch to other work, and check back periodically without keeping the agent window open.

Progress tracking requires the agent to estimate total work and report completed work. For agents with deterministic workflows, this is straightforward: the agent knows it will execute twelve steps, reports progress as step N of twelve, and updates the percentage after each step. For agents with adaptive workflows where the number of steps depends on intermediate results, progress estimation is harder. The agent can report progress as completed milestones rather than percentages: gathered user data, analyzed requirements, generated recommendations, validated results. Milestone-based progress is less precise but more honest than a percentage that turns out to be wrong when the agent discovers additional work.

The suspend control is a pause button that saves the current state and stops execution. The button is always enabled while the agent is running. Clicking pause sends a suspend signal to the runtime. The runtime completes the current step, writes the checkpoint, and transitions the session to a suspended state. The UI shows a paused indicator and provides a resume button. Clicking resume loads the checkpoint and continues from the next step. The user sees the agent pick up exactly where it left off, with no repeated work and no lost progress.

Some suspend scenarios are user-initiated, and others are system-initiated. User-initiated suspend happens when the user clicks pause or closes the window. System-initiated suspend happens when the agent hits a timeout, when the user's device goes to sleep, when the network disconnects, or when the deployment platform needs to reclaim resources. The agent runtime must handle both gracefully. For user-initiated suspend, the runtime writes the checkpoint synchronously before returning control to the user. For system-initiated suspend, the runtime may have only seconds to write the checkpoint before the process is terminated. Use asynchronous checkpoint writes with flush-on-signal to ensure that the checkpoint completes even if the process is killed.

## Cancel and Cleanup

Cancel is different from suspend. Suspend preserves state for later resumption. Cancel discards state and aborts the work permanently. Users cancel when they realize the agent is solving the wrong problem, when they no longer need the result, or when the agent is taking too long and they want to start over with different inputs. The cancel control is a stop button, visually distinct from the pause button, often with a confirmation dialog to prevent accidental clicks.

Cancellation must clean up any resources the agent acquired. If the agent locked a database record, cancellation releases the lock. If the agent reserved a meeting room, cancellation frees the reservation. If the agent started a long-running external job, cancellation sends a stop signal to that job. This requires the agent to track acquired resources in the checkpoint. When the user cancels, the runtime loads the checkpoint, iterates over the resource list, and releases each resource. If resource release fails, the runtime logs the failure and alerts the operations team, because leaked resources can cause downstream problems.

Some resources are easy to release and others are not. A read lock on a database row releases automatically when the transaction ends. A write lock may require an explicit rollback if the agent made partial changes. A sent email cannot be unsent; cancellation can only prevent future emails. A started payment transaction may be in flight; cancellation must query the payment processor to determine whether the transaction completed, and if it did, initiate a refund. The agent platform provides a resource manager that tracks resource acquisitions and provides type-specific cleanup handlers. Each tool that acquires a resource registers it with the resource manager. On cancel, the manager invokes the appropriate cleanup handler for each resource.

Partial results from cancelled agents may still be useful. If the agent completed three of five analysis steps before cancellation, the user may want to see the intermediate results. The UI provides an option to save partial results when cancelling. The runtime writes a partial result checkpoint marked as incomplete, and the user can later view the results with a clear indication that the work was not finished. This is especially valuable for research and analysis agents where partial progress still provides insight.

## Session Persistence and Expiration

Long-running agents require durable session storage. The session includes the conversation history, the action log, the checkpoints, the resource list, and the user metadata. This data must survive process restarts, deployments, and infrastructure failures. Store sessions in a database or object store with replication and backup. DynamoDB, PostgreSQL, and Cloud Storage all work well. The session store must support fast random access by session ID, because the resume operation needs to load the full session quickly.

Sessions have a lifecycle. A session begins when the user starts the agent. The session is active while the agent is running, suspended while paused, and completed when the agent finishes or the user cancels. Completed sessions transition to archived state after a retention period. The retention period depends on the use case. For transactional agents that perform one-time tasks, archive after 24 hours. For analytical agents that produce reports users may reference later, archive after 30 days. For audit-critical agents in regulated industries, archive after the legal retention period, which may be years.

Suspended sessions must also expire. If a user suspends an agent and never resumes, the session occupies storage indefinitely. Set a suspend expiration policy: if a session remains suspended for more than seven days, automatically archive it. Notify the user before expiration: send an email or in-app notification three days before the session expires, giving the user a chance to resume or extend the session. If the user does not respond, archive the session and release resources. Provide a session history view where users can see archived sessions and optionally restore them if needed.

Session size matters. A long-running agent may accumulate megabytes of conversation history and action logs. Checkpointing every action means hundreds or thousands of checkpoint records. Optimize storage by compressing checkpoints, deduplicating repeated data, and using incremental checkpoints that store only deltas from the previous checkpoint. For very long sessions, implement checkpoint compaction: periodically consolidate old checkpoints into a single snapshot, discard intermediate checkpoints, and store only the snapshot plus recent deltas. This keeps session size bounded even for agents that run for days.

## Resume Consistency and Version Skew

Agent code evolves. Deployments introduce new features, fix bugs, and change behavior. A session that started on version 1.2 of the agent may resume on version 1.3. If the code change is backward-compatible, resumption works transparently. If the code change is not backward-compatible, resumption fails or behaves incorrectly. Version skew is a major hazard for long-running agents.

Backward compatibility requires discipline. Never remove a tool that existing sessions might reference. Instead, deprecate the tool and maintain it for a transition period while active sessions complete. Never change the signature of a tool in a way that breaks existing checkpoints. If you need to add a parameter, make it optional with a default value. If you need to change behavior, add a new tool with a new name and migrate sessions to use the new tool at natural breakpoints like user interactions.

Checkpoints must include a schema version. The checkpoint stores not just data but also the version of the agent code that created it. On resume, the runtime checks the checkpoint version against the current code version. If the versions match, resume proceeds normally. If the checkpoint version is older, the runtime applies migration logic to update the checkpoint schema to the current version. If the checkpoint version is newer, resume fails because the current code cannot interpret a future schema. This should never happen in production if deployments are properly sequenced, but it can occur in development or during rollbacks.

Migration logic handles schema changes. If version 1.2 stored action arguments as a flat dictionary and version 1.3 stores them as a nested structure, the migration logic reads the 1.2 checkpoint, transforms the flat dictionary into the nested structure, and writes a 1.3 checkpoint. The agent then resumes using the 1.3 checkpoint. Write migration tests for every schema change. Load a 1.2 checkpoint, run the migration, and verify that the 1.3 checkpoint contains the correct data. This prevents migration bugs from causing resume failures in production.

Some changes are too large to migrate automatically. If the agent's entire architecture changes, migrating old sessions may be impractical. In this case, provide a manual migration path: notify users that their suspended sessions cannot resume automatically, offer to export the session data in a readable format, and allow users to start new sessions with the current version. This is disruptive, so avoid it except for major version upgrades. Plan agent architecture changes with session continuity in mind. If a change would break existing sessions, phase it in gradually: support both old and new logic paths, migrate users at session boundaries, and deprecate the old path only after all active sessions have completed.

## Distributed Long-Running Agents

In distributed systems, long-running agents may span multiple backend services. The agent orchestrator runs in one service, tools execute in other services, and the session state lives in a shared data store. Suspend and resume must coordinate across all these components. When the user suspends, the orchestrator sends suspend signals to all in-flight tool calls, waits for acknowledgments, writes the global checkpoint, and stops. When the user resumes, the orchestrator loads the global checkpoint, restores the state of each component, and continues.

This requires distributed coordination. Use a distributed transaction protocol like two-phase commit or a saga pattern. In two-phase commit, the orchestrator sends a prepare-to-suspend message to each component. Each component completes its current operation, writes a local checkpoint, and responds ready. Once all components are ready, the orchestrator writes the global checkpoint and sends commit messages. Each component transitions to suspended state. On resume, the process reverses: the orchestrator sends resume messages, each component restores from its local checkpoint, and the orchestrator continues the workflow.

Sagas are more complex but handle failures better. The orchestrator writes the global checkpoint first, then sends suspend commands to each component. If a component fails to suspend, the orchestrator executes a compensating action to roll back the suspend and resume the component. This ensures that the system does not get stuck in a partially suspended state. Implement saga-based suspend-resume for agents with many components or unreliable tool services.

Multi-region deployments add latency and consistency challenges. If the agent starts in region A, suspends, and the user resumes from region B, the region B runtime must load the session from the global session store and continue execution. The session store must replicate data across regions with low latency. Use a globally distributed database like Cloud Spanner or DynamoDB Global Tables. Ensure that writes in region A are visible in region B within seconds. Monitor cross-region replication lag and alert if it exceeds acceptable thresholds. High replication lag causes resume failures where the region B runtime cannot find the latest checkpoint.

## Monitoring and Operational Metrics

Track session lifecycle metrics: sessions created, sessions suspended, sessions resumed, sessions cancelled, sessions completed, and sessions expired. High suspend rates may indicate that the agent is too slow or that users are unsure whether to wait. High cancel rates suggest that the agent is not solving the right problem or that users are frustrated with progress. High expiration rates indicate that users are abandoning suspended sessions, which may mean the suspend feature is not useful or that users forget about suspended work.

Measure suspend-to-resume latency. This is the time between the user clicking suspend and the runtime writing the checkpoint, plus the time between the user clicking resume and the agent continuing execution. Target suspend latency below five seconds and resume latency below three seconds. High suspend latency frustrates users who expect immediate pause. High resume latency makes resumption feel unreliable. Break down latency by component: checkpoint write time, resource cleanup time, state serialization time, and network round-trip time. Optimize the slowest component.

Monitor checkpoint size and growth rate. Sessions that grow unbounded eventually exceed storage limits or exceed the maximum checkpoint size that the runtime can load into memory. Alert if a session checkpoint exceeds 10 MB. Investigate why the session is so large. Common causes include storing full conversation history without summarization, logging verbose debug information, or accumulating redundant action records. Implement automatic summarization for long conversations and checkpoint compaction for long action logs.

Track version skew failures. If a resume fails because the checkpoint version is too old or too new, log the failure with the checkpoint version and the current code version. Aggregate these failures to identify problematic version transitions. If many sessions fail to resume after deploying version 1.4, version 1.4 likely introduced a breaking change. Roll back the deployment, fix the backward compatibility issue, and redeploy. This prevents a bad deployment from breaking all suspended sessions.

## User Communication and Transparency

Users need to understand what happens when they suspend or cancel. Provide clear messaging: suspending saves your progress and allows you to resume later; cancelling stops the work permanently and discards results. Show confirmation dialogs for destructive actions like cancel. After suspending, show a notification with the session ID and a link to the session history page where the user can resume. After cancelling, show a confirmation message and offer to save partial results if available.

For long-running agents that the user initiates and then leaves, send progress notifications. If the agent completes while the user is away, send an email or push notification with a summary and a link to the results. If the agent encounters an error, notify the user immediately with the error details and suggested next steps. If the agent is suspended due to a timeout or resource limit, notify the user and provide a resume link. This keeps users informed and prevents them from wondering whether their work is still running.

Provide a dashboard where users can see all their active, suspended, and completed sessions. The dashboard shows session start time, current status, elapsed time, progress percentage, and action buttons for resume or cancel. Users can search and filter sessions by date, status, or agent type. This transparency builds trust and gives users control over their agent interactions. Users who can see their suspended sessions are more likely to resume them rather than starting duplicate work.

The transition to always-on, persistent agent infrastructure is underway across the industry. As agents move from single-turn interactions to multi-hour workflows, suspend-resume-cancel capabilities become mandatory rather than optional. The engineering investment in lifecycle management pays dividends in user satisfaction, compute efficiency, and operational reliability. Build these primitives into your agent platform from the start, and your users will trust the system to handle work that spans hours, days, or longer.
