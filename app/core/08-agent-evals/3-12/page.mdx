# 3.12 — Budget-Aware Planning: Token and Cost Constraints on Reasoning

On March 14, 2025, an AI agent at a financial services company called Meridian Capital was asked to prepare a comprehensive competitive analysis comparing the firm to twelve rival investment banks. The task was complex but feasible, and the agent began with what seemed like responsible planning: it spent four minutes generating a detailed thirty-two-step plan that broke down the analysis into data gathering, comparison matrices, trend analysis, and executive summary generation. The planning phase alone consumed 47,000 tokens at a cost of $2.35. The agent then began execution, starting with step one: gathering recent deal data for each competitor. Three steps in, after spending another $3.20 on search and data extraction, the agent hit its budget limit. The task had a $5.00 cost constraint to keep analysis costs economical across hundreds of monthly reports. The agent had spent nearly half its budget on planning and less than a tenth of execution before running out of resources. The analysis was never completed. The agent's careful, thorough planning had consumed the very resources needed to execute the plan. The irony was not lost on the engineering team: the agent had planned itself into failure.

You face a fundamental paradox when building budget-aware agents: planning consumes the same resource—tokens—that execution requires. Every token spent reasoning about what to do is a token unavailable for actually doing it. Every dollar spent generating an elaborate plan is a dollar that cannot fund the tool calls and data processing the plan prescribes. In resource-constrained environments, which is nearly every production environment in 2026, planning is not free. It competes with execution for the same budget. Your agent must plan well enough to execute effectively, but not so elaborately that planning prevents execution.

## The Planning Budget Paradox

Planning seems like it should make agents more efficient. By thinking through the task before acting, the agent avoids wasteful actions and redundant work. A good plan reduces execution cost by choosing optimal actions. This reasoning is sound when planning is cheap relative to execution. But when planning itself is expensive, the calculus changes. The cost of planning must be justified by the savings it produces in execution.

Consider a simple task: given a topic, research it and write a summary. A minimal reactive approach might cost 5,000 tokens total: the agent takes an action, observes the result, takes another action, and so on until done. A proactive planning approach might generate a plan consuming 3,000 tokens, then execute more efficiently, consuming only 3,500 tokens in execution. Total: 6,500 tokens. The proactive approach costs more overall despite more efficient execution. The planning overhead exceeds the execution savings.

Now consider a complex task: analyze customer feedback from ten sources, identify themes, prioritize issues, and generate recommendations. A reactive approach might take thirty steps with repeated backtracking, consuming 35,000 tokens. A proactive approach might spend 8,000 tokens on planning but execute in twenty efficient steps totaling 18,000 tokens, for 26,000 total. Here, planning pays for itself. The execution savings exceed the planning cost.

The paradox is that you often cannot know which situation you are in until after you have planned. The task might look complex enough to justify planning, but turn out to be simple once you start. Or it might look simple but reveal hidden complexity that makes you wish you had planned more. You must commit to a planning budget before knowing whether that budget will be well-spent.

The problem intensifies under hard budget constraints. If your task has a token budget of 10,000 tokens, and you spend 4,000 on planning, you have only 6,000 left for execution. If execution requires 7,000 tokens, you will fail. You would have been better off spending 1,000 tokens on rough planning and 9,000 on execution, accepting somewhat less optimal execution in exchange for actually completing the task.

Budget-aware planning is the discipline of allocating your token budget between planning, execution, and reflection in a way that maximizes the probability of task completion within budget. It requires understanding how planning budget affects plan quality, how plan quality affects execution efficiency, and where the tradeoffs favor more planning versus more execution.

## Token Budget Allocation Strategies

The simplest budget allocation strategy is fixed percentages: allocate X percent to planning, Y percent to execution, Z percent to reflection and error handling. A common split might be 10 percent planning, 80 percent execution, 10 percent buffer. For a 10,000 token budget, that is 1,000 tokens for planning, 8,000 for execution, 1,000 for handling surprises. This approach is easy to implement and provides predictable resource distribution.

The advantage of fixed percentages is simplicity and predictability. You know upfront how much you can spend on planning, which prevents runaway planning costs. The agent generates a plan within the planning budget and then executes within the execution budget. If the execution budget proves insufficient, you have the buffer to handle it. If you run out of budget entirely, at least you made it through planning and attempted execution.

The disadvantage is that the optimal allocation varies by task. Simple tasks need minimal planning—allocating 10 percent to planning might be wasteful. Complex tasks need extensive planning—allocating only 10 percent might produce such a poor plan that execution flails. Fixed percentages ignore task characteristics and force a one-size-fits-all allocation that fits few tasks perfectly.

Adaptive allocation adjusts the planning budget based on task characteristics. The agent assesses the task's complexity, uncertainty, and structure, then allocates more budget to planning for complex tasks and less for simple tasks. A simple task might get 5 percent planning, 90 percent execution, 5 percent buffer. A complex task might get 20 percent planning, 70 percent execution, 10 percent buffer. The allocation reflects the expected planning difficulty.

The challenge with adaptive allocation is measuring task complexity before planning. The agent must analyze the task description and predict how much planning will be needed without actually planning. This prediction is itself a reasoning task that consumes tokens. If the prediction is wrong, you either over-allocate to planning and run out of execution budget, or under-allocate to planning and execute inefficiently.

Progressive allocation is a dynamic approach where the agent starts with a minimal planning budget, generates a rough plan, checks if more planning is needed, allocates more budget if necessary, and iterates. The agent might spend 500 tokens on a high-level plan, evaluate whether that plan is sufficient to begin execution, and if not, spend another 500 tokens refining it. This continues until the plan is good enough or the planning budget is exhausted. The advantage is that you pay for planning only as needed. The disadvantage is overhead from repeated planning phases and the difficulty of knowing when the plan is good enough.

Some teams use a two-tier system: mandatory planning and optional planning. Mandatory planning is a minimal upfront plan that every task gets, consuming a small fixed budget. Optional planning is additional planning allocated only if the mandatory plan reveals complexity that justifies it. This combines the predictability of fixed allocation with the flexibility of adaptive allocation.

Another strategy is opportunity cost allocation: the agent estimates the cost of execution with perfect planning versus execution with minimal planning, calculates the expected savings from better planning, and allocates planning budget up to the point where additional planning budget produces less than one dollar of execution savings per dollar spent. This is economically optimal in theory but difficult to estimate accurately in practice.

## Cost-Aware Plan Generation

When your agent operates under a budget constraint, the plan itself must respect that constraint. The agent cannot simply generate the best plan for the task—it must generate the best plan that fits within the remaining budget after planning costs are accounted for. This is a harder problem than unconstrained planning because the plan must be both effective and affordable.

Cost-aware planning requires the agent to estimate the cost of each action before including it in the plan. When considering whether to add "search for competitor X's recent press releases" to the plan, the agent estimates that this action will consume approximately 800 tokens: 200 for the search query generation, 400 for the search API response, and 200 for processing the results. If the remaining execution budget is only 600 tokens, the action cannot be included. The agent must find a cheaper alternative or simplify the plan.

This cost estimation is approximate and uncertain. The agent does not know exactly how many tokens each action will consume until it executes the action. Search results might be shorter or longer than expected. Processing might be simpler or more complex. The agent must work with estimates that have significant error margins. A disciplined approach includes safety margins: if an action is estimated at 800 tokens, budget 1,000 to account for uncertainty.

Cost-aware planning favors cheaper tool calls when multiple tools can accomplish the same goal. If the agent can gather information via web search or via an API call, and the web search costs 500 tokens while the API call costs 1,200 tokens, the cost-aware plan chooses web search. Quality might be slightly lower, but the task can be completed within budget. Without budget constraints, the agent might choose the API call for better data quality. Budget awareness shifts the optimization from quality to cost-effectiveness.

Another cost-aware pattern is preferring shorter reasoning chains. If the agent can achieve the goal in three steps with complex reasoning at each step, or in five steps with simple reasoning at each step, the five-step plan might be cheaper overall if the reasoning cost per step is significantly reduced. Longer chains with simpler steps can be more budget-efficient than shorter chains with expensive steps.

Cost-aware planning also involves deferring or eliminating optional steps. If the plan includes ten steps, three of which are optional enhancements that improve quality but are not strictly necessary, and the budget is tight, the cost-aware plan omits those steps. The agent completes the core task within budget rather than attempting a comprehensive solution and running out of resources partway through.

Some agents implement plan degradation: they generate an ideal plan assuming unlimited budget, then progressively simplify it to fit the actual budget. The agent removes the least valuable steps first, substitutes cheaper alternatives for expensive steps, and continues until the plan fits within budget. This ensures that the plan uses the available budget efficiently while maintaining as much quality as possible.

## Progressive Budget Consumption Tracking

Budget-aware agents need real-time tracking of budget consumption during execution. The agent must know how much budget has been spent, how much remains, and how the current consumption rate compares to the plan's assumptions. This tracking enables mid-execution adjustments when the agent is consuming budget faster or slower than expected.

The simplest tracking is a running token counter. Before each action, the agent checks the counter. After each action, the counter is incremented by the tokens consumed by that action. When the counter exceeds the budget limit, execution stops. This prevents budget overruns but provides no early warning or adaptation opportunity.

More sophisticated tracking includes burn rate analysis. The agent calculates how many tokens it is consuming per step and projects whether it will complete the plan within budget at the current rate. If the agent is three steps into a ten-step plan and has already consumed 40 percent of the budget, the burn rate is too high. The agent should simplify the remaining steps or re-plan with cheaper alternatives.

Budget tracking should distinguish between planning tokens, execution tokens, and overhead tokens. Overhead includes error handling, retries, reflection, and any meta-reasoning about the plan. By tracking each category separately, you can identify where budget is being spent. If overhead is consuming 20 percent of the budget, that is a signal to reduce retries or simplify error handling. If planning consumed 30 percent, that is a signal to allocate less to planning in future similar tasks.

Some agents implement budget checkpoints: predefined points in the plan where the agent checks budget status. Before starting a major phase of the plan, the agent verifies that enough budget remains to complete that phase. If not, the agent either simplifies the phase or skips it and moves to a cheaper alternative. Checkpoints provide structured points for budget-aware decision-making without the overhead of checking after every single action.

Real-time tracking also enables dynamic reallocation. If the agent budgeted 1,000 tokens for buffer but the plan executed more efficiently than expected and the buffer is not needed, those tokens can be reallocated to reflection or to optional plan steps. Conversely, if execution is consuming more than budgeted, tokens can be pulled from the buffer to avoid running out mid-plan.

Budget tracking is more complex when actions have uncertain costs. An API call might cost anywhere from 200 to 2,000 tokens depending on the response size. The agent must decide whether to execute the call based on the expected cost and the risk. If the budget remaining is 1,500 tokens and the call's expected cost is 600 tokens with a max of 2,000 tokens, executing the call risks exceeding the budget. A conservative agent skips the call. A risk-tolerant agent executes it and hopes the actual cost is closer to the expected value.

## What to Do When the Budget Runs Out Mid-Plan

Budget exhaustion is a failure mode that budget-aware agents must handle gracefully. The agent is partway through a plan, has consumed the entire budget, and cannot complete the remaining steps. What should it do? The answer depends on the task's requirements and the current state.

The first decision is whether to stop immediately or attempt to complete a partial result within the remaining budget. If the task requires a complete analysis and stopping mid-way produces no value, the agent should stop, report partial progress, and explain why it could not complete the task. If partial results have value, the agent should use any remaining budget to package what it has accomplished into a usable output.

Some agents implement graceful degradation: when budget is exhausted, the agent switches to a minimal-cost completion strategy. Instead of thorough analysis, it provides a summary of what it has found so far. Instead of detailed recommendations, it provides high-level themes. The output quality is lower, but the user gets something rather than nothing.

Another pattern is checkpoint resumption: the agent saves its state when the budget is exhausted, reports how far it got, and allows the task to be resumed later with additional budget. The user can allocate more budget and the agent continues from the checkpoint. This is useful for large tasks where budget limits are per-session but the task can span multiple sessions.

If the agent detects budget exhaustion before it happens—the budget is almost gone and the remaining plan cannot be completed—it can abort the current plan and switch to a cheaper alternative. Instead of completing the original ten-step plan with steps seven through ten, it might execute a simplified two-step plan that provides a basic answer to the original question. This requires the agent to maintain awareness of alternative strategies and the ability to switch strategies mid-execution.

Some tasks allow for incremental delivery: the agent completes as much as it can within budget and returns a partial result with clear indication of what is missing. For example, if asked to analyze twelve competitors but budget runs out after analyzing eight, the agent returns analysis of eight competitors and notes that four were not analyzed due to budget constraints. The user can decide whether the partial result is sufficient or whether to allocate more budget for the remainder.

Budget exhaustion should always be communicated clearly to the user. The agent should not silently truncate its work or pretend it completed a task when it did not. The message should explain what was accomplished, what was not, why the budget was insufficient, and what would be needed to complete the task. This transparency allows the user to make informed decisions about whether to allocate more budget or accept the partial result.

## The Relationship Between Planning Budget and Plan Quality

Plan quality generally increases with planning budget, but the relationship is not linear and has diminishing returns. The first 500 tokens of planning might take you from no plan to a rough outline, a large quality jump. The next 500 tokens might refine the outline into a detailed plan, another significant improvement. The next 500 tokens might add minor optimizations and edge case handling, smaller improvements. After some point, additional planning budget produces minimal quality gains.

The exact curve depends on task complexity. For simple tasks, plan quality saturates quickly—spending more than 300 tokens on planning a straightforward search-and-summarize task is wasteful. For complex tasks, plan quality continues improving up to several thousand tokens as the agent reasons through dependencies, optimizes sequencing, and anticipates failure modes.

Plan quality also depends on what the planning budget is spent on. Budget spent on high-level strategy yields more quality improvement than budget spent on low-level details. An agent that spends 1,000 tokens on overall approach and 200 tokens on specific tool parameters will produce a better plan than an agent that spends 200 tokens on approach and 1,000 tokens on parameters. The architecture of the planning prompt influences how budget translates to quality.

Empirical data from production systems in 2026 shows that for most tasks, the optimal planning budget is between 5 and 15 percent of total budget. Below 5 percent, plans are too rough and execution inefficiency exceeds planning savings. Above 15 percent, diminishing returns set in and the budget spent on planning would produce more value if spent on execution. The exact optimum varies, but 10 percent is a good default for mixed task workloads.

Some tasks have non-monotonic relationships between planning budget and outcome quality. The agent might produce a decent plan with minimal planning, a worse plan with moderate planning as it overthinks and complicates the approach, and then a good plan with extensive planning as it works through the complications. This U-shaped curve is rare but appears in tasks where initial intuition is reasonable, shallow analysis reveals apparent complexity that is actually illusory, and deep analysis reveals the underlying simplicity. Budget allocation for these tasks is particularly difficult.

## Practical Strategies for Budget-Aware Planning

The most practical approach for most production systems is to implement a planning budget cap with adaptive scaling. Set a maximum planning budget as a percentage of total budget—typically 10 to 20 percent—and allow the agent to spend up to that cap based on task complexity signals. Simple tasks trigger minimal planning. Complex tasks trigger planning up to the cap. This combines predictability with adaptability.

Use rough planning as the default strategy. Instead of generating detailed step-by-step plans, the agent generates high-level phase-based plans: "Phase one: gather data. Phase two: analyze data. Phase three: generate output." Each phase is then planned reactively during execution. This reduces planning budget while maintaining strategic coherence. The rough plan costs 200 to 500 tokens. Detailed phase planning during execution costs 100 to 200 tokens per phase, totaling less than a detailed upfront plan.

Implement cost estimation in your planning process. The agent should estimate the token cost of each planned action and sum these estimates to predict total execution cost. If the prediction exceeds the available execution budget, the agent should simplify the plan before starting execution. This prevents the common failure mode of running out of budget mid-plan.

Cache plans for recurring tasks. If your agent performs similar tasks repeatedly, the plan from the first instance can be reused for subsequent instances with minor parameter adjustments. The planning cost is amortized across multiple executions. This works well for templated tasks like "analyze competitor X" or "summarize meeting notes." The first execution incurs full planning cost. Subsequent executions reuse the plan at near-zero cost.

Monitor planning effectiveness in production. Track metrics like planning cost as percentage of total cost, plan completion rate, and execution efficiency. If you see high planning costs but low completion rates, your planning budget is too high and should be reduced. If you see low planning costs but frequent replanning or backtracking, your planning budget is too low and should be increased. Use data to tune your allocation over time.

Build budget awareness into your agent's prompts. The system prompt should include the budget constraint and instruct the agent to generate plans that respect it. Explicit budget awareness in prompts significantly improves budget adherence compared to implicit budget enforcement via token limits. The agent reasons about budget tradeoffs rather than blindly planning until cut off.

Finally, remember that budget-aware planning is about completing tasks within resource constraints, not about perfect optimization. A plan that costs 8,000 tokens and completes the task successfully is better than a plan that costs 3,000 tokens but produces a better result for 9,000 tokens total. The goal is not minimum cost or maximum quality in isolation—it is maximum value delivered within budget. Budget-aware planning optimizes for this real-world objective.

## Budget Constraints and Planning Granularity

The granularity of your plan—how detailed it is—directly affects planning cost. A high-level plan that says "gather data, analyze it, generate report" might cost 200 tokens. A detailed plan that specifies every search query, every data source, every analysis step, and every section of the report might cost 3,000 tokens. The question is whether the additional detail justifies the additional cost.

For predictable tasks where the details are obvious once you know the high-level approach, fine-grained planning is wasteful. An agent that has gathered data before knows how to analyze it. The detailed steps do not need to be planned upfront—they can be determined reactively during execution. The rough plan provides strategic direction. The details fill themselves in.

For unpredictable tasks where the details are not obvious, fine-grained planning can prevent costly mistakes. If the analysis approach depends on the structure of the data, and that structure varies, planning the approach in detail ensures the agent does not start down the wrong path and waste execution budget. The upfront planning cost prevents larger downstream waste.

The challenge is that you often do not know whether details are obvious until you try to fill them in. This creates another dimension of the planning paradox: you need detailed planning to know if detailed planning is necessary, but detailed planning is expensive. Some agents address this with hierarchical planning: create a rough plan, identify which parts are uncertain or complex, add detail only to those parts, leave the rest rough. This targets planning budget where it provides the most value.

Budget constraints also affect plan flexibility. A rigid plan is cheaper to generate than a flexible plan with contingencies and alternatives. But rigid plans fail when assumptions are violated, requiring expensive re-planning or backtracking. Flexible plans cost more upfront but save budget during execution by adapting smoothly to surprises. The optimal flexibility depends on environmental uncertainty and the cost of replanning versus the cost of building in flexibility upfront.

## How Different Agent Architectures Handle Planning Budgets

Different agent frameworks make different tradeoffs in planning budget allocation. ReAct-style agents spend minimal budget on planning—just enough reasoning to decide the next action—and invest most budget in execution. This works well for exploratory tasks where you cannot plan effectively without taking actions to gather information. The planning budget is near zero. The execution budget is the entire budget minus per-step reasoning overhead.

Plan-and-execute agents front-load planning budget. They generate a complete plan before taking any actions, often spending 20 to 30 percent of total budget on planning. This works well for structured tasks where thorough planning yields significant execution efficiency gains. The risk is that plan generation consumes so much budget that execution must be rushed or simplified.

Hierarchical agents use a graduated planning budget. They spend a small budget on high-level planning, then allocate additional budget to detailed planning for each high-level step as it is executed. Total planning budget is moderate—perhaps 15 to 20 percent—but it is distributed across the execution timeline rather than concentrated upfront. This balances strategic coherence with reactive adaptation.

Iterative refinement agents alternate between planning and execution. They generate a rough plan, execute one or two steps, refine the plan based on what they learned, execute more steps, refine again. Planning budget is distributed across multiple small planning phases rather than one large upfront phase. This allows the agent to incorporate new information into planning without expensive re-planning from scratch. The overhead is in the transitions between planning and execution phases.

Your choice of architecture determines your planning budget profile. If you are building a new agent system, consider which profile matches your task characteristics. If you are optimizing an existing system, measure your actual planning budget consumption and compare it to your architecture's expected profile. Deviations indicate opportunities for optimization.

## The Impact of Model Capabilities on Planning Budget

Stronger models can generate better plans with less budget. GPT-4 might produce a high-quality plan in 1,000 tokens that takes GPT-3.5 three thousand tokens to produce. Claude Opus might reason through complex dependencies in 800 tokens that takes a smaller model 2,000 tokens. The model's reasoning capability directly affects how efficiently it converts planning budget into plan quality.

This creates a tradeoff between model cost and planning efficiency. A more expensive model per token might actually be cheaper per task if it requires significantly less planning budget. If Model A costs twice as much per token as Model B but produces the same quality plan in half the tokens, the planning cost is the same. If the more efficient planning also leads to more efficient execution, Model A becomes cheaper overall despite higher per-token cost.

In 2026, many teams use tiered model strategies for budget-aware planning. Small models for simple routine tasks where minimal planning suffices. Medium models for typical tasks where moderate planning is needed. Large models for complex tasks where thorough planning prevents expensive execution failures. The model tier is selected based on estimated task complexity, and the planning budget allocation is adjusted accordingly.

Another approach is to use a large model for planning and a smaller model for execution. The large model generates a detailed plan at moderate token cost because of its efficiency. The small model executes the plan step by step, which is cheaper because execution is more mechanical than planning. This division of labor optimizes cost by matching model capability to task requirements.

The frontier in 2026 is adaptive model selection where the agent starts with a small model, detects when planning is becoming difficult based on plan quality metrics or uncertainty signals, and escalates to a larger model only when necessary. This minimizes cost while ensuring complex tasks get the planning capability they need. Implementation requires confidence scoring and escalation triggers, which adds system complexity.

## Real-World Budget Tuning Based on Production Data

The theoretical guidelines for planning budget allocation—10 percent planning, 80 percent execution, 10 percent buffer—are starting points, not final answers. Your optimal allocation depends on your specific tasks, tools, model, and performance requirements. You discover the optimum through measurement and iteration.

Start by instrumenting your agent to track budget consumption by phase. Log how many tokens were spent on planning, execution, error handling, and reflection for each task. Aggregate this data across hundreds or thousands of tasks. Look for patterns. Are you consistently spending more on planning than your target allocation? Are you running out of budget during execution? Is error handling consuming unexpectedly large portions of budget?

Segment your analysis by task type. Some tasks might need 20 percent planning while others need only 5 percent. If you are using a single allocation across all tasks, you are over-spending on some and under-spending on others. Task-specific allocations improve efficiency. You can implement these allocations by detecting task type from the task description or by allowing users to specify task complexity hints.

Track planning effectiveness metrics in addition to planning cost. High planning cost is acceptable if it produces high-quality plans that execute efficiently. Low planning cost is problematic if it produces poor plans that require extensive backtracking or fail entirely. The metric you care about is cost per successful task completion, not planning cost in isolation. A task that spends more on planning but completes successfully is better than a task that spends less on planning but fails.

Look for tasks that exceed budget before completion. These are your highest-priority optimization targets. Analyze why they failed. Was planning too expensive? Was execution inefficient? Were there unexpected errors that consumed buffer budget? Each failure mode suggests a different intervention. Too much planning means reduce planning allocation. Inefficient execution means improve plan quality or tool selection. High error overhead means improve error handling or tool reliability.

Run A/B tests on planning budget allocation. For a sample of tasks, randomly assign different planning budgets—say 5 percent, 10 percent, and 15 percent—and measure success rate, total cost, and quality. The allocation with the best balance of success and cost becomes your new default. Re-run these tests periodically as your agent evolves and task mix changes.

Your agent operates in a resource-constrained world where tokens are money and money is finite. Planning consumes resources that execution needs. The planning budget paradox is unavoidable, but you can manage it effectively by allocating budget thoughtfully, tracking consumption actively, adapting when needed, and always keeping the end goal in focus: delivering value within the resources available. Budget-aware planning is not a one-time design decision—it is an ongoing practice of measurement, learning, and optimization that separates production-ready agents from prototypes.
