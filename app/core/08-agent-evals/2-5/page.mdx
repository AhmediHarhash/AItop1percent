# 2.5 — ReWOO: Decoupled Planning and Execution for Reduced Latency

In August 2025, a travel tech company serving business travelers was hemorrhaging customers because their AI trip planner was too slow. Users would submit complex queries like "Find me a three-day trip to Portland with vegetarian restaurants, outdoor activities, and lodging under two hundred dollars per night," and then wait eighteen to twenty-two seconds for results. The agent used a ReAct pattern: it would search for restaurants, examine the results, search for activities based on the restaurant locations, examine those results, search for hotels in areas near both, and synthesize a final plan. Each step waited for the previous step's results before deciding what to do next. This sequential dependency was killing their conversion funnel. Analytics showed that users who waited more than eight seconds had a forty-seven percent drop-off rate. The engineering team knew they needed lower latency but couldn't figure out how to parallelize a process where each decision depended on previous outcomes.

The breakthrough came when they realized that while the execution needed to be sequential to be safe, the planning could happen upfront. The agent could analyze the query, determine all the information it would need, and issue all the search requests at once. Instead of search-then-think-then-search-then-think, they could think-then-search-everything-then-synthesize. This architectural shift reduced their median response time from twenty seconds to seven seconds, a sixty-five percent improvement. Conversion rates recovered and the product became viable. What they'd discovered, independently, was the core insight behind ReWOO: decoupling planning from execution to enable parallelism.

## The Core Mechanism: Planning Before Execution

The ReWOO pattern—Reasoning Without Observation—inverts the standard agent execution model in a way that fundamentally changes latency characteristics. In ReAct and most agent frameworks, reasoning and tool use are interleaved: you reason about what to do next, execute a tool, observe the result, reason about what to do next based on that result, execute another tool, and so on. Each reasoning step has access to all previous observations, which makes the agent adaptive but inherently sequential. ReWOO separates these phases: first you plan all the tool calls you'll need, then you execute them all in parallel, then you reason over all the results at once to produce the final answer.

The planning phase is where the intelligence lives. You present the agent with the user's query and available tools, and instead of asking it to immediately execute a tool, you ask it to produce a plan: a structured specification of all the tool calls needed to answer the query. For the travel planning example, the plan might specify: search restaurants with constraints vegetarian and Portland, search activities with constraints outdoor and Portland, search hotels with constraints Portland and max-price two hundred. Each planned tool call includes the tool name and its parameters, but none are executed yet. This planning output becomes the execution blueprint.

This planning prompt requires careful design because the agent must predict what information it will need without seeing any actual results. In ReAct, the agent might search for restaurants, see that most are clustered in the Pearl District, and then specifically search for activities in that neighborhood. In ReWOO, the agent doesn't get to see restaurant locations before planning the activity search. It must either make the activity search broad enough to cover wherever restaurants might be, or make assumptions about likely clustering, or include placeholder logic that will use restaurant results when they become available. The planner is operating without the benefit of ground truth.

The execution phase is straightforward once you have the plan: take the plan and execute all tool calls in parallel. If the plan specifies five searches, you make five API calls simultaneously. If the plan includes database queries, web scrapes, and calculations, you run them all at once. This parallelism is the source of ReWOO's speed advantage. What would have taken five sequential round trips—search, wait for results, search again, wait for results, and so on—now takes one round trip because all external calls happen together. The wall-clock time is determined by the slowest individual tool call rather than the sum of all calls.

The synthesis phase brings everything together. Once all tool executions complete, you present the agent with the original query, the plan it created, and all the tool results. Now the agent's job is pure reasoning: combine this information to answer the user's question. For trip planning, it examines the restaurant results, activity results, and hotel results, identifies options that satisfy the constraints, builds a coherent itinerary, and formats it for the user. This synthesis reasoning can be as complex as needed because it's not gated by external API calls; it's just model inference over data already in context.

## Why This Delivers Lower Latency Than Sequential Execution

The latency difference between ReWOO and ReAct stems from how they handle external dependencies. In ReAct, each tool call is a blocking operation. The agent requests information, waits for it, processes it, and only then decides what to request next. If each tool call has an average latency of three seconds and you need five tool calls, your minimum total latency is fifteen seconds plus the time for reasoning steps. Network variability makes it worse: some calls take four seconds, others two, but you always wait for each to complete before moving forward. This creates a latency profile where total time grows linearly with the number of tool calls needed.

ReWOO collapses all those sequential waits into a single parallel wait. If you need five tool calls and each takes three seconds, your latency is three seconds—the longest call—plus planning time plus synthesis time. Even if planning and synthesis each take two seconds, your total is seven seconds compared to ReAct's fifteen-plus seconds. The speedup is roughly proportional to the number of tool calls: more tools means more sequential steps in ReAct but the same parallel batch in ReWOO. You've converted a linear time complexity into a constant time complexity with respect to tool count.

The speedup is most dramatic when tool calls have high variance in latency. Imagine you need results from five different APIs: a fast cache that returns in half a second, a database query that takes one second, an external search that takes three seconds, a complex computation that takes four seconds, and a slow third-party API that takes six seconds. In ReAct, you might hit these sequentially for a total of fourteen-point-five seconds. In ReWOO, you hit them all at once and wait six seconds for the slowest to return. The fast operations don't add to latency at all; they complete while you're waiting for the slow ones. This means ReWOO's advantage increases as latency variance increases.

Another latency source that ReWOO eliminates is reasoning between tool calls. In ReAct, after each observation, the agent must reason about what to do next: interpret the results, decide if more information is needed, formulate the next query. Each of these reasoning steps involves model inference, which for large models like GPT-4o or Claude 4 can take one to three seconds depending on context size and generation length. If you have five tool calls, you have four inter-call reasoning steps, adding four to twelve seconds of latency. ReWOO has only two reasoning steps: planning at the start and synthesis at the end. You've eliminated all the intermediate reasoning, which both reduces latency and reduces token consumption.

The cumulative effect is that ReWOO can achieve latency reductions of fifty to seventy percent for tasks that require multiple tool calls, and the reduction scales with task complexity. A simple two-tool task might only see thirty percent reduction, while a ten-tool research task might see eighty percent reduction. The pattern becomes increasingly valuable as your agent's tool usage increases, making it particularly relevant for complex information-gathering workflows.

## The Fundamental Tradeoff: Adaptability for Speed

The cost of this speed is flexibility, and understanding this tradeoff is critical for knowing when to apply the pattern. ReAct's sequential structure allows the agent to adapt its strategy based on what it learns. If the first search returns no results, the agent can broaden the query or try a different approach. If the results reveal an unexpected constraint or opportunity, the agent can pivot its investigation. ReAct is fundamentally adaptive: each step is informed by all previous steps, and the agent's plan evolves as it gathers information. This adaptability is valuable when working in uncertain environments where you can't predict what you'll find.

ReWOO commits to a fixed plan before seeing any results. If the plan includes a search for vegetarian restaurants in Portland and there aren't any in the database, you won't discover that until after all tool calls complete. You can't adapt mid-execution because execution is already happening in parallel. The agent must predict at planning time what information it will need, and that prediction must be correct even in the face of uncertainty about what the tool results will contain. You're betting that your planner is smart enough to anticipate the information landscape without seeing it.

This limitation manifests in several ways. The most obvious is query failures: the agent plans a tool call that turns out to be impossible or nonsensical based on earlier results. Imagine planning to find hotels near a specific landmark, but the landmark search returns no results. The hotel query is now meaningless, but it executes anyway because it was in the plan. You waste a tool call on a query that could have been avoided if you'd seen the landmark search failure first. In ReAct, you would observe the failure and adapt; in ReWOO, you've already committed.

A subtler problem is missed opportunities. Real-world data often contains surprises that suggest better approaches than your initial plan. A ReAct agent searching for trip activities might notice that several top-rated restaurants are in a particular neighborhood, realize that concentrating the itinerary there would reduce travel time, and adjust subsequent searches to focus on that area. This kind of data-driven optimization happens naturally in sequential execution. A ReWOO agent doesn't see the restaurant results until after it's already executed the activity search, so it can't make that geographic optimization. The plan is locked in before the data arrives.

The third issue is redundancy. Without intermediate observations, the planning agent often includes fallback queries or broad searches to ensure it gets usable information. You might search for both "vegetarian restaurants Portland" and "restaurants Portland with vegan options" because you're not sure which will return better results. In ReAct you'd try one, see if it worked, and conditionally try the other. In ReWOO you try both because you can't see the first result before deciding on the second. This can lead to executing more tool calls than strictly necessary, partially offsetting the parallel efficiency gains.

The deeper architectural implication is that ReWOO works best when the information landscape is predictable. If you know what kinds of results your tools typically return, what patterns appear in the data, what edge cases exist, your planner can account for these in advance. But if you're operating in a domain where each query reveals surprising information that should inform the next query, ReAct's adaptability becomes essential. The pattern choice is fundamentally about whether your task has stable structure or emergent structure.

## Task Profiles Where ReWOO Excels

The pattern works best when tool calls are genuinely independent: the parameters and relevance of one tool call don't depend on the results of another. Pure information gathering tasks often have this property. If a user asks "Compare the GDP, population, and climate of Norway, Japan, and Brazil," you can plan six independent lookups: GDP of Norway, GDP of Japan, GDP of Brazil, population of Norway, population of Japan, population of Brazil. None of these queries depends on the results of the others. Executing them in parallel is pure upside: you get all the data in one round trip instead of six sequential trips.

Research and fact-checking tasks are another good fit. Imagine an agent that verifies claims in an article by searching for supporting or contradicting evidence. Given a list of claims, the agent can plan a search for each claim, execute all searches in parallel, and then synthesize whether each claim is supported, contradicted, or unverifiable based on the collected evidence. The searches are independent because each claim stands alone; you don't need to verify claim one before knowing how to verify claim two. This kind of parallel verification is what makes large-scale fact-checking tractable.

Data aggregation from multiple sources works well with ReWOO. A financial analysis agent might gather quarterly earnings, stock prices, analyst ratings, and news sentiment for a set of companies. These are parallel lookups from different data sources. The planning phase identifies which companies and which data points are needed. The execution phase hits all the APIs at once—financial data service, market data feed, ratings database, news sentiment API. The synthesis phase combines the data into a comparative analysis. The independence of data sources makes parallelization natural and safe.

Dashboard and report generation benefits from ReWOO because these tasks involve collecting diverse metrics that don't influence each other. A system monitoring agent might gather CPU usage, memory stats, error rates, request latencies, and database performance metrics. These are independent queries to different monitoring systems. Executing them in parallel cuts the dashboard load time from seconds to subsecond, making real-time monitoring viable. Users refresh dashboards frequently; every second of latency reduction translates to better user experience and lower infrastructure cost from reduced polling.

The pattern also excels when you can enumerate queries deterministically from the user's input. If the user provides a structured request like "Get me weather forecasts for these five cities" or "Fetch the profiles for these user IDs," you don't need sophisticated planning. The tool calls are obvious from the input structure, and they're inherently independent. You just map over the list, create one tool call per item, execute in parallel, and aggregate results. This makes ReWOO attractive for batch processing workflows where a single user request triggers many similar operations.

Multi-source validation tasks fit the pattern well. If you're building an agent that needs to verify information by checking multiple authoritative sources before presenting it to users, you can plan lookups across all your sources, execute them in parallel, and synthesize based on consensus or disagreement. A medical information agent might check Mayo Clinic, Cleveland Clinic, Johns Hopkins, and NIH databases simultaneously, then synthesize an answer that reflects the medical consensus while flagging any disagreements among sources.

## Task Profiles Where ReWOO Fails

The clearest failure mode is hard dependencies: tasks where step N genuinely cannot be formulated until you see the results of step N minus one. Debugging workflows often have this structure. You start by checking if a service is running. If it's down, you investigate why it stopped. If it's running, you check if it's responding to requests. The second step depends entirely on the first step's outcome; you can't plan both in advance because they're mutually exclusive paths. ReWOO can't handle this branching structure without knowing which branch to take.

Multi-step reasoning tasks with branching logic don't parallelize well. Consider a medical diagnosis agent: check symptoms, based on symptoms order relevant tests, based on test results recommend treatment. The test selection depends on symptoms, and the treatment depends on test results. You can't plan all three steps upfront because you don't know which tests are relevant until you've analyzed symptoms, and you don't know which treatment is appropriate until you've seen test results. ReWOO can handle the symptom analysis, but the subsequent steps need ReAct's adaptive structure.

Exploratory tasks where you're searching through a large space also challenge ReWOO. Imagine an agent investigating a bug in a large codebase. You might start by searching for error messages, which points you to specific files, which you then read to understand the code, which reveals dependencies you need to check, which might require searching for configuration files, and so on. Each step reveals what to investigate next. You can't plan this investigation upfront because the path through the codebase emerges from what you find. ReAct's ability to observe and adapt is essential for exploration.

Tasks that require iterative refinement don't fit the ReWOO model. If you're generating creative content and need to search for inspiration, evaluate what you've generated, search for more specific examples based on gaps, and refine the output, that iterative loop with feedback between generation and search requires sequential execution. You might be able to parallelize within an iteration—searching multiple inspiration sources at once—but the iteration structure itself demands observation between steps. Creative and analytical tasks often have this iterative character.

High-uncertainty environments where tool results are unpredictable make planning difficult. If you're dealing with flaky APIs that often return errors, incomplete data, or rate limits, your plan needs contingencies: if this search fails, try this alternative; if you get rate-limited, switch to a different data source. Encoding all these contingencies into a static plan is complex and error-prone. ReAct handles uncertainty gracefully by observing failures and adapting; ReWOO requires predicting all possible failures at planning time, which is often infeasible.

Tasks where the user's intent is ambiguous also struggle with upfront planning. If a query could be interpreted multiple ways and you need to gather some information to disambiguate before knowing what other information to gather, you need sequential execution. A ReAct agent can make an initial search, use the results to infer which interpretation is correct, and then proceed accordingly. A ReWOO agent has to either guess the interpretation at planning time or plan for all interpretations simultaneously, leading to redundant execution.

## Cost Implications of Parallel Execution

While ReWOO reduces latency, it doesn't necessarily reduce cost. In fact, it can increase costs in several ways, and understanding the cost model is critical for production deployment. The first is redundant execution: you run tool calls that might turn out to be unnecessary because you can't see earlier results before committing to later queries. In ReAct, if your first search fully answers the question, you stop and avoid subsequent searches. In ReWOO, you've already planned and executed all the searches before discovering that the first one was sufficient. This means you're paying for tool calls you didn't need.

The second cost increase comes from broader queries. When you can't adapt based on intermediate results, you compensate by making queries more comprehensive to ensure you capture the needed information. Instead of a targeted search based on observed patterns, you run a broad search that returns more data than you need. This increases API costs for services that charge per result or per data volume. It also increases context size for the synthesis step because you're processing more total information, which means higher token costs for the synthesis inference.

Tool call failures in parallel execution waste resources differently than in sequential execution. In ReAct, if a tool call fails, you might abandon that approach and try a different one, avoiding further investment in a dead end. In ReWOO, if one of your parallel tool calls fails but others succeed, you've already spent resources on all of them. You can't recover the cost of the failed call, and you might not have a fallback planned because you committed to the plan before knowing it would fail. This makes ReWOO less resilient to partial failures.

That said, ReWOO can reduce costs in other ways. By eliminating intermediate reasoning steps between tool calls, you reduce the number of model inference calls. ReAct might require seven or eight model calls for a five-tool-call task: initial reasoning, reason after each observation, and final synthesis. ReWOO requires only two: planning and synthesis. For expensive models like Claude Opus 4.5 or GPT-4.5, this can offset the cost of redundant tool calls. The overall economics depend on the relative costs of model inference versus tool calls in your specific setup.

Another cost benefit is predictability. ReAct's cost varies based on how many adaptive steps the agent takes, which depends on the data encountered. One query might resolve in three tool calls while a similar query requires eight. This variance makes budgeting difficult and can lead to unexpectedly high costs on complex queries. ReWOO's cost is determined by the plan, which is generated before execution and can be analyzed for cost before committing. You can implement cost-based plan filtering: if the planned tool calls would exceed a budget threshold, reject the plan and ask the user to narrow the query. This gives you cost control that's harder to achieve with adaptive execution.

The token economics are also worth analyzing carefully. ReAct's intermediate reasoning steps each require putting the full conversation history plus new observations into context, which means token costs scale with the number of steps. ReWOO has two large context windows—planning and synthesis—but no intermediate steps. If your tool calls return large amounts of data, the synthesis context might be larger than the sum of ReAct's intermediate contexts, but if tool results are compact, ReWOO wins on token costs. You need to profile your actual task patterns to understand which architecture is more economical.

## Hybrid Architectures: Combining ReWOO and ReAct

The most sophisticated production systems don't choose between ReWOO and ReAct; they use both in a hybrid architecture that captures the benefits of each. One common pattern is staged execution: use ReWOO for the initial information gathering phase where queries are predictable and independent, then switch to ReAct for the analysis phase where you need to dig deeper based on what you found. For the trip planning example, you'd use ReWOO to gather all the restaurant, activity, and hotel data in parallel, then use ReAct to iteratively refine the itinerary based on constraints and preferences that emerge from the data.

Another hybrid pattern is conditional planning: generate a ReWOO-style plan with multiple branches for different contingencies, execute all the tool calls you'll definitely need in parallel, then adaptively execute conditional calls based on the results. Imagine a plan that says: "Fetch user profile and account balance in parallel. If balance is above one thousand dollars, fetch investment options; if below one thousand, fetch savings account options." You execute the first two calls immediately and in parallel. Based on the balance result, you adaptively choose which third call to make. You've parallelized what you can while remaining adaptive where necessary.

Hierarchical execution combines both patterns at different levels. At the high level, you use ReAct to adaptively break down a complex task into subtasks. At the subtask level, you use ReWOO to execute each subtask efficiently via parallel tool calls. For a complex research query, the high-level agent might adaptively decide to investigate three different angles based on initial findings. For each angle, it spawns a ReWOO subagent that plans and executes all relevant searches in parallel. This structure gets you strategic adaptability where it matters and tactical parallelism where it helps.

Speculative execution is another hybrid technique: plan and execute multiple possible next steps in parallel, then select which result to use based on what you learn. This is like ReWOO's parallelism but applied to ReAct's adaptive structure. After observing the first tool result, instead of choosing one next step and waiting for it, you predict the two or three most likely next steps, execute all of them in parallel, and then select the relevant result once you have all the information. You're trading redundant execution cost for reduced latency, getting some of ReWOO's speed without fully committing to a fixed plan.

Dynamic planning lets the agent regenerate the plan mid-execution if it detects that the initial plan won't work. You start with a ReWOO plan and execute it in parallel, but you also monitor for failure signals: tool errors, empty results, contradiction between requirements and available options. If you detect failure early—say, one of your parallel calls returns within five hundred milliseconds indicating no results found—you can cancel the remaining calls, replan with this new information, and execute a new parallel batch. This maintains ReWOO's parallelism for the normal case while adding a ReAct-style escape hatch for the failure case.

Progressive planning is a pattern where you plan in stages: make a rough plan for the overall task, execute the first batch of tool calls in parallel, use those results to refine the plan for the next batch, execute the second batch in parallel, and so on. This gives you parallelism within each batch while maintaining adaptability between batches. It's a middle ground between ReWOO's full upfront planning and ReAct's step-by-step execution, trading some latency for flexibility while still achieving significant speedup over pure sequential execution.

## Production Implementation Patterns

Deploying ReWOO effectively requires understanding your task characteristics and making explicit tradeoffs. Start by profiling your agent's execution patterns under ReAct. How many tool calls does it typically make? How much latency does each add? How often does it adapt its approach based on intermediate results? If you see consistent patterns where most executions use similar tool call sequences and where adaptations are rare, that's a signal that ReWOO could work. If execution paths are highly variable and depend heavily on data encountered, ReAct's flexibility is probably worth the latency cost.

The next step is identifying which queries are truly independent. You might discover that seventy percent of your tool calls could be parallelized because they don't depend on each other, while thirty percent require sequential ordering. That's still a good candidate for ReWOO with fallback: plan and execute the independent calls in parallel, then handle the dependent calls adaptively afterward. You get the latency reduction on the parallelizable majority while accepting sequential execution for the dependent minority. This kind of partial parallelization often delivers eighty percent of the benefit with twenty percent of the complexity.

User experience requirements often drive the decision. If your product has strict latency SLAs—responses must complete in under five seconds, for example—and your current ReAct implementation averages eight to twelve seconds, you need architectural changes to meet the requirement. ReWOO becomes attractive not because it's elegant but because it's the only way to hit your latency targets. The loss of adaptability is an acceptable tradeoff for meeting user expectations. You might supplement with fallback mechanisms for edge cases, but the core flow needs the parallelism ReWOO provides.

Cost sensitivity points in different directions depending on your economics. If model inference is your dominant cost and tool calls are cheap—which is common when tools are internal database queries or cache lookups—ReWOO's reduction in reasoning steps saves money. If tool calls are expensive and model inference is cheap—which happens when tools are paid third-party APIs and you're using smaller models—ReWOO's potential for redundant tool execution increases costs. You need to model both scenarios with realistic pricing and task distributions to know which approach is more economical for your specific case.

Monitoring and instrumentation become critical for production ReWOO deployments because the pattern can fail in ways that aren't immediately obvious. You should track plan quality: how often do generated plans include unnecessary tool calls? How often do they miss necessary ones? Are there patterns in plan failures that suggest prompt improvements? You should also monitor synthesis quality: when the agent has all the tool results, does it successfully combine them into correct answers, or does it get confused by the parallel data? If synthesis quality is low, the latency savings are worthless because you're delivering wrong answers quickly.

Fallback logic handles cases where the planned tool calls don't provide sufficient information to answer the query. After synthesis, the agent should evaluate whether it has enough information to respond confidently. If not, it needs a mechanism to request additional data: either falling back to adaptive ReAct-style execution for follow-up queries or asking the user for clarification. The worst outcome is confidently presenting an incomplete or incorrect answer because the fixed plan didn't gather the right information. Better to be slow and right than fast and wrong, so your fallback mechanism is essential for maintaining quality.

Plan validation before execution is another critical production pattern. Once the agent generates a plan, you can programmatically check it for common errors: duplicate tool calls, tool calls with invalid parameters, missing required dependencies. This pre-execution validation catches many planning errors before you waste resources executing a broken plan. You can also implement cost estimation at this stage: calculate the expected cost of the plan and reject plans that exceed thresholds, forcing the agent to replan with tighter constraints.

## Building Planning Prompts That Work

The quality of your planning prompt determines whether ReWOO succeeds or fails in production. A good planning prompt needs to teach the agent to predict information needs accurately without seeing results. This requires showing the agent examples of successful plans—queries where the planned tool calls turned out to be exactly what was needed—and examples of failed plans—queries where the agent planned tool calls that turned out to be irrelevant or missed tool calls that were needed.

Your planning prompt should explicitly instruct the agent to think about dependencies and uncertainty. "For each tool call you plan, consider: does this tool call depend on the results of another tool call? If yes, can you still formulate it without those results, or does it need to be conditional? What might go wrong with this tool call, and do you need a fallback?" This metacognitive prompting helps the agent surface assumptions and identify risks in the plan before execution.

Another technique is to show the agent what good and bad plans look like for the same query. For a trip planning query, show a plan that includes focused searches with clear parameters, and contrast it with a plan that includes vague searches or redundant calls. Annotate why the first plan is better: "This plan uses specific geographic constraints that will return relevant results. It avoids redundant searches by choosing one clear approach rather than trying multiple similar queries." This helps the agent learn plan quality criteria.

You should also teach the agent to estimate result sizes and plan for synthesis complexity. "How many results do you expect each tool call to return? Will the synthesis step need to compare dozens of options or just a few? If you're planning many tool calls that each return many results, the synthesis might become overwhelming—consider whether you can narrow the searches or reduce the number of calls." This helps prevent plans that generate so much data that synthesis becomes infeasible.

Testing your planning prompts requires building evaluation sets with known-good query-plan pairs. For each query type your agent handles, create examples where you know what the optimal plan should be, execute that plan, and verify it produces good results. Then use those examples as both few-shot demonstrations in your planning prompt and as test cases for evaluating new planning prompts. This gives you a systematic way to improve planning quality over time.

## When ReWOO Is the Right Choice

The ReWOO pattern represents a specific tradeoff: you sacrifice adaptability and flexibility for parallelism and reduced latency. It's not better than ReAct in general; it's better for specific task profiles where queries are predictable, mostly independent, and where latency matters more than plan optimality. The pattern works brilliantly for information aggregation, dashboard generation, structured data gathering, and multi-source validation. It struggles with exploratory tasks, debugging workflows, creative iteration, and high-uncertainty environments where you need to adapt based on what you learn.

The production opportunity lies in recognizing which parts of your agent's workload fit the ReWOO profile and applying the pattern selectively rather than treating it as a universal replacement for adaptive execution. Most production systems end up with hybrid architectures that use ReWOO where it helps and fall back to ReAct where it doesn't. The engineering challenge is building the orchestration layer that decides which pattern to use for which query, and that gracefully transitions between them when needed.

Understanding ReWOO also prepares you for the next evolution in agent orchestration patterns, where decomposition and planning become first-class concerns that inform how agents structure their work. The ability to analyze a task, predict information needs, and plan parallel execution is valuable beyond just the latency benefits—it's a foundation for building agents that can handle genuinely complex workflows with multiple phases and dependencies. The pattern you'll explore next, Self-Ask and decomposition, builds on these planning capabilities to handle tasks where the structure itself needs to be discovered through careful problem breakdown.
