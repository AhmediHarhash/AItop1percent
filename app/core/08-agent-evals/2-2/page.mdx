# 2.2 — Plan-and-Execute: Upfront Planning for Complex Multi-Step Tasks

In September 2025, a fintech company building an agent to automate financial reconciliation deployed a ReAct-based system to their accounting team. The task seemed straightforward: take transaction records from multiple sources—payment processors, bank feeds, internal ledgers—identify discrepancies, investigate the causes, and produce a reconciliation report. The ReAct agent would examine one transaction, search for matching records, check another transaction, iterate through the dataset, flag mismatches, and generate a report.

The first production run processed 847 transactions and took 11 hours. The agent examined transactions in whatever order they appeared in the database. It searched for matching records one at a time. When it found a mismatch, it immediately investigated, even if investigating that specific mismatch required information it had not yet gathered. It discovered halfway through that several mismatches were caused by a single systematic issue—a payment processor had changed their timestamp format—but it had already wasted four hours investigating individual instances of the problem before recognizing the pattern.

A human accountant doing the same reconciliation would have taken a different approach. First, scan the dataset to understand its structure and identify patterns. Second, look for systematic issues that affect multiple transactions—timestamp format changes, duplicate entries, missing batches. Third, handle the systematic issues in bulk. Fourth, investigate the remaining individual discrepancies. Fifth, generate the report. The whole process would take 90 minutes.

The ReAct agent had no plan. It just reacted to each observation. The human had a plan before touching a single transaction. The difference in efficiency was dramatic: 11 hours versus 90 minutes.

The fintech team rebuilt the system using a plan-and-execute pattern. The agent now started by analyzing the dataset structure, generating a reconciliation plan that identified likely systematic issues and outlined the investigation sequence, and then executing the plan step by step. The same 847-transaction reconciliation completed in two hours, with better accuracy because the systematic issues were caught early. The plan made all the difference.

## How Plan-and-Execute Works: Planning First, Then Acting

The plan-and-execute pattern separates agent execution into two distinct phases: planning and execution. This separation is the core difference from ReAct, where planning and execution are interleaved.

**Phase one: Planning.** The agent receives the task and generates a structured plan before taking any action. The plan is an explicit sequence of steps, each with a clear objective, dependencies, and success criteria. The planning phase might involve reasoning about the task, decomposing it into sub-tasks, identifying information requirements, and determining the optimal sequence of actions.

The plan is not just a list of actions. It is a structured representation that captures:

- What steps are needed.
- What each step is trying to accomplish.
- What information or resources each step requires.
- What dependencies exist between steps.
- How to determine if a step succeeded or failed.
- What to do if a step fails.

The output of the planning phase is a plan object: a data structure that guides execution. This might be a linear sequence, a directed acyclic graph of steps with dependencies, or a hierarchical breakdown of tasks and sub-tasks.

**Phase two: Execution.** The agent executes the plan step by step. For each step, it performs the specified action, observes the result, and updates the plan state to mark the step as complete, failed, or requiring retry. Execution follows the plan but is not rigid. If a step fails, the agent can adapt: retry with different parameters, skip to an alternative step, or trigger replanning.

The key difference from ReAct is that the agent commits to a strategy before acting. It thinks ahead. It considers the full task, not just the immediate next step. This upfront investment in planning pays off when the task is complex enough that a coherent strategy improves outcomes.

## The Planning Phase: Generating Structured Plans from Goals

Generating a plan is a non-trivial task that requires reasoning about the problem structure, available tools, information requirements, and dependencies.

The simplest planning approach is to ask the LLM to generate a plan as structured text or JSON. You provide the task description and the available tools, and you prompt the model: "Generate a step-by-step plan to accomplish this task. For each step, specify the action, the tool to use, the expected outcome, and any dependencies on previous steps."

The model produces a plan like:

Step 1: Search for relevant financial transactions in the payment processor database. Tool: database query. Expected outcome: list of transactions. Dependencies: none.

Step 2: Search for matching transactions in the internal ledger. Tool: database query. Expected outcome: list of ledger entries. Dependencies: none.

Step 3: Compare the two datasets to identify mismatches. Tool: comparison function. Expected outcome: list of discrepancies. Dependencies: step 1 and step 2.

Step 4: For each discrepancy, investigate the cause by checking timestamps, amounts, and transaction IDs. Tool: data inspection. Expected outcome: categorization of discrepancy types. Dependencies: step 3.

Step 5: Generate reconciliation report summarizing findings. Tool: report generator. Expected outcome: formatted report. Dependencies: step 4.

This plan is more sophisticated than what a ReAct agent would do. The ReAct agent would start with step 1, observe the results, decide what to do next, maybe do step 2, compare a few records, get distracted by an individual mismatch, investigate it, lose track of the overall task. The plan provides structure: do these steps in this order, and you will accomplish the goal.

More sophisticated planning might involve:

- Parallel execution: identifying steps that can run concurrently because they have no dependencies.
- Conditional branching: specifying alternative paths based on intermediate outcomes.
- Resource allocation: assigning priorities or resource limits to different steps.
- Validation rules: specifying conditions that must be true for the plan to be valid.

The sophistication of the plan depends on the task complexity and the agent's capabilities. For simple tasks, a linear sequence suffices. For complex tasks, you might need a full directed acyclic graph with explicit dependency management.

## The Execution Phase: Following the Plan While Adapting to Reality

Execution in a plan-and-execute agent is structured by the plan but not rigidly bound to it. The agent executes steps in the planned order, but it monitors for deviations and adapts when necessary.

For each step in the plan:

- The agent identifies the action: which tool to call, what parameters to use.
- The agent executes the action.
- The agent observes the result.
- The agent evaluates: did the step succeed? Did it produce the expected outcome?
- The agent updates the plan state: mark the step complete if it succeeded, mark it failed if it did not.
- The agent decides: continue to the next step, retry the current step, or trigger replanning?

If execution proceeds smoothly—every step succeeds, every outcome matches expectations—the agent marches through the plan and completes the task. The plan provided the strategy, execution implemented it, and the task is done.

But execution rarely proceeds perfectly. Tools fail. Results are unexpected. Conditions change. The plan must adapt.

## Re-Planning Triggers: When to Abandon the Plan and Replan

The decision of when to abandon the current plan and generate a new one is critical. Replanning too aggressively wastes the effort invested in the original plan. Never replanning makes the agent brittle when the environment changes.

Common replanning triggers include:

**Step failure after retries:** If a step fails once, retry. If it fails twice, consider whether the plan is still viable. If it fails three times, the plan is probably wrong. Trigger replanning: generate a new plan that accounts for the unavailability of the failed action or the incorrectness of the assumption that led to the failed step.

**Unexpected results:** If a step succeeds but produces a result that contradicts the plan's assumptions, replanning may be necessary. For example, if the plan assumes the database contains transaction data, but the query returns empty results, the plan is invalid. The agent must generate a new plan that accounts for the absence of expected data.

**Goal changes:** If the task goal changes mid-execution—the user updates the requirements, external conditions shift, new information emerges—the current plan may no longer be appropriate. Replanning aligns the strategy with the new goal.

**Detected inefficiency:** If the agent recognizes that the current plan is taking much longer than expected or consuming excessive resources, it might replan to find a more efficient approach. This requires the agent to have some model of expected cost or latency and the ability to recognize when reality diverges from expectations.

**Dependency violations:** If the agent discovers that a dependency assumed in the plan does not hold—step C depends on step B, but step B cannot be completed—replanning is required to find an alternative path.

The replanning process itself mirrors the initial planning process: the agent reasons about the current state, the goal, the failures or changes that triggered replanning, and generates a new plan. The new plan incorporates what the agent has learned from the initial execution attempt.

Replanning is expensive. It requires additional LLM calls, additional reasoning time, and potentially wasted effort from the abandoned plan. But it is essential for robustness. A plan-and-execute agent that cannot replan is a plan-and-fail agent.

## Advantages of Plan-and-Execute Over ReAct

Plan-and-execute has clear advantages over ReAct for certain types of tasks.

**Global coherence:** Planning forces the agent to think about the entire task before acting. This leads to more coherent execution. The agent is less likely to wander, repeat steps, or lose track of the goal because it has a roadmap.

**Efficiency:** A good plan minimizes wasted effort. The agent identifies the necessary steps, eliminates redundancy, and executes in an optimal order. ReAct's greedy approach often leads to backtracking, repeated queries, or unnecessary exploration. Planning avoids this.

**Structured execution:** For tasks with natural phases or dependencies, planning makes the structure explicit. The agent executes phase one, then phase two, then phase three. Each phase builds on the previous. Dependencies are respected. Structure reduces errors.

**Transparency:** The plan is inspectable. You can review it before execution, approve it, modify it, or reject it. This transparency is valuable in high-stakes domains where you want to verify the agent's approach before it takes irreversible actions. ReAct's reasoning is visible, but it is interleaved with execution. The plan is separate, reviewable, and amendable.

**Parallelization:** Plans can specify steps that are independent and can be executed in parallel. ReAct is inherently sequential: reason, act, observe, reason, act. Plan-and-execute can identify "step 2 and step 3 have no dependencies, execute them concurrently," reducing total execution time.

**Better handling of long-horizon tasks:** Tasks that require 20 or 30 steps are difficult for ReAct because the context becomes unwieldy and the agent loses coherence. Plan-and-execute handles long horizons better because the plan provides structure. The agent follows the plan rather than trying to hold the entire task in working memory.

**Explicit failure handling:** Plans can specify what to do if a step fails. "If step 3 fails, retry with alternative parameters. If it fails again, skip to step 5." This explicit fallback logic makes the agent more robust. ReAct's failure handling is implicit in the reasoning, which is less reliable.

For tasks where these advantages matter—complex multi-step workflows, tasks with dependencies, tasks where efficiency is critical, tasks where transparency is required—plan-and-execute is superior to ReAct.

## Disadvantages: Planning Overhead, Brittle Plans, Wasted Planning

Plan-and-execute is not always better. It has costs and failure modes that make it inappropriate for many tasks.

**Planning overhead:** Generating a plan requires time and compute. The agent must reason about the task, decompose it, identify dependencies, structure the steps, and produce a plan object. This might take several LLM calls. For simple tasks, the planning overhead exceeds the execution time. If the task can be done in three steps, spending 30 seconds planning and 10 seconds executing is wasteful compared to 15 seconds of ReAct.

**Brittle plans:** Plans are based on assumptions about the world. If those assumptions are wrong, the plan fails. The agent might plan to query a database that is unavailable, use data that does not exist, or execute a sequence that violates a constraint. When the plan is invalid, execution fails, and the agent must replan. For tasks where the environment is uncertain or dynamic, planning is risky because the plan is likely to become stale.

**Wasted planning for simple tasks:** If the task is straightforward—answer a question by searching once or twice—planning adds no value. ReAct can execute the task faster than plan-and-execute can generate a plan. The overhead is not justified. Plan-and-execute is for complex tasks where the investment in planning pays off through more efficient execution.

**Difficulty adapting mid-execution:** While replanning is possible, it is costly. If the environment changes frequently, the agent spends more time replanning than executing. ReAct adapts naturally at each step because it has no plan to revise. Plan-and-execute is less agile.

**Complexity:** Plan-and-execute is harder to implement than ReAct. You need a planner, a plan representation, a plan executor, replanning logic, and dependency management. The code is more complex. The debugging is harder because failures might occur in planning, execution, or the interaction between them.

These disadvantages mean plan-and-execute is not the default. It is the pattern you choose when the task characteristics justify the overhead.

## When Plan-and-Execute Is the Right Choice

Use plan-and-execute when:

- The task is complex, requiring many steps with dependencies.
- Efficiency matters, and a good plan significantly reduces wasted effort.
- The task has structure—phases, sub-tasks, dependencies—that benefits from explicit representation.
- You want transparency into the agent's intended approach before execution.
- The environment is relatively stable, so plans are unlikely to become stale quickly.
- The task is long-running enough that the planning overhead is a small fraction of total execution time.

Do not use plan-and-execute when:

- The task is simple, requiring only a few steps.
- The environment is highly dynamic, and plans become stale quickly.
- Agility is more important than efficiency, and you need rapid adaptation to changing conditions.
- The planning overhead is comparable to the execution time.

The tradeoff is efficiency and structure versus simplicity and agility. Plan-and-execute is more efficient when the plan is good and the environment is stable. ReAct is simpler and more agile when the task is short or the environment is uncertain.

## Production Implementation Patterns

Deploying plan-and-execute agents in production requires careful implementation of planning, execution, and replanning.

**Plan representation:** You need a data structure that represents the plan. This might be JSON, a Python object, or a domain-specific language. The representation must capture steps, dependencies, status, and metadata. A simple representation might be a list of steps with status flags. A sophisticated representation might be a directed acyclic graph with explicit dependency edges.

**Plan validation:** Before executing a plan, validate that it is achievable. Check that every step references a valid tool, that dependencies are acyclic, that parameters are well-formed. Invalid plans should be rejected and replanned before execution starts.

**Execution engine:** You need an orchestrator that interprets the plan and executes steps. The orchestrator manages state: which steps are complete, which are in progress, which have failed. It enforces dependencies: a step does not execute until its dependencies are complete. It handles concurrency: independent steps can execute in parallel.

**Monitoring progress:** Unlike ReAct, where every step is a reasoning-action pair, plan-and-execute separates reasoning from action. You need visibility into both the plan and the execution state. Log when each step starts, completes, or fails. Track how execution diverges from the plan. Monitor whether replanning is occurring frequently, which indicates plan quality issues.

**Replanning logic:** Define clear triggers for replanning. Implement replanning as a transition: pause execution, generate a new plan, resume execution with the new plan. Preserve state across replanning: the agent should not lose information it gathered before replanning. Consider whether replanning should incorporate results from the abandoned plan or start fresh.

**Human review of plans:** For high-stakes tasks, allow humans to review and approve plans before execution. The agent generates the plan, presents it to a human, waits for approval, and then executes. This pattern provides the efficiency benefits of planning while maintaining human oversight.

**Fallback to ReAct:** For steps that are exploratory or uncertain, allow the plan to specify "execute a ReAct loop to accomplish this sub-goal." This hybrid approach uses planning for the high-level structure and ReAct for the low-level tactics. It combines the strengths of both patterns.

These implementation patterns are more complex than ReAct, but they are necessary for robust plan-and-execute agents.

## Plan Quality: The Make-or-Break Factor

The quality of the plan determines the success of plan-and-execute. A good plan leads to efficient execution. A bad plan leads to wasted effort, frequent replanning, and possible failure.

Plan quality depends on several factors:

**Correct decomposition:** The task must be broken down into the right steps. Too coarse, and the steps are too complex to execute. Too fine, and the plan is bloated and hard to manage. The decomposition should match the natural structure of the task.

**Accurate dependencies:** The plan must correctly identify which steps depend on others. Missing dependencies lead to steps executing out of order and failing. False dependencies lead to unnecessary sequencing and lost parallelization opportunities.

**Realistic assumptions:** The plan is based on assumptions about the environment, available data, and tool capabilities. If the assumptions are wrong, the plan fails. Good planning includes verification: check that critical assumptions hold before committing to the plan.

**Robustness to failure:** A good plan anticipates possible failures and includes fallback strategies. If a step might fail, the plan specifies what to do next. Plans that assume perfect execution are brittle.

**Efficiency:** The plan should minimize wasted effort. It should avoid redundant steps, unnecessary backtracking, and suboptimal sequencing. An inefficient plan defeats the purpose of planning.

Improving plan quality requires iteration. You deploy the agent, observe plans it generates, identify patterns of poor planning—incorrect decomposition, missed dependencies, unrealistic assumptions—and refine the planning prompt, the planning model, or the planning process.

Some teams use a two-model approach: a larger, more capable model for planning and a smaller, faster model for execution. The intuition is that planning requires more sophisticated reasoning, while execution is more straightforward. This can improve plan quality while controlling costs.

## Comparing ReAct and Plan-and-Execute: A Decision Framework

The choice between ReAct and plan-and-execute comes down to task characteristics and priorities.

Use ReAct if:

- The task requires fewer than 10-15 steps.
- The next step is usually clear from the current state.
- The environment is dynamic, and plans would become stale.
- Simplicity and debuggability are priorities.
- You are building a first version or prototyping.

Use plan-and-execute if:

- The task requires 15 or more steps with dependencies.
- Upfront planning significantly improves efficiency.
- The task has clear phases or structure.
- You need transparency into the approach before execution.
- The environment is stable, and plans are unlikely to become stale quickly.

Use a hybrid approach if:

- The high-level structure benefits from planning, but individual steps are exploratory.
- Some parts of the task are well-defined, and others are uncertain.
- You want the structure of planning with the agility of ReAct.

The decision is not ideological. It is pragmatic. Both patterns are tools. The skill is in choosing the right tool for the job.

## The 2026 Landscape: Plan-and-Execute for High-Value Tasks

By 2026, plan-and-execute had become the standard pattern for high-value, complex agent tasks. Teams building software engineering agents, data analysis agents, and workflow orchestration agents defaulted to plan-and-execute because the tasks justified the overhead.

Frameworks evolved to make plan-and-execute easier. LangGraph introduced explicit plan nodes and execution graphs. AutoGPT added planning modes. Custom agent platforms built specialized planners for domain-specific tasks.

The pattern also matured. Early plan-and-execute systems generated rigid plans and failed when execution diverged from the plan. By 2026, systems incorporated adaptive replanning, probabilistic planning that accounted for uncertainty, and hierarchical planning that decomposed tasks at multiple levels of abstraction.

The fintech team's reconciliation agent became a case study in effective plan-and-execute. They open-sourced their implementation, and dozens of companies adapted it for similar financial workflows. The pattern was clear: analyze the dataset, identify systematic issues, handle them in bulk, address individual discrepancies, generate the report. The plan made the task tractable, efficient, and reliable.

The lesson was that planning is not overhead when the task is complex enough to benefit from strategy. It is an investment that pays off in efficiency, reliability, and transparency. The craft is knowing when the investment is justified.
