# 2.14 — Agent Workflow State Machines: States, Transitions, and Timeouts

In July 2025, a travel booking platform called Wanderlust deployed an agent that could plan and book multi-city trips by coordinating flights, hotels, and rental cars. The agent was sophisticated: it understood complex user preferences, compared dozens of options, and assembled complete itineraries. In testing, it worked beautifully. Users would describe their travel plans, the agent would search for options, present recommendations, wait for user approval, and execute the bookings. The agent launched to production on a Friday afternoon. By Sunday evening, the platform had 127 zombie workflows: requests that had started processing but never completed. Some were waiting indefinitely for API responses that had timed out hours ago. Others were stuck in infinite loops where the agent kept searching for flights even after the user had abandoned the conversation. Some had partially completed bookings—hotel reserved but no flight—with no mechanism to either roll back the partial transaction or complete it. The engineering team spent the weekend manually investigating each stuck workflow, canceling partial bookings, and refunding customers. The direct cost was $23,000 in engineering time and refunds. The indirect cost was much higher: users who experienced stuck bookings never returned to the platform.

You will build agent workflows that get stuck in inconsistent states, execute operations in the wrong order, fail to recover from interruptions, and behave unpredictably under edge conditions. This happens because most agent systems rely on implicit state management: the agent's reasoning determines what state it is in, what actions are valid, and how to transition between states. This works in simple cases but breaks down when workflows involve multiple steps, external dependencies, user interactions, and failure recovery. The solution is explicit state machines: formal models that define the discrete states of a workflow, the valid transitions between states, the conditions that trigger transitions, and the timeout behaviors when a state persists too long. This subchapter explains why implicit state fails in production, how to model agent workflows as state machines, how to implement states and transitions, how to handle timeouts and error states, how to persist state for long-running agents, and when the tradeoff between explicit state machines and flexible agent reasoning is worth making.

## Why Implicit State Fails in Production

Implicit state management treats the agent's current context and reasoning as the state machine. The agent reads the conversation history, understands where it is in the workflow, decides what to do next, and executes the appropriate action. This approach is appealingly simple: you do not need to write state machine code because the agent's intelligence handles state tracking automatically. In controlled scenarios with cooperative users and reliable APIs, implicit state works well. In production, with adversarial inputs, flaky dependencies, and unexpected interruptions, it fails catastrophically.

Wanderlust's agent used implicit state. The system prompt included instructions like "First search for flights, then present options to the user, then wait for confirmation, then book the selected flight." The agent would follow this workflow by reading the conversation history and reasoning about what step it was on. If the conversation showed flight options presented but no confirmation received, the agent would wait for user input. If the conversation showed confirmation received, the agent would execute the booking. This worked perfectly in test scenarios where users followed the happy path and APIs responded instantly.

The failures emerged from three sources. First, the agent had no mechanism to detect when it was stuck waiting for something that would never arrive. When a flight search API timed out, the agent would wait for results indefinitely because its instructions said "wait for search results before presenting options." There was no timeout condition that said "if search results do not arrive within 30 seconds, transition to an error state." The agent just waited forever because its implicit state was "waiting for search results" and nothing told it to stop waiting.

Second, the agent could not distinguish between normal waiting and abnormal waiting. When the agent presented flight options and the user did not respond immediately, that was normal—users might need time to think about their choices. When the user did not respond for six hours, that was abnormal—the user had probably abandoned the conversation. But the agent had no timeout logic that differentiated between the two. It just kept waiting because its state was "waiting for user confirmation" and no one told it when to give up.

Third, the agent had no rollback mechanism for partial failures. When a hotel booking succeeded but the subsequent flight booking failed, the agent's state was inconsistent: the workflow was incomplete, but part of it had already been executed against external systems. The agent's implicit state model had no concept of compensating transactions or rollback procedures. It just got stuck because it could not complete the workflow and did not know how to undo what it had already done.

These are not edge cases. They are normal conditions in production systems. APIs time out. Users abandon conversations mid-workflow. Partial failures leave systems in inconsistent states. Implicit state management cannot handle these conditions reliably because the agent's reasoning is not designed to encode the strict invariants, timeout conditions, and error handling logic that production workflows require. You need explicit state machines.

## Defining States: What Makes a State a State

A state is a discrete condition of the workflow with well-defined characteristics: what information is available, what actions are valid, what the system is waiting for, and how long the system can remain in this state before timing out. Defining states requires thinking about the workflow not as a continuous narrative but as a sequence of distinct phases with clear boundaries.

For the Wanderlust travel booking workflow, the states might be: initial query received, searching for flights, flight options presented, waiting for flight selection, flight selected, booking flight, flight booked, searching for hotels, hotel options presented, waiting for hotel selection, hotel selected, booking hotel, hotel booked, itinerary complete, booking failed, workflow abandoned. Each state represents a specific condition of the workflow with specific valid actions.

In the "searching for flights" state, the system has received the user's travel requirements and has dispatched a search request to the flight API. The valid actions are: receive search results and transition to "flight options presented," receive search timeout and transition to "booking failed," or exceed the state timeout and transition to "workflow abandoned." The system cannot accept user input in this state because it is waiting for API results. It cannot proceed to booking because no flight has been selected yet. The state boundaries are clear and the valid transitions are enumerable.

Compare this to implicit state where the agent might be "in the middle of searching for flights" but there is no formal definition of what that means. The agent might interpret user messages during the search as attempts to modify the search criteria, or as unrelated questions, or as impatient complaints about slowness. Without explicit state boundaries, the behavior is unpredictable because it depends on the agent's reasoning rather than formal rules.

Defining states requires identifying the key decision points and waiting points in the workflow. Decision points are moments where the workflow must choose between multiple paths: did the API return results or an error? Did the user approve the selection or reject it? Waiting points are moments where the workflow pauses for external input: waiting for API response, waiting for user confirmation. Each decision point and waiting point suggests a state boundary.

For Wanderlust, the decision points are: search results received or timeout, user selected flight or rejected all options, booking succeeded or failed, user selected hotel or rejected all options. The waiting points are: waiting for search results, waiting for user selection, waiting for booking confirmation. Each decision point creates a fork in the state graph, and each waiting point creates a state where timeout logic must be defined.

The result is a state machine with 15 states and 30 transitions. This sounds complex, but it makes the workflow completely explicit. Every possible condition of the system maps to a specific state. Every valid action in each state is enumerated. Every timeout condition is defined. The complexity has not increased—it was always there in the implicit state model—but now it is visible and manageable instead of hidden in the agent's reasoning.

## Defining Transitions: What Moves the Workflow Forward

A transition is a change from one state to another triggered by a specific event or condition. Transitions make the workflow dynamic while keeping it predictable. In an explicit state machine, you enumerate the valid transitions for each state, the conditions that trigger each transition, and the actions that execute during the transition.

For the Wanderlust workflow, the transition from "searching for flights" to "flight options presented" is triggered by the event "search results received." The transition includes these actions: parse the search results, format them for presentation, store them in workflow state, and send them to the user. The transition is only valid if the current state is "searching for flights" and the event is "search results received." If the current state is "waiting for user selection," receiving search results does not make sense and should be rejected or logged as an anomaly.

Defining transitions requires thinking about the event model: what events can occur in each state, and how should the system respond to each event. The common events are: external API response received, user input received, timeout elapsed, error occurred, internal computation completed. For each state, you enumerate which events are valid and which should be ignored or treated as errors.

In the "waiting for flight selection" state, the valid events are: user selects a flight, user rejects all options, user asks a clarifying question, timeout elapsed. The transitions are: user selects a flight triggers transition to "flight selected," user rejects all options triggers transition to "searching for flights" with modified search criteria, user asks a clarifying question triggers an information response without state transition, timeout elapsed triggers transition to "workflow abandoned." Events like "API response received" are invalid in this state and should be logged as errors because the system is not waiting for an API response.

This explicit event handling eliminates ambiguity. The agent does not need to reason about what user input means in the current context—the state machine defines valid events for each state and maps them to transitions. This makes the system testable: you can verify that each state responds correctly to each valid event and rejects invalid events appropriately.

Transition guards add conditional logic to transitions. A guard is a predicate that must be true for the transition to execute. For example, the transition from "flight selected" to "booking flight" might have a guard that checks whether the selected flight is still available at the quoted price. If the guard fails, the transition does not execute and the workflow transitions to a "price changed" state instead, where it can notify the user and ask for reconfirmation.

Transition actions define what happens during a state change. When transitioning from "booking flight" to "flight booked," the actions might include: store the booking confirmation number, update the workflow status, send a confirmation email to the user, log the successful booking event, and initiate the next phase of the workflow. These actions are part of the transition definition, so they execute atomically with the state change. Either the entire transition succeeds—the state changes and all actions complete—or the transition fails and the state remains unchanged.

Wanderlust's implicit state model had none of this structure. The agent would reason about what to do next based on conversation history, which meant that the same user input could produce different behaviors depending on subtle variations in how the agent interpreted context. With explicit transitions, the behavior is deterministic: a specific event in a specific state always triggers the same transition with the same actions.

## Timeout Handling: Preventing Stuck Workflows

Timeouts are critical for production systems because they define the boundary between patience and abandonment. Every state where the workflow waits for external input—API response, user action, asynchronous callback—must have a timeout that specifies the maximum duration the workflow will wait before taking corrective action.

For Wanderlust, the "searching for flights" state has a 30-second timeout. If the flight search API does not respond within 30 seconds, the workflow transitions to "booking failed" with an error message like "Flight search timed out, please try again." This prevents the workflow from waiting indefinitely for an API that is down or overloaded.

The "waiting for flight selection" state has a 10-minute timeout. If the user does not respond within 10 minutes, the workflow transitions to "workflow paused" and sends a message like "Are you still there? Let me know when you are ready to continue." If the user still does not respond after another 10 minutes, the workflow transitions to "workflow abandoned" and releases any reserved resources.

Timeout durations must be tuned based on the nature of the waiting. API calls should have short timeouts—5 to 30 seconds—because longer waits indicate a problem with the external service. User interactions can have longer timeouts—minutes to hours—because users might need time to make decisions or might be interrupted by other activities. Background processes like asynchronous booking confirmations might have very long timeouts—hours to days—because the external system might take that long to process the request.

Timeout actions define what the workflow does when a timeout occurs. The simplest action is to transition to an error state and notify the user that the operation failed. More sophisticated actions include: retry the operation with backoff, escalate to a human operator, transition to a degraded functionality state, or save the workflow state and offer to resume later.

For Wanderlust, when a flight booking times out, the workflow checks whether the booking might have succeeded despite the timeout. It queries the booking API to see if a confirmation number exists. If the booking succeeded but the confirmation response was lost, the workflow transitions to "flight booked" and continues. If the booking did not succeed, the workflow transitions to "booking failed" and offers to retry. This prevents the double-booking scenario where a timeout causes the user to retry and the original booking completes late.

The timeout logic that saved Wanderlust from zombie workflows would have been straightforward to implement in an explicit state machine but was nearly impossible to implement reliably with implicit state. The agent would need to reason about how long it had been waiting, whether that duration was excessive, and what corrective action to take. Without explicit timeout definitions in each state, the agent had no basis for making those judgments consistently.

## Error States and Recovery Transitions

Error states are special states that the workflow enters when something goes wrong. They serve two purposes: they prevent the workflow from getting stuck in an inconsistent state, and they provide a structured context for recovery actions.

For Wanderlust, the "booking failed" state is an error state entered when a flight or hotel booking cannot be completed. In this state, the workflow has not made any external commitments, so recovery is straightforward: notify the user of the failure, offer to retry with the same parameters or modify the search, or abandon the workflow if the user chooses.

The "partial booking completed" state is a more complex error state entered when some bookings succeed and others fail—for example, the hotel is booked but the flight booking fails. This state requires compensating transactions: cancel the hotel reservation, refund any charges, and notify the user that the complete itinerary could not be booked. The recovery transitions from this state are: retry the failed booking, modify the search parameters and retry the complete workflow, or cancel all partial bookings and abandon the workflow.

Defining error states explicitly makes failure handling testable and consistent. Instead of relying on the agent to figure out how to recover from errors, you define the recovery logic as transitions from error states to recovery states or terminal states. This ensures that every failure mode has a defined recovery path and that the workflow never gets stuck in an undefined error condition.

Wanderlust's implicit state model had no error states. When a booking failed, the agent would try to reason about what went wrong and what to do next, but there was no structured context for that reasoning. Sometimes the agent would retry the booking immediately, causing rapid repeated failures. Sometimes it would ask the user what to do, forcing users to understand technical error messages and make recovery decisions. Sometimes it would just report the error and wait for user input that never came, creating a stuck workflow.

With explicit error states, the recovery logic is codified. When the workflow enters "booking failed," it automatically retries once with the same parameters. If that fails, it transitions to "user intervention required" and asks the user whether to modify the search or abandon the booking. If the user does not respond within 5 minutes, it transitions to "workflow abandoned" and cleans up any partial state.

## State Persistence for Long-Running Workflows

Long-running workflows require state persistence because the workflow might span hours or days, during which the agent process might restart, the user might disconnect and reconnect, or the system might need to pause and resume the workflow. State persistence means storing the current state, the accumulated workflow data, and the transition history in durable storage so the workflow can be reconstructed if the process is interrupted.

For Wanderlust, the workflow state includes: current state name, user preferences, flight search results, selected flight details, hotel search results, selected hotel details, booking confirmation numbers, error messages, and timestamp of the last state transition. This state is stored in a database after every state transition so that if the agent process crashes, the workflow can resume from the last persisted state.

State persistence enables several critical capabilities. First, it enables workflow resumption after interruptions. If the user closes the browser during flight selection, they can return later and the workflow will resume in the "waiting for flight selection" state with the flight options still available. Second, it enables debugging and auditing. You can query the database to see all workflows currently in progress, how long they have been in their current state, and what transition history led them there. Third, it enables timeout enforcement. A background process can scan the database for workflows that have been in a waiting state longer than the timeout threshold and trigger timeout transitions automatically.

The state persistence implementation must address several concerns. First, state updates must be atomic with transition actions. If the workflow transitions from "booking flight" to "flight booked" and sends a confirmation email, the state update and the email send must happen atomically. Either both succeed or both fail. This prevents scenarios where the email is sent but the state is not updated, causing the workflow to retry the booking and send duplicate emails.

Second, state persistence must handle concurrent access. If two processes try to transition the same workflow simultaneously—for example, a timeout handler and a user input handler—the persistence layer must ensure that only one transition succeeds and the other is rejected or retried. This requires optimistic locking or transaction isolation.

Third, state persistence must support schema evolution. As the workflow state machine evolves—new states added, transitions changed, state data fields modified—the persistence layer must be able to migrate existing workflows to the new schema without breaking in-progress workflows.

Wanderlust implemented state persistence using PostgreSQL with a workflow_state table that stored the current state name, the workflow data as JSON, and the updated_at timestamp. Every state transition executed in a database transaction that updated the state row and committed the transition atomically. A background job scanned for workflows with updated_at older than the state timeout threshold and triggered timeout transitions. This prevented zombie workflows and enabled workflow resumption after user disconnections.

## Testing State Machines: Determinism and Coverage

Explicit state machines are testable because they are deterministic. Given a specific state and a specific event, the state machine will always execute the same transition and produce the same next state. This makes it possible to write comprehensive test suites that verify every state, every transition, and every timeout condition.

For Wanderlust, the test suite included state transition tests that verified each valid transition, invalid event tests that verified each state rejected invalid events correctly, timeout tests that verified each waiting state transitioned correctly when timeouts elapsed, error handling tests that verified each error state executed the correct recovery logic, and end-to-end scenario tests that verified complete workflows from initial query to booking confirmation.

State transition tests are table-driven: for each state and each valid event, assert that the correct next state is reached and the correct transition actions are executed. For example, test that "searching for flights" state with "search results received" event transitions to "flight options presented" state and executes the "format and present results" action.

Invalid event tests verify that each state handles unexpected events gracefully. For example, test that "waiting for flight selection" state with "API response received" event logs an error and does not transition. This prevents undefined behaviors when events arrive in the wrong order.

Timeout tests use fake timers to simulate time passing without actually waiting. For example, test that "searching for flights" state with 30 seconds elapsed transitions to "booking failed" state and executes the "notify user of timeout" action.

Error handling tests verify that error states execute the correct recovery logic. For example, test that "booking failed" state retries the booking once, then transitions to "user intervention required" state if the retry also fails.

End-to-end scenario tests verify complete workflows. For example, test a successful booking scenario: user submits query, agent searches for flights, user selects flight, agent books flight, agent searches for hotels, user selects hotel, agent books hotel, workflow completes. Also test failure scenarios: API timeout during search, user rejects all options, booking fails due to unavailability, partial booking requires rollback.

This level of test coverage is only possible with explicit state machines. Implicit state management is not deterministic enough to test comprehensively because the agent's reasoning introduces variability. You can test happy paths, but you cannot systematically test every edge case and error condition.

## The Tradeoff: Explicitness vs Flexibility

Explicit state machines make workflows predictable, debuggable, and testable, but they sacrifice flexibility. If a user does something unexpected—asks a question in the middle of a booking, changes their mind about a previous selection, wants to backtrack to an earlier decision—the state machine must have transitions defined for those scenarios or it will not handle them. Implicit state management, where the agent reasons about the conversation and decides what to do, can handle unexpected user behaviors more gracefully because the agent is not constrained by predefined transitions.

This tradeoff is context-dependent. For high-stakes workflows where correctness, auditability, and predictability are critical—financial transactions, medical procedures, legal processes—explicit state machines are the right choice. The cost of getting stuck or producing inconsistent results is too high to rely on the agent's reasoning. For exploratory workflows where user intent is ambiguous and the interaction is more conversational—brainstorming, creative writing, research assistance—implicit state management is more appropriate because the flexibility outweighs the risk.

Wanderlust's travel booking workflow is a hybrid. The booking execution phase—flight selected to flight booked to hotel selected to hotel booked—is implemented as an explicit state machine because correctness is critical and the workflow is well-defined. The search and selection phase—initial query to flight options presented to flight selected—uses more implicit state management because user preferences are often ambiguous and the agent needs flexibility to ask clarifying questions, present alternatives, and iterate on search criteria.

This hybrid approach works well: use explicit state machines for the parts of the workflow where state transitions are well-defined and errors are costly, and use implicit state management for the parts where flexibility and conversational fluency are more important. The key is to be intentional about where the boundaries are and to implement the state machine rigorously for the parts that need it.

## Building State Machines That Scale

Production agent systems that rely on explicit state machines need infrastructure to define, execute, monitor, and evolve state machines at scale. This infrastructure includes a state machine definition language or framework, a state machine executor that processes events and transitions, a state persistence layer that stores workflow state durably, a monitoring system that tracks workflows in progress and alerts on stuck states, and a migration system that evolves state machines as requirements change.

For Wanderlust, the state machine infrastructure was implemented as a Python library with a declarative state machine definition API. Engineers defined states, transitions, guards, actions, and timeouts in code, and the library handled state persistence, event processing, timeout enforcement, and monitoring integration. This made it easy to define new workflows and evolve existing ones without building state machine logic from scratch each time.

The library also provided tools for visualizing state machines as graphs, which made it easy to understand complex workflows at a glance and to communicate workflow logic to non-technical stakeholders. The visualization showed states as nodes, transitions as edges, and annotated each transition with the triggering event and guard conditions. This was invaluable for debugging and for onboarding new team members.

Monitoring integration was critical for production operations. The library exported metrics for each state: number of workflows currently in that state, median time spent in that state, number of timeouts from that state. These metrics were visualized in dashboards that showed the health of the workflow system at a glance. Alerts fired when workflows spent longer than expected in a state or when error states saw unusual volume, enabling the operations team to investigate and intervene before users were significantly impacted.

State machine evolution was managed through versioned state machine definitions and migration scripts. When the workflow requirements changed—new states added, transitions modified, timeout thresholds adjusted—engineers defined a new version of the state machine and wrote migration logic to transition in-progress workflows from the old version to the new version. This allowed the team to evolve the workflow over time without breaking existing in-progress bookings.

The investment in state machine infrastructure paid for itself within weeks. The team could define new workflows in hours instead of days, debug stuck workflows in minutes instead of hours, and deploy workflow changes confidently without fear of breaking in-progress operations. The explicit state machines eliminated the zombie workflow problem that had plagued the implicit state implementation and gave the operations team visibility and control over the agent system that was previously impossible.

You do not need to build state machine infrastructure from scratch. Libraries like XState for JavaScript and transitions for Python provide excellent state machine implementations with persistence, visualization, and testing support. The key is to recognize when your agent workflows need explicit state management and to adopt the right tools and practices before implicit state management creates production failures that damage user trust.

Explicit state machines are not always the answer, but they are often the answer for production agent systems that need reliability, predictability, and debuggability. Learn to recognize the workflows that need them, build the discipline to define states and transitions rigorously, implement timeout and error handling systematically, and invest in the infrastructure that makes state machines manageable at scale. That is how you build agent systems that do not get stuck, do not leave users waiting indefinitely, and do not require weekend emergency debugging sessions to clean up zombie workflows.
