# 7.4 — Asynchronous HITL: Handling Delays and Timeouts

Humans sleep, take vacations, attend meetings, switch jobs, and sometimes just ignore notifications—your agent cannot assume that when it asks for human input, that input will arrive instantly or even within a reasonable timeframe. In January 2026, a healthcare billing agent at a mid-sized hospital system sent forty-seven claims for review on a Friday evening to medical coders who worked Monday through Friday, nine to five. The coders did not see them until Monday morning. By then, the submission deadline had passed. The hospital lost seventy-two thousand dollars in delayed reimbursements because the agent had no concept of reviewer availability, deadlines, or what to do when humans were not immediately available to respond.

You are building agents that operate continuously in a world where humans have limited availability. Humans sleep, take vacations, attend meetings, switch jobs, and sometimes just ignore notifications. Your agent cannot assume that when it asks for human input, that input will arrive instantly or even within a reasonable timeframe. Asynchronous human-in-the-loop is not an edge case you handle with a timeout parameter. It is a fundamental architectural requirement that shapes how you design approval workflows, manage queues, handle escalations, and ultimately determine whether your agent provides reliable service or creates frustrating gaps where work stalls waiting for unavailable humans.

## The Reality of Reviewer Availability

The first step in designing asynchronous HITL is accepting that human reviewers are not API endpoints with predictable response times. They are people with schedules, priorities, capacity limits, and varying levels of engagement with your system. When your agent sends an approval request at two in the morning, the assigned reviewer is probably asleep and will not see it for hours. When you send a request on Friday afternoon, it might sit unreviewed until Monday. When you send a request to someone who just went on vacation without setting an out-of-office status, it might sit for a week.

I worked with a logistics company whose route optimization agent would request approval for route changes from dispatchers. The agent assumed requests would be reviewed within fifteen minutes because that was the average response time they observed during business hours. They built their timeout policies around that assumption. Then they started running the agent overnight to handle morning route planning. Approval requests sent at three AM sat unanswered until dispatchers arrived at seven AM. The four-hour delay meant routes could not be finalized in time for drivers to get their assignments before their shifts started. The entire value proposition of automated route optimization evaporated because no one had thought about reviewer availability during off-hours.

You need to model reviewer availability explicitly in your system. This might be as simple as business hours configuration: reviewers are available Monday through Friday, eight AM to six PM. During those hours, expect responses within one hour. Outside those hours, expect responses the next business day. More sophisticated systems track individual reviewer schedules, integrating with calendar systems to know when people are in meetings, on vacation, or out sick. The agent can use this availability information to make smarter decisions about when to request reviews, who to assign reviews to, and how long to wait before escalating or taking alternative actions.

## Designing for Asynchronous Approval

Asynchronous approval workflows require different design patterns than synchronous ones. In a synchronous workflow, the agent requests approval and blocks until it receives a response. In an asynchronous workflow, the agent requests approval and then does something else while waiting. It might work on other tasks, it might pause that particular workflow, or it might pursue alternative paths that do not require approval. The key is that the agent cannot just stop and wait indefinitely.

One pattern is parallel task execution. If the agent has multiple workflows in progress and one hits an approval checkpoint, the agent sets that workflow aside and continues working on others. When approval eventually arrives, the agent resumes the paused workflow. This works well when your agent is managing many independent workflows and approval delays on one do not block the others. A customer service agent might be handling twenty conversations simultaneously. If one conversation requires supervisor approval for a refund, the agent requests approval and continues helping the other nineteen customers. When approval comes through, it resumes the refund conversation.

Another pattern is optimistic continuation with rollback. The agent assumes approval will be granted and continues executing subsequent steps that do not commit irreversible actions. It does preparatory work, gathers additional data, or generates drafts. If approval is denied, it rolls back the speculative work. If approval is granted, it already has the next steps prepared and can proceed immediately. A document generation agent might request approval for a contract template, then optimistically start filling in customer-specific details while waiting for approval. If the template is approved, the contract is ready to send. If the template is rejected, the agent discards the partially filled contract and starts over with a different template.

A third pattern is degraded service mode. When approval is needed but not immediately available, the agent continues operating with reduced functionality. A content recommendation agent might normally personalize recommendations based on detailed user behavior analysis. If that analysis requires privacy team approval that is not available, the agent falls back to generic popular content recommendations. Service continues, just not at full quality. When approval arrives, the agent upgrades to full functionality.

## What the Agent Does While Waiting

The decision of what the agent does during approval wait time has major implications for user experience and system throughput. If the agent just pauses entirely, users see stalled workflows and wonder whether anything is happening. If the agent continues too aggressively, it might do work that becomes wasted when approval is denied. You need strategies that balance progress against the risk of wasted effort.

Communicate waiting status clearly. If a user is interacting with the agent and the agent needs to wait for approval, tell the user explicitly. "I have requested approval from the finance team to process this refund. This typically takes two to four hours during business hours. I will notify you as soon as I receive a decision." The user knows what is happening and sets their expectations appropriately. Do not leave them thinking the agent is still actively working when it is actually blocked waiting for human input.

Continue work on non-dependent tasks. If the agent has a task queue and one task is blocked on approval, work on other tasks. If you are building an agent that processes expense reports and one report needs approval for an unusual expense category, move to the next report rather than stopping entirely. This requires careful dependency tracking so the agent knows which tasks are independent and which depend on the blocked task's outcome.

Gather information that will be needed regardless of the approval decision. Even if you do not know whether your proposed action will be approved, you might know that you will need certain data either way. A procurement agent waiting for approval to purchase from a new vendor might use the wait time to gather quotes from alternative vendors, research product specifications, or update demand forecasts. If the new vendor is approved, that information supports the purchase. If the new vendor is rejected, that information helps the agent quickly pivot to an alternative.

Avoid taking actions that create cleanup work if approval is denied. Do not send emails, charge credit cards, update user-facing state, or trigger external workflows while waiting for approval. These actions create side effects that must be undone if approval is denied, and undoing them is often messy. A scheduling agent that books a conference room while waiting for meeting approval creates a problem: if the meeting is denied, someone must remember to unbook the room, or it sits reserved but unused. Better to wait for approval before making the reservation.

## Timeout Policies and SLAs

Every approval request needs a timeout policy that defines what happens if no human responds within a certain timeframe. The timeout period should be based on realistic expectations for human response times, not wishful thinking. If your reviewers typically respond within two hours during business hours, setting a fifteen-minute timeout will cause constant timeout-triggered actions that might not be appropriate. If reviewers sometimes take eight hours, a two-hour timeout is too aggressive.

Service level agreements define the expected response time for different types of approval requests. A high-priority approval request for a production outage fix might have a fifteen-minute SLA. A medium-priority request for a routine procurement decision might have a four-hour SLA. A low-priority request for a policy clarification might have a twenty-four-hour SLA. The SLA tells reviewers how quickly they need to respond and tells the agent how long to wait before taking timeout actions.

When a timeout expires, you have several options. Auto-approve proceeds with the originally proposed action despite lack of explicit approval. This maintains throughput but increases risk. Use auto-approve only when the consequence of proceeding without approval is acceptable. Auto-reject cancels the proposed action and notifies the user that their request could not be processed due to lack of timely review. This is safe but creates poor user experience. Escalate sends the approval request to a backup reviewer or higher-level authority. This maintains safety by ensuring human review while routing around unresponsive reviewers. Defer postpones the decision until reviewers are available again. This works when there is no urgency to the decision.

The right timeout policy varies by decision type. For the healthcare billing agent, high-value claims should escalate to a backup coder if the primary coder does not respond within two hours. Low-value routine claims might auto-approve if no response within four hours, because the risk of a billing code error on a small claim is less than the cost of delayed submission. Claims with compliance flags should never auto-approve, instead deferring until a qualified coder reviews them even if that takes days.

Some systems use progressive timeout policies. After two hours with no response, send a reminder notification. After four hours, escalate to a backup reviewer. After eight hours, escalate to a manager. After twenty-four hours, either auto-reject or page an on-call team member. This gives multiple opportunities for review before taking drastic timeout actions.

## Handling Timezone Differences

Global teams create timezone challenges for HITL workflows. If your engineering team is in San Francisco, your operations team is in London, and your compliance team is in Singapore, there are only a few hours of overlap when all teams are online. An agent that needs approval from multiple teams in different timezones can face delays of twelve to twenty-four hours even with responsive reviewers.

One approach is follow-the-sun escalation. The agent routes approval requests to whichever team is currently in business hours. If the San Francisco team is offline, route to London. If London is offline, route to Singapore. This requires having qualified reviewers in each timezone and clear policies about who can approve what. It works well for operational decisions that do not require specific domain expertise. It works poorly for specialized decisions where only certain individuals have the knowledge to review.

Another approach is asynchronous approval with long timeouts. Accept that some approvals will take a full day because they cross timezones. Design your workflows so that a twenty-four-hour approval delay is acceptable. Batch work to minimize the number of approval points. If you need three approvals from three different timezones, try to structure the work so you can request all three approvals in parallel rather than sequentially, turning a three-day sequential delay into a one-day parallel delay.

Some teams use recorded approval guidelines that let agents make decisions without real-time review. A compliance officer records a video or writes a detailed guide explaining how to evaluate certain types of decisions. The agent presents that guidance to the requester and asks them to self-certify compliance. This shifts the approval from the compliance officer to the requester, eliminating timezone dependencies. It only works when requesters have the expertise to evaluate compliance accurately and are trustworthy to self-certify honestly.

## Weekend and Off-Hours Coverage

The healthcare billing agent's Friday evening failure illustrates the weekend and off-hours problem. Many businesses operate Monday through Friday during standard business hours. If your agent operates twenty-four seven, you need explicit handling for approvals requested outside business hours. Simply letting them queue until Monday creates multi-day delays that might be unacceptable.

On-call rotations ensure someone is always available for urgent approvals. Critical approval requests trigger pages to an on-call reviewer even at three AM or on Sunday. This maintains responsiveness for high-priority decisions while not requiring full staffing around the clock. The tradeoff is that on-call work is exhausting and expensive. You need to reserve it for truly urgent approvals, not routine decisions. A production deployment that needs approval at two AM to fix a critical bug should page the on-call engineer. A routine expense report should not.

Weekend batch processing defers non-urgent work until business hours resume. Approval requests that arrive Friday evening through Sunday night queue up and are presented to reviewers Monday morning. The agent does not block waiting for approval, it continues other work or enters a reduced functionality mode. Monday morning, reviewers work through the weekend backlog. This works well when Monday morning processing is acceptable and the backlog does not grow so large that it overwhelms reviewers.

Some organizations simply disable certain agent functions outside business hours. If an agent function requires human approval and reviewers are not available, the agent tells users that function is not available until business hours resume. "Refund requests that require supervisor approval can only be processed Monday through Friday, eight AM to six PM Pacific. Your request has been queued and will be reviewed when our team returns." This is honest and sets clear expectations, though it creates a degraded user experience during off-hours.

## The Impact of Approval Latency on User Experience

From a user's perspective, agent approval workflows create waiting periods that need to be managed carefully. If a user submits a request and the agent needs approval, the user should know approximately how long they will wait. They should receive updates if the wait is longer than expected. They should have a way to check status. And the final response should acknowledge the delay and explain what happened.

Proactive wait time communication sets expectations. When the agent determines it needs approval, it should tell the user immediately: "Your refund request requires manager approval. Our managers typically respond within four hours during business hours. I will email you as soon as your request is approved or if we need additional information." The user knows they will not get an instant response and can plan accordingly.

Progress updates during long waits reassure users that their request has not been forgotten. If approval is taking longer than expected, send an update: "Your refund request is still awaiting manager approval. The assigned manager is currently in meetings but should be able to review by end of day." This is much better than silence, which makes users wonder whether their request was lost.

Status check functionality lets users see where their request is in the approval process. A dashboard or chat command that shows "your request was submitted at two PM, sent to Manager Smith for approval at two fifteen PM, currently waiting for response" gives users visibility and reduces anxiety. They can see that the system is working even if slowly.

When approval finally arrives and the agent completes the request, acknowledge the delay: "Your refund has been approved and processed. Thank you for your patience while we reviewed your request." Do not pretend the delay did not happen. Users experienced it and appreciate acknowledgment.

The worst user experience is the black hole where requests disappear into approval workflows and users hear nothing until days later. I have seen systems where users submit requests, the agent says "I will look into this," and then the user hears nothing for three days until suddenly they get a response. During those three days, they have no idea whether their request is being worked on, stuck in a queue, or lost entirely. They submit duplicate requests, email support asking for status, and generally create extra work trying to figure out what is happening. Simple status communication eliminates most of this friction.

## Building Resilient Async HITL Systems

Resilient asynchronous HITL requires thinking through failure modes. What happens if the reviewer is on vacation and forgot to set an out-of-office status? What happens if the escalation chain all points to people who are unavailable? What happens if approval notifications are getting caught in spam filters? You need fallbacks and monitoring that detect these situations and route around them.

Availability verification before assigning reviews prevents requests from being assigned to unavailable people. Check calendar systems, out-of-office status, and recent activity before routing an approval request to a specific reviewer. If the primary reviewer appears to be unavailable, assign to the backup immediately rather than waiting for a timeout.

Escalation chain validation ensures that your escalation paths actually work. Periodically test that backup reviewers exist, are active users, and have the permissions needed to approve requests. I have seen escalation chains that pointed to people who had left the company months ago, so timeouts would escalate to non-existent users and then fail.

Notification delivery monitoring tracks whether approval notifications are actually reaching reviewers. If you send email notifications, verify that they are not bouncing or being filtered as spam. If you send Slack notifications, verify that messages are being delivered and not muted. If notifications are consistently failing, fall back to alternative channels or escalate to ensure someone sees the request.

Stuck request detection identifies approval requests that have been waiting far longer than expected and alerts operations teams. A dashboard showing all approval requests older than twenty-four hours lets you spot systemic problems like a reviewer who is ignoring all requests or a broken notification system. You can manually intervene to reassign or escalate these stuck requests before they cause user-facing failures.

The asynchronous nature of human review is not a bug in your HITL system, it is an inherent characteristic of working with humans. You cannot make humans respond instantly, but you can design agents that gracefully handle delays, communicate clearly with users about wait times, escalate appropriately when delays become problematic, and continue making progress on work that does not depend on the delayed approval. The difference between a frustrating HITL system and a smooth one is not whether delays happen, but how visibly and intelligently the system manages them. Accept asynchrony, design for it, and build the monitoring and fallbacks that ensure delays do not become silent failures.
