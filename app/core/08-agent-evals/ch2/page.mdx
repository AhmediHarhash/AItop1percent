# Chapter 2 — Core Agent Orchestration Patterns

Once you've decided to build an agent, the next question is how it thinks. Agent orchestration patterns define how your system plans, acts, observes, and adapts across multi-step tasks. Pick the wrong pattern and you'll fight your architecture at every turn. Pick the right one and the rest of the system falls into place.

In 2026, most teams cargo-cult orchestration patterns from academic papers without understanding when each pattern applies. They implement ReAct because it's popular, or they build elaborate tree search because it sounds sophisticated, only to discover their use case needed something simpler. Elite teams choose patterns based on task structure, failure tolerance, and production constraints.

This chapter covers the core orchestration patterns that power production agent systems, when each pattern makes sense, how to combine them, and what frameworks implement them well. You'll learn what separates research demos from systems that run at scale, and how to move from prototype to production without rebuilding everything.

**ReAct and its variants.** ReAct is the workhorse pattern: reason, act, observe, repeat. It's simple, debuggable, and works for most tasks. You'll learn how ReAct works, when it breaks down, how to extend it with self-correction, and why it's the default starting point for most production agents.

**Plan-and-Execute architectures.** Some tasks require upfront planning before execution. Plan-and-Execute separates planning from action, validates the plan, then executes step by step. You'll learn when this overhead is worth it, how to validate plans, and how to handle plan drift when reality doesn't match expectations.

**Reflection and self-correction.** Agents that can critique their own output and retry perform better on complex tasks. You'll learn how to add reflection loops, when they help versus when they just burn tokens, and how to prevent infinite correction cycles.

**Tree-of-Thought and search patterns.** For high-value tasks where one mistake is costly, tree search explores multiple paths before committing. You'll learn when tree search is worth the latency and cost, how to prune search spaces, and why most teams don't actually need it.

**ReWOO and plan-before-execute patterns.** ReWOO reduces API calls by planning the full workflow upfront, then executing it in parallel where possible. You'll learn when this matters, how to handle dependencies, and why it's critical for cost-sensitive applications.

**Corrective agents and error recovery.** Elite agents detect errors and adjust strategy. You'll learn how to build correction loops, when to retry versus when to escalate, and how to prevent agents from repeating the same failed action.

**Agentic RAG.** RAG becomes agentic when the system can query multiple sources, validate conflicting information, and iteratively refine its understanding. You'll learn how agentic RAG differs from standard retrieval and when the complexity pays off.

**Choosing and combining patterns.** Most production systems use hybrid orchestration: ReAct for most tasks, Plan-and-Execute for complex ones, Reflection for high-stakes outputs. You'll learn how to route between patterns and when to combine them within a single episode.

**Frameworks and their tradeoffs.** LangGraph, CrewAI, AutoGen, and Mastra each implement orchestration differently. You'll learn what each framework optimizes for, when to use them versus building custom, and how to evaluate new frameworks as they emerge.

**Prototype to production.** The pattern that works in a notebook often breaks in production. You'll learn what changes between research and production: state management, error handling, observability, exactly-once execution, and workflow versioning.

---

## What This Chapter Covers

- **2.1** — ReAct: The Foundation Pattern (Reason, Act, Observe, Repeat)
- **2.2** — Plan-and-Execute: When to Plan Before Acting
- **2.3** — Reflection Loops: Self-Correction and Critique
- **2.4** — Tree-of-Thought: Search-Based Reasoning for High-Stakes Tasks
- **2.5** — ReWOO: Plan-Before-Execute for Reduced API Overhead
- **2.6** — Self-Ask: Decomposing Complex Questions into Sub-Questions
- **2.7** — Corrective Agents: Detecting and Recovering from Errors
- **2.8** — Agentic RAG: Multi-Source Retrieval with Validation
- **2.9** — Choosing the Right Pattern for Your Task Structure
- **2.10** — Hybrid Orchestration: Routing Between Patterns
- **2.11** — Framework Overview: LangGraph, CrewAI, AutoGen, Mastra
- **2.12** — Anti-Patterns: What Breaks Orchestration at Scale
- **2.13** — Prototype to Production: What Changes When You Ship
- **2.14** — Workflow State Machines: Managing State Across Episodes
- **2.15** — Exactly-Once-ish Execution: Handling Retries and Failures

---

*We start with ReAct, the pattern most production agents build on.*
