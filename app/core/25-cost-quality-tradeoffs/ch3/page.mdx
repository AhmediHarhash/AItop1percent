# Chapter 3 — Model-Level Tradeoffs

Which model you call determines the majority of your cost. Not your infrastructure. Not your retrieval pipeline. Not your monitoring stack. The model. A single routing decision — sending a simple query to a frontier model instead of a capable small model — can make the difference between a product that costs two cents per request and one that costs forty. Multiply that by millions of queries and you are looking at the difference between a viable business and a funding crisis.

This chapter teaches you to treat model selection as a cost-quality lever, not a fixed architectural choice. You will learn how tiered routing matches model power to task complexity, when distilled small models outperform larger ones on specific tasks, how to build fallback stacks that degrade gracefully without collapsing quality, and how to orchestrate multi-model pipelines that combine cheap and expensive models in the same request flow. You will also learn the discipline of the model downgrade test — the systematic process of proving that a cheaper model is good enough before you commit to the expensive one.

---

- **3.1** — The Model Tax: How Model Choice Drives Most of Your Cost
- **3.2** — Tiered Model Routing: Matching Model Power to Task Complexity
- **3.3** — Small Models That Outperform: When Distillation Beats Scale
- **3.4** — The Fallback Stack: Graceful Degradation Without Quality Collapse
- **3.5** — Prompt Complexity and Model Fit: Right-Sizing Instructions for Cheaper Models
- **3.6** — Batch vs Real-Time: Choosing Processing Modes for Cost and Quality
- **3.7** — Multi-Model Pipelines: Orchestrating Cheap and Expensive Models Together
- **3.8** — Model Version Pinning vs Floating: Cost Stability and Quality Risk
- **3.9** — The Model Downgrade Test: Proving Cheaper Is Good Enough

---

*Model choice sets the per-call price. But the other major cost driver is how many tokens you feed into each call — and that is the domain of context and token economics.*
