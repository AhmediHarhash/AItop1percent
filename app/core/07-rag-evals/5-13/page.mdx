# 5.13 â€” Conflict Resolution Policy: Freshness, Authority, Region, and Product Rules

In October 2024, a global enterprise software company deployed an internal knowledge assistant that retrieved documentation from multiple sources: official product documentation, internal wikis, team Slack channels, and archived email threads. The system worked well until the product team released a major update that changed core API endpoints. The official documentation was updated immediately. But the internal wiki still contained old tutorials. Slack threads from the previous month referenced the old endpoints. Archived Stack Overflow-style discussions explained the old behavior. When engineers asked the RAG system "How do I authenticate with the API?" it retrieved a mix of old and new information. The generated answers were incoherent, sometimes citing the new OAuth2 flow and sometimes referencing the deprecated API key method. Within two weeks, engineers stopped trusting the system. Usage dropped by 73%. The problem was not retrieval quality or generation quality. The problem was that the system had no policy for resolving conflicts between sources. It treated all retrieved documents as equally authoritative, even when they contradicted each other.

You are building a RAG system right now, and you will face source conflicts. Your knowledge base is not a single, perfectly consistent, always-up-to-date source of truth. It is a collection of documents created by different authors at different times for different purposes with different levels of authority. When you retrieve documents to answer a query, you will retrieve documents that disagree. One document will say the deadline is March 31. Another will say April 1. One document will recommend approach A. Another will recommend approach B. One document will cite policy X. Another will cite policy Y. If you generate an answer from these conflicting sources without a conflict resolution policy, your answer will be confused, contradictory, or arbitrary. Users will lose trust. You need explicit, auditable policies for how to resolve conflicts. These policies are not edge cases. They are core system design.

## When Sources Disagree: The Reality of Multi-Source RAG

In an ideal world, every document in your knowledge base would be consistent with every other document. In reality, conflicts are common and arise from multiple causes. Temporal conflicts occur when documents from different time periods describe the same topic but the information has changed. The 2023 compliance guide says one thing. The 2024 compliance guide says something different. Both are retrieved because both are relevant, but they contradict. The older document is not wrong in the sense that it accurately reflected policy at the time, but it is outdated.

Authority conflicts occur when documents from different sources make different claims. The official product documentation says to use method A. A team wiki written by an engineer suggests method B as a workaround. A Slack thread discusses method C as an experimental alternative. All three are retrieved. Which one should the system trust? The official documentation has higher authority, but the wiki might have more recent practical advice. The Slack thread might reflect current team practice.

Regional conflicts occur when information varies by geography. The global policy document says X. The US regional addendum says Y. The California-specific guidance says Z. A user in California asks a question, and all three documents are retrieved. Which one applies? The California guidance is most specific and should take precedence, but only for California users. For users in other regions, different rules apply.

Product conflicts occur in organizations with multiple products or product versions. Documentation for Product A version 2.0 says one thing. Documentation for Product A version 3.0 says another. Documentation for Product B, a related but different product, says something different still. A user asks about "authentication," and all three are retrieved because they all discuss authentication. The answer depends on which product and version the user is asking about.

Scope conflicts occur when documents at different levels of specificity contradict. A high-level policy document states a general principle. A detailed implementation guide provides an exception to that principle for specific cases. Both are retrieved. The general principle and the specific exception are both true, but they seem to contradict if you do not understand the scope. The system needs to recognize that the specific exception takes precedence in its applicable scope.

Without a conflict resolution policy, the RAG system will handle these conflicts inconsistently. Sometimes it will choose the newer document. Sometimes it will choose the document with the higher retrieval score, which might be older. Sometimes it will try to synthesize information from both documents and produce a confused answer. Sometimes it will generate an answer that arbitrarily picks one source and ignores the other. None of these behaviors are acceptable. You need explicit policies.

## Freshness-Wins: Newer Document Takes Precedence

The freshness-wins policy is simple: when documents conflict, the most recently published or updated document takes precedence. This policy is appropriate when your knowledge base consists of versioned documentation that supersedes earlier versions. If you have compliance guides, product documentation, or policy manuals that are regularly updated, freshness-wins ensures that users get the current information.

Implementing freshness-wins requires that your documents have timestamps. Every document or chunk needs metadata indicating when it was created or last updated. When you retrieve documents, you include these timestamps. When you detect a conflict, you compare timestamps and prioritize the newer document. The generated answer cites the newer document and either ignores the older document or explicitly notes that it is outdated.

The challenge is defining what constitutes a conflict. You cannot simply compare every pair of retrieved documents and check if they disagree. You need to identify when documents are making claims about the same topic in incompatible ways. One approach is to extract structured claims from each document and compare them. If Document A says "filing deadline is March 31" and Document B says "filing deadline is April 1," these are conflicting claims about the same entity and attribute. You compare the timestamps and choose the claim from the newer document.

Another approach is to prompt the language model to identify conflicts. You provide the model with multiple retrieved documents and ask: "Do these documents contain conflicting information about the filing deadline? If yes, identify the conflict and indicate which document is newer." The model performs conflict detection and resolution as part of the generation process. This is flexible but requires careful prompting to ensure the model reliably detects conflicts and applies the freshness policy.

You also need to handle cases where freshness is ambiguous. If a document was created in 2023 but last updated in 2025, is its timestamp 2023 or 2025? You need to define this clearly. Typically, last-updated is more relevant than creation date for freshness-wins. But if your metadata only includes creation date, you work with what you have and accept some imprecision.

Freshness-wins works well for time-sensitive information like regulatory requirements, product features, policies, and procedures. It does not work well for archival information where older documents might be relevant for historical context, or for subjective information like recommendations where newer is not necessarily better. You apply freshness-wins selectively to domains where recency matters.

## Authority-Wins: Official Policy Beats Wiki

The authority-wins policy prioritizes documents based on their source authority, regardless of recency. Official documentation beats unofficial wikis. Approved policy documents beat team-created guides. Regulatory texts beat interpretive summaries. This policy is appropriate when your knowledge base includes a mix of authoritative and informal sources, and you want to ensure that users get information from the most trustworthy sources when conflicts arise.

Implementing authority-wins requires defining an authority hierarchy. You classify each document source by authority level. For example, in a corporate knowledge base, you might have levels like: 1) official policy documents, 2) approved product documentation, 3) internal wikis and guides, 4) Slack or email threads, 5) external sources. When documents from different authority levels conflict, the higher authority source wins.

You encode authority as metadata on each document. When you retrieve documents, you include authority level. When you detect a conflict, you compare authority levels and prioritize the higher authority document. If multiple documents at the same authority level conflict, you might apply a tie-breaking rule like freshness-wins or abstain and surface the conflict to the user.

The challenge is defining authority in a way that is clear, consistent, and aligned with organizational reality. In some organizations, official policy documents are meticulously maintained and truly authoritative. In others, they are outdated and the real guidance lives in wikis or Slack. You need to understand your organization's information culture and set authority levels accordingly. If official docs are stale and wikis are current, you might need to adjust your authority hierarchy or combine authority-wins with freshness-wins.

Another challenge is communicating authority to users. When you generate an answer based on the authority-wins policy, you should indicate why that source was chosen. "Based on the official product documentation, the recommended authentication method is OAuth2. Note that some internal wikis mention API key authentication, but this has been deprecated per official policy." This transparency helps users understand the policy and trust the answer.

Authority-wins is particularly important in regulated industries where official sources have legal standing. If a compliance question has conflicting answers in an official regulatory document and an internal interpretation guide, the official document must take precedence. Failure to prioritize authoritative sources can lead to compliance violations and legal liability.

## Region-Wins: Local Regulations Override Global

The region-wins policy prioritizes documents based on geographic specificity. Local or regional guidance takes precedence over global guidance when they conflict. This policy is essential for organizations operating in multiple jurisdictions with varying regulations, policies, or practices.

Implementing region-wins requires geographic metadata on documents and user context. Each document is tagged with the region or jurisdiction it applies to: global, US, California, EU, Germany, etc. Each user query includes context about the user's region, either inferred from their profile, IP address, or explicitly provided. When documents from different regions conflict, the most specific applicable region wins. If a California user asks about employment policy, California-specific guidance beats US-wide guidance, which beats global guidance.

The hierarchy is based on specificity and applicability. A document that applies specifically to the user's region beats a document that applies more broadly. If the user is in California, the precedence order is: California, US West, US, North America, Global. You retrieve documents at all applicable levels but prioritize the most specific when generating the answer.

You also handle cases where regional guidance modifies but does not replace global guidance. A global policy might set a baseline, and regional addenda might add additional requirements or exceptions. In this case, you need to synthesize both: "The global policy requires X. Additionally, in California, you must also comply with Y." This requires understanding whether the regional document is a complete replacement or an addendum, which might be indicated by metadata or inferred from the document content.

Region-wins is critical for compliance and legal applications. If a user in Germany asks about data privacy requirements, you cannot give them US-specific guidance. You need to prioritize GDPR-compliant documentation. If regional documents are not available or do not address the query, you might provide global guidance with a caveat: "Based on global policy, the requirement is X. However, you should verify whether additional regional requirements apply in Germany."

You also use region-wins for operational information that varies by geography: office hours, contact information, local procedures. A user asking "What are the office hours?" should get the hours for their local office, not global headquarters. This requires that your knowledge base is structured with regional metadata and that your retrieval and conflict resolution logic applies region-wins appropriately.

## Product-Wins: Product Team Owns Product Docs

The product-wins policy prioritizes documents based on product scope and ownership. Documentation for Product A takes precedence over general documentation when answering questions about Product A. Documentation owned by the Product A team beats documentation written by other teams. This policy is important in organizations with multiple products or complex product portfolios where different teams own different documentation.

Implementing product-wins requires product metadata on documents and query understanding. Each document is tagged with the product or products it covers. Each query is analyzed to determine which product it is about. This might be explicit if the user says "How do I configure authentication in Product A?" or implicit if you infer product context from user history or session state.

When documents about different products conflict, or when product-specific and general documents conflict, the product-specific document wins. If a user asks about authentication and you retrieve both the general corporate authentication guide and the Product A authentication documentation, and they recommend different methods, the Product A docs take precedence for a query about Product A.

You also handle cross-product questions where the user is asking about how products interact or compare. In this case, you might need to synthesize information from multiple product docs and make the differences explicit. "Product A uses OAuth2 for authentication. Product B uses SAML. If you are integrating both, you will need to configure both methods." This requires understanding when the query is product-specific versus cross-product.

Product-wins also applies to version-specific documentation. If you have docs for Product A version 2.x and version 3.x, and they conflict, you prioritize the version the user is asking about or currently using. If the user's context indicates they are on version 3.x, you use version 3.x docs. If version is ambiguous, you might default to the latest version and caveat the answer: "Based on the latest version 3.x documentation, the method is X. If you are using version 2.x, the method may differ."

Product-wins is essential for maintaining documentation quality and user trust. Product teams are the authoritative source for their products. Allowing general or cross-team documentation to override product-specific guidance leads to errors and confusion. By enforcing product-wins, you ensure that answers about products come from the people who build and maintain those products.

## Implementing Resolution Hierarchies

In practice, you often need to combine multiple conflict resolution policies into a hierarchy. You might apply region-wins first to narrow to applicable documents, then authority-wins to prioritize authoritative sources within that region, then freshness-wins to choose the newest authoritative regional document. The hierarchy depends on your domain and organizational structure.

A typical hierarchy for a global enterprise might be: 1) apply region-wins to filter to documents applicable to the user's region, 2) apply product-wins to filter to documents about the relevant product, 3) apply authority-wins to prioritize official over unofficial sources, 4) apply freshness-wins to choose the newest official source. This multi-stage resolution ensures that the final answer is region-appropriate, product-specific, authoritative, and current.

You implement this as a pipeline. After retrieval, you have a set of candidate documents. You apply the first policy in the hierarchy to prioritize or filter documents. You check for remaining conflicts. If conflicts exist, you apply the next policy. You continue until conflicts are resolved or until you determine that a conflict cannot be resolved automatically, in which case you surface it to the user.

You also define tie-breaking rules for when policies do not resolve a conflict. If two documents have the same region, product, authority, and freshness, and they still conflict, you might default to the document with the higher retrieval score, or you might present both and let the user decide, or you might abstain and indicate that authoritative sources conflict.

You make these hierarchies explicit and configurable. Different parts of your organization or different use cases might require different hierarchies. A compliance team might prioritize authority and region above all else. An engineering team might prioritize product and freshness. You allow administrators to configure the resolution hierarchy for their domain or user group.

## Making Policies Explicit and Auditable

Conflict resolution policies must be explicit, documented, and auditable. Users need to understand why they received a particular answer when multiple sources said different things. Administrators need to be able to review and verify that the system is applying policies correctly. Auditors or regulators might need to trace answers back to sources and understand the resolution logic.

You make policies explicit by documenting them clearly in your system design and user-facing documentation. You explain: "When multiple sources conflict, this system prioritizes sources in the following order: 1) region-specific over global, 2) official policy over informal guides, 3) newer over older." This sets expectations and helps users understand the logic.

You make policies auditable by logging conflict resolution decisions. When a conflict is detected and resolved, you log which documents conflicted, which policy was applied, and which document was chosen. This log is available for review. If a user reports that they received incorrect information, you can trace back to the conflict resolution decision and determine whether the policy was applied correctly or whether the policy itself needs adjustment.

You also surface conflict resolution to users when appropriate. If a conflict was significant, you might include a note in the generated answer: "Based on the most recent official documentation from March 2025, the deadline is April 1. Note that older documentation from 2024 indicated March 31, but this has been superseded." This transparency builds trust. Users see that the system is aware of conflicting information and has made a reasoned decision about which to trust.

You provide mechanisms for feedback and override. If a user believes the system chose the wrong source, they should be able to provide feedback. If an administrator knows that a particular document is incorrect despite being authoritative or recent, they should be able to flag it or deprioritize it. These feedback loops allow you to refine policies and handle edge cases.

## Handling Conflicts That Cannot Be Resolved Automatically

Not all conflicts can be resolved by policies. Sometimes two equally authoritative, equally recent, equally specific documents genuinely contradict each other due to inconsistent information in the knowledge base. Sometimes the conflict is subtle and requires human judgment to resolve. Sometimes the correct answer is that both sources are valid in different contexts, and the system cannot determine which context applies.

When conflicts cannot be resolved automatically, you have several options. You can abstain and explain the conflict to the user: "I found conflicting information about the filing deadline. Official Policy Document A says March 31, while Official Policy Document B says April 1. Both documents are current and authoritative. Please consult your compliance officer for clarification." This is honest and safe. It avoids generating a potentially wrong answer by picking one source arbitrarily.

You can present both answers and let the user decide: "There are two recommended methods for authentication. Official Documentation A recommends OAuth2. Official Documentation B recommends SAML. Both are supported. Your choice may depend on your existing infrastructure." This empowers the user to make an informed decision when the system cannot.

You can escalate to a human expert: "I detected conflicting information that I cannot resolve automatically. This query has been flagged for review by the documentation team." This is appropriate for high-stakes queries where an incorrect answer has serious consequences. It adds latency but ensures quality.

You can also treat unresolvable conflicts as signals for knowledge base improvement. Each conflict is logged and reviewed. If the same conflict appears repeatedly, it indicates an issue in the knowledge base: outdated documents need to be archived, inconsistent documents need to be reconciled, or metadata needs to be corrected. Over time, this feedback loop improves knowledge base quality and reduces conflicts.

## Case Study: The Global Software Company's Recovery

The global software company that saw 73% usage drop due to conflicting API documentation learned these lessons the hard way. After the crisis, they conducted a thorough analysis of their knowledge base and conflict patterns. They found that conflicts between official docs and wikis occurred in 18% of queries. Conflicts between old and new versions of official docs occurred in 12% of queries. Conflicts between product-specific and general guidance occurred in 9% of queries.

They implemented a comprehensive conflict resolution policy with the following hierarchy: 1) product-wins to filter to relevant product documentation, 2) authority-wins to prioritize official docs over wikis, 3) freshness-wins to choose the newest official docs. They enriched their document metadata with product tags, authority levels, and last-updated timestamps. They built conflict detection into their generation pipeline, using the language model to identify when retrieved documents made contradictory claims.

They added transparency features to explain conflict resolution. When the system detected a conflict, the generated answer would note: "This answer is based on the official Product A Documentation v3.1, last updated March 15, 2025. Note that some team wikis reference older authentication methods, but these have been deprecated." This helped users understand that the system was aware of conflicting information and had made a principled choice.

They also implemented a feedback loop. When users reported incorrect answers, the team would review the conflict resolution decision and the source documents. In several cases, they discovered that official docs were outdated and wikis had the correct information. They updated their authority hierarchy to deprioritize official docs that had not been updated in over a year, and they initiated a documentation refresh project. Within three months, conflicts dropped from 18% to 6% of queries. Usage recovered to 91% of the original level. Engineers reported that the system was "finally giving consistent, trustworthy answers." The investment in conflict resolution policies saved the product.

You are building a RAG system, and you need conflict resolution policies from the beginning. Analyze your knowledge base to understand what types of conflicts are likely: temporal, authority, regional, product, scope. Define explicit policies for resolving each type: freshness-wins, authority-wins, region-wins, product-wins. Implement these policies as a resolution hierarchy that runs after retrieval and before generation. Enrich your document metadata to support policy application. Build conflict detection so you know when policies are being applied. Make policies transparent and auditable so users trust the decisions. Provide feedback mechanisms so you can refine policies based on real-world usage. Treat unresolvable conflicts as opportunities for knowledge base improvement. Conflict resolution is not optional. It is the difference between a RAG system that provides coherent, trustworthy answers and a system that generates confused garbage from contradictory sources. Your users will not tolerate the latter. Build the former.
