# 7.4 — User and Tenant-Targeted Flags: Per-Customer Feature Control

Enterprise customers pay for control. Feature flags let you give it to them without building separate systems. When a customer needs a specific model, wants a feature disabled, or agrees to beta test a new capability, targeted flags make it possible. You do not deploy separate code for each customer. You deploy one system with flags that route each customer to their specific configuration. The same infrastructure serves everyone, but each customer gets the experience they negotiated, the compliance they require, or the customization they paid for.

## User-Targeted Flags: Enabling for Specific Individuals

A user-targeted flag enables a feature for specific users by matching user IDs against a list. The flag configuration contains an explicit list of user IDs that should see the feature enabled. When the flag is evaluated, the system checks whether the current user's ID is in the list. If yes, the flag returns true. If no, it returns false. This gives you surgical control over who sees a feature.

The most common use case is beta testing. You build a new AI capability and want feedback before launching broadly. You add ten internal users and five trusted customers to the flag's target list. Those fifteen users see the new capability enabled. Everyone else sees the old behavior. You collect feedback, fix issues, and expand the target list gradually. When you are confident the feature is ready, you switch from a targeted flag to a percentage rollout or remove the flag entirely and enable the feature for everyone.

User targeting is also useful for customer support escalations. A customer reports a problem with a specific feature. You suspect the problem is real but need time to investigate and fix it properly. You add that customer's user ID to a flag that disables the problematic feature for them specifically. The feature turns off for that one customer. Everyone else continues using it normally. The customer's issue is resolved immediately while you work on a permanent fix. When the fix deploys, you remove the user from the flag target list.

Internal users are frequent flag targets. You want employees to see features before customers do. You maintain a flag that targets all users with email addresses ending in your company domain. Internal users get early access to new features, can report issues before customers see them, and provide initial feedback that shapes the final release. This is safer than testing only in staging because internal users exercise production systems with real data and real usage patterns.

## Tenant-Targeted Flags: Per-Customer Configuration in Multi-Tenant Systems

In a multi-tenant system, tenant targeting is more powerful than user targeting. A tenant represents a company, organization, or account that contains many individual users. When you target a flag by tenant ID, all users in that tenant get the same flag value. This keeps behavior consistent within a customer's organization and makes support and debugging simpler.

Tenant targeting lets you customize AI behavior per customer. Customer A requires that all AI interactions use Claude Opus 4.5 because they have negotiated specific data processing terms with Anthropic that cover that model. Customer B uses GPT-5 because they have already completed internal compliance review for OpenAI. Customer C uses a self-hosted Llama 4 deployment because they have data residency requirements that forbid cloud API calls. You deploy one system with model selection controlled by tenant-targeted flags. Each tenant gets routed to their required model configuration.

Another use case is feature gating by contract tier. Enterprise customers paying for premium support get access to advanced features. Standard customers do not. A tenant-targeted flag checks the tenant's contract tier attribute and enables premium features only for enterprise tenants. The same codebase serves both tiers. The flag determines what features are accessible. This is cleaner than building separate products or maintaining entitlement logic throughout your application code.

Compliance requirements often drive tenant targeting. A healthcare tenant operating under HIPAA requires that all AI processing happens in US-based data centers. A financial services tenant in the EU requires GDPR-compliant data handling. You use tenant-targeted flags to route each tenant to infrastructure that meets their compliance needs. The flag configuration specifies which tenants route to which infrastructure. The application code checks the flag and uses the appropriate configuration.

## Targeting Rules: Matching User and Tenant Attributes

Simple targeted flags use explicit ID lists: user IDs or tenant IDs that should see the flag enabled. This works for small lists but does not scale to hundreds or thousands of targets. When you need to target based on attributes rather than explicit IDs, you use targeting rules that match against user or tenant properties.

A typical rule looks like: enable the flag if the tenant's contract tier is enterprise and the tenant's region is US. The flag evaluation checks the tenant's attributes against these conditions. If both conditions are true, the flag is enabled. Otherwise, it is disabled. This lets you target all enterprise US customers without explicitly listing every tenant ID.

Attribute-based targeting is more maintainable than ID lists. When a new enterprise customer signs up, they automatically get the flag enabled because their attributes match the targeting rule. You do not need to update the flag configuration to add their tenant ID. When a customer upgrades from standard to enterprise tier, their tenant attributes change, and the targeting rule automatically gives them access to enterprise features. The flag configuration does not change — the tenant's data changed.

Targeting rules can be complex. You might have: enable if the user is in the beta-tester group OR the tenant is in the early-access program OR the user email domain is your company's domain. The rule engine evaluates these conditions and returns true if any are satisfied. The complexity is in the rule evaluation logic, not in the application code. Your application code just checks the flag. The flag system handles the targeting logic.

The flexibility of attribute-based targeting comes with a cost. Someone needs to maintain the attribute data. If you target based on tenant tier, someone needs to ensure that tier attribute is correct for every tenant. If you target based on user group membership, someone needs to manage group membership. Stale or incorrect attributes lead to incorrect flag behavior. A customer who should see a feature does not because their attributes are wrong. An internal user who should have beta access does not because they were never added to the beta-tester group.

## Flag Inheritance: Defaults with Specific Overrides

Flag inheritance means that a flag has a default value and then specific overrides for targeted users or tenants. The default applies to everyone unless they match a targeting rule, in which case the override applies. This pattern is cleaner than maintaining a giant list of every possible user or tenant and their flag value.

A typical inheritance structure: the flag defaults to false for everyone, but it is overridden to true for beta testers, internal users, and enterprise customers. The flag configuration specifies the default and the overrides. When the flag is evaluated, the system checks whether the current user or tenant matches any override rule. If yes, the override value is used. If no, the default value is used.

This makes rollout strategies clear. You start with the flag defaulting to false. You add overrides for internal users and beta testers. You test and iterate. You expand the overrides to include a small set of friendly customers. You continue testing. When ready to launch, you change the default from false to true. Now everyone gets the feature unless they are explicitly overridden to false. The overrides become an exclusion list rather than an inclusion list.

Flag inheritance also handles deprecation gracefully. You have a feature that is generally enabled but needs to be disabled for a few customers who found a bug that only affects their specific use case. The flag defaults to true. You add overrides that set it to false for the affected tenants. Those tenants stop seeing the feature immediately. Everyone else continues normally. When you fix the bug, you remove the overrides. The affected tenants start seeing the feature again.

Multiple overrides can exist in a hierarchy. The tenant-level override takes precedence over the default. The user-level override takes precedence over the tenant-level override. If a flag defaults to false, is overridden to true at the tenant level, and is overridden to false at the user level, a specific user in that tenant sees false even though their tenant sees true. This lets you handle exceptions: most users in a tenant should see the feature, but one specific user should not because they are using a legacy integration that breaks with the new feature.

## Managing Thousands of Targeting Rules

When you have hundreds of tenants and dozens of flags, the number of targeting rules explodes. Each flag can target multiple tenants. Each tenant can be targeted by multiple flags. Keeping track of which flags are enabled for which tenants becomes a data management problem, not just a configuration problem.

Flag management platforms solve this by providing UIs for managing targeting rules. You can view all flags for a tenant: what features are enabled, what overrides apply, what percentage rollouts they are in. You can view all tenants for a flag: who is targeted, what rules apply, what the effective flag value is for each tenant. This visibility is critical for support and debugging. When a customer reports that a feature is not working, you can immediately see whether the flag is enabled for them and why.

Rule cleanup is essential. As you ship features and remove flags, you must also remove the targeting rules associated with those flags. Stale targeting rules clutter your configuration and make it harder to understand what is actually in effect. Some flags are temporary — they gate a feature during rollout and then are removed when the feature is fully launched. When you remove the flag from code, you must also remove it from the flag management system and delete all its targeting rules.

Some teams automate rule cleanup by tagging flags with expiration dates or lifecycle stages. A flag tagged as rollout is expected to be removed after the rollout completes. A flag tagged as permanent gates a paid feature and should not be removed. The flag management system can surface flags that have been in rollout for more than three months and prompt engineers to either complete the rollout or explain why it is still needed. This prevents flag sprawl where hundreds of old flags accumulate and no one knows whether they are still used.

## Customer-Controlled Flags: Letting Customers Configure Their Own AI Behavior

Some teams go further and let customers control their own flags. A tenant admin UI shows flags that affect the tenant's AI behavior. The customer can toggle flags on or off within constraints you define. This gives customers agency over their AI experience without requiring them to contact support.

A typical use case is opting into beta features. You release a new capability as an opt-in beta. Customers who want to try it log into their admin panel and enable the beta feature flag. The feature turns on for their tenant immediately. Customers who prefer stability leave it disabled. When the beta is over, you promote the feature to general availability and remove the flag. Customers who had opted in continue seeing the feature. Customers who had not also start seeing it because it is now enabled by default.

Another use case is preference settings. A customer might want more verbose AI explanations. Another customer wants terse responses. You expose this as a customer-controlled flag: verbose mode on or off. The customer sets the flag in their settings. Your application reads the flag value and adjusts AI behavior accordingly. This is cleaner than building a full preference system — the flag infrastructure handles storage, retrieval, and evaluation.

Customer-controlled flags must be safe. You cannot let customers enable flags that would break their system or violate compliance requirements. The flags you expose to customers are a curated subset of all flags. Internal flags that control infrastructure routing, debugging features, or experimental capabilities remain hidden. Only flags that are safe for customers to toggle are exposed in the customer UI.

You also need audit logging for customer-controlled flags. When a customer changes a flag, you record who changed it, when they changed it, and what the previous and new values were. This is critical for support. When a customer reports an issue, you can see whether they recently toggled a flag that might explain the problem. It is also important for security. If a customer's account is compromised, you can see whether the attacker changed flag settings to enable features they should not have access to.

## Security Considerations: Who Can Create and Modify Targeting Rules

Targeting rules determine what users and tenants see. If an attacker can modify targeting rules, they can enable features for themselves that they should not have access to. If an internal bad actor can modify targeting rules, they can give themselves access to premium features, beta capabilities, or administrative functionality. Targeting rule management must be access-controlled and audited.

Role-based access control is standard. Engineers can create and modify flags. Product managers can update targeting rules for flags they own. Customer support can add specific users to troubleshooting flags but cannot change default flag values. Customers can control their own customer-facing flags but cannot see or modify internal flags. Each role has specific permissions that limit what flag operations they can perform.

Audit logging is mandatory. Every flag configuration change is logged with who made the change, when, what changed, and why if a reason was provided. When a feature is unexpectedly enabled for a tenant, you can trace back to who added the targeting rule and when. When a percentage rollout goes wrong, you can see who increased the percentage and whether they followed the review process.

Some teams require two-person approval for production flag changes. One person proposes the change, another reviews and approves. This prevents accidental changes and makes sabotage harder. The process is lightweight — the approver just reviews the proposed change in the flag management UI and clicks approve — but it adds a checkpoint that catches mistakes and malicious changes.

Flags that affect security-sensitive features need extra controls. A flag that disables authentication for certain users cannot be modified by customer support or product managers. Only security team members can modify it, and all changes require security team approval. These high-impact flags are tagged in the flag management system so that automated checks can enforce the access controls.

Targeted flags give you precise control over who sees what, but the next level of sophistication is conditional flags that evaluate arbitrary expressions to determine whether a feature should be enabled — flags that can route based on request attributes, time of day, or any other context you can capture.

