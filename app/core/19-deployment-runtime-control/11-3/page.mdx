# 11.3 â€” Partial Rollback: Affected Users or Segments Only

What if the problem only affects some users? Do you roll back everyone, or just the affected segment? This question appears in every incident where degradation is not universal. A new model version performs well for ninety percent of users but hallucinates for users in a specific geographic region. A prompt change improves responses for most queries but breaks responses for a narrow class of questions. A configuration update works fine during low traffic but causes timeouts during peak load. In each of these scenarios, full rollback fixes the problem but also removes the improvement for the majority of users who were not affected. Partial rollback, reverting only for the affected segment, is often the better answer. It is also significantly harder to execute.

Partial rollback is the practice of reverting a deployment for a subset of traffic while keeping the new version active for everyone else. The affected segment returns to the previous known-good version. The unaffected segment continues using the new version. This reduces the cost of rollback, preserves the gains from the deployment, and limits the blast radius of recovery. It is a powerful capability. It is also a capability that introduces complexity, increases the risk of state inconsistency, and can create operational confusion if not managed carefully.

## Segment Identification: Determining Who Is Affected by the Bad Deployment

Partial rollback is only possible if you can identify which users are affected. This requires that your monitoring and logging infrastructure provides segment-level visibility. You cannot roll back a segment if you do not know which segment is broken. Most teams discover the need for partial rollback only after deploying a change that affects a specific cohort, and only then do they realize that their observability does not support segment-level analysis. By that point, the only option is full rollback. Partial rollback must be designed in advance.

Segment-level visibility means breaking down quality metrics by user attributes: geographic region, language, user tier, subscription level, device type, session characteristics. When you deploy a new version, you do not just look at aggregate hallucination rate or aggregate task success. You look at hallucination rate by region, task success by language, latency by device type. If one segment degrades while others remain stable, you have identified the scope of the problem. This scope becomes the rollback target.

The most common segmentation dimensions are geographic region, A/B test cohort, and tenant or customer ID. Geographic segmentation is useful when degradation is caused by region-specific data skew, latency to external services, or infrastructure differences across data centers. A/B test cohort segmentation is built into most gradual rollout strategies: if the treatment group degrades, roll back the treatment while keeping the control. Tenant segmentation is essential for multi-tenant systems where one customer may be affected by a deployment while others are not.

Segmentation must be real-time. If it takes thirty minutes to run a query that identifies which users are affected, partial rollback is not fast enough to matter. Real-time segmentation requires pre-aggregated metrics, fast query infrastructure, and dashboards that expose segment-level breakdowns immediately. Invest in this infrastructure before you need partial rollback. The ability to detect segment-specific degradation is as important as the ability to roll back, and it is a prerequisite for partial rollback to be operationally useful.

## Targeting Rollback: Using Feature Flags to Revert Specific Users

Once you have identified the affected segment, you need a mechanism to revert only that segment. The most flexible mechanism is feature flags with targeting rules. A feature flag does not just control whether a feature is enabled or disabled globally. It controls which users see the feature based on attributes like user ID, region, or cohort. When you deploy a new version wrapped in a feature flag, you can roll back by setting the flag to disabled for the affected segment while leaving it enabled for everyone else.

Feature flag targeting works like this. You deploy a new model version behind a feature flag. The flag starts at ten percent rollout, then fifty percent, then one hundred percent. During the one hundred percent phase, you detect that users in the EU region are experiencing elevated error rates. You update the flag targeting rule to disable the feature for users in the EU region. Within seconds, EU users are served by the previous version, and the rest of the world continues using the new version. This is partial rollback.

The challenge with feature flag targeting is that it requires your application to evaluate targeting rules on every request. If the rule is complex, multi-dimensional region AND subscription tier AND language, evaluation becomes expensive. The solution is to pre-compute targeting decisions and cache them. When a user makes a request, the system looks up their cached targeting decision rather than evaluating the rule from scratch. Cache invalidation must be fast, under thirty seconds, to ensure that rollback targeting changes propagate quickly.

Feature flag targeting also requires discipline around flag semantics. If the flag controls the model version, rolling back the flag must cleanly revert to the previous model. If the flag controls multiple behaviors, prompt version, model version, and routing logic, rolling back the flag must revert all of those behaviors. Flags that control too many things at once become difficult to reason about during incidents. Prefer narrow flags that control one behavior each, and use orchestration to coordinate rollback across multiple flags if necessary.

## A/B Test Rollback: Pulling the Losing Variant While Keeping the Winner

A/B testing is a form of partial rollback by design. You deploy two variants, A and B, and route a percentage of traffic to each. You measure quality for both. If variant B degrades relative to A, you roll back B by setting its traffic allocation to zero. Variant A continues serving traffic as if nothing happened. This is the cleanest form of partial rollback because the segment is predefined: it is the B cohort.

A/B test rollback is fast because the infrastructure is already built for traffic splitting. You do not need to identify an affected segment or configure targeting rules. You just adjust the traffic allocation. If B is currently receiving fifty percent of traffic, you change it to zero percent. The change propagates within the feature flag or load balancer update interval, typically under thirty seconds. All users who were seeing B are now seeing A.

The complexity in A/B test rollback is handling users mid-session. If a user starts a conversation with variant B, then you roll back B mid-conversation, what happens? The user's next request might be routed to variant A, which has different prompt behavior, different output structure, or different capabilities. The conversation context may not transfer cleanly. The user experience becomes inconsistent. To avoid this, A/B test rollback should be session-aware. Once a user is assigned to a variant, they remain on that variant for the duration of their session, even if you roll back the variant globally. New sessions are routed to A only.

Session-aware rollback requires session affinity. The system must track which variant each session is using and route subsequent requests in that session to the same variant. When you roll back variant B, existing sessions on B continue until they end naturally. New sessions are not assigned to B. Over time, the population of users on B decays to zero as sessions expire. This makes rollback gradual rather than instant, but it preserves user experience and avoids mid-session consistency issues.

## Geographic Rollback: Reverting a Specific Region While Others Stay on New Version

Geographic rollback is common in global deployments where model behavior varies by region due to language, cultural context, or data distribution. A deployment might work well in the US but degrade in Europe because the training data was English-heavy. A model might perform well in high-bandwidth regions but time out in regions with poor connectivity. When degradation is region-specific, rolling back only that region preserves the improvement everywhere else.

Geographic rollback requires region-aware routing. Your load balancer or API gateway must route requests based on the user's region and must support per-region version configuration. When you deploy a new version globally, each region is configured to serve that version. When you roll back the EU region, you update the EU region's configuration to serve the previous version. US, Asia, and other regions remain on the new version. Each region is independently controllable.

The challenge with geographic rollback is that regions are not always cleanly isolated. A user in the US might be traveling in Europe. A European user might be using a VPN that makes them appear to be in the US. If you roll back the EU region based on detected location, these users may experience inconsistent behavior depending on their network path. To handle this, geographic rollback should key off user account region, not IP-based geolocation. The user's account region is stable and unaffected by travel or VPNs.

Geographic rollback also requires region-specific monitoring. You cannot detect region-specific degradation if your metrics are global aggregates. You need per-region dashboards showing hallucination rate, task success, latency, and error rate for each region independently. When the EU dashboard shows degradation but the US dashboard does not, you have clear evidence that the problem is regional. Rollback is targeted to the EU. This level of granularity is essential for multi-region systems serving a global user base.

## Tenant-Specific Rollback: Reverting for One Customer Without Affecting Others

In multi-tenant systems, degradation can be customer-specific. A new model version might work well for most customers but fail for one customer whose use case or data distribution is unusual. Rolling back the entire deployment punishes all customers to fix one customer's problem. Tenant-specific rollback reverts the deployment for the affected customer while leaving it active for everyone else.

Tenant-specific rollback is the ultimate in rollback precision. Each tenant can be on a different model version, a different prompt configuration, or a different feature flag state. When tenant 42 reports quality issues, you investigate, confirm that the new version is the cause, and roll back tenant 42 to the previous version. Tenant 43, tenant 44, and all other tenants remain on the new version. Tenant 42's users see no further degradation. Other tenants see no interruption.

The infrastructure required for tenant-specific rollback is the same as for tenant-specific configuration: a version mapping table that stores which version each tenant is using. When a request comes in, the system looks up the tenant ID, retrieves the tenant's assigned version, and routes the request to that version. Rolling back a tenant means updating their version mapping. The change is immediate and affects only that tenant's traffic.

Tenant-specific rollback introduces operational complexity. You now have a heterogeneous deployment where different tenants are on different versions. This makes debugging harder because you cannot assume all traffic is seeing the same behavior. It makes upgrades harder because you must track which tenants are on which versions and coordinate migrations. It makes testing harder because you need to test version compatibility across a matrix of tenant configurations. These costs are real, but for B2B systems with high-value customers, the ability to isolate rollback is worth the complexity.

## Risk of Partial Rollback: Increased System Complexity

Partial rollback is not without downsides. The primary downside is complexity. When you support full rollback only, your system is simple: all traffic sees one version at a time. When you support partial rollback, your system must handle multiple versions simultaneously, route traffic based on segment attributes, and maintain consistency across heterogeneous states. Every piece of infrastructure that touches version management, load balancers, feature flags, monitoring, dashboards, becomes more complex.

Complexity creates failure modes. Targeting rules can have bugs. Cache invalidation can be delayed. Routing logic can be misconfigured. A partial rollback intended for ten percent of users might accidentally apply to ninety percent. A partial rollback intended for the EU might accidentally apply to the US. These errors are harder to detect than full rollback errors because the system still appears to be mostly working. Only a subset of users are affected, and if your monitoring does not break down by segment, you might not notice until users report issues.

Partial rollback also increases cognitive load during incidents. Full rollback is a binary decision: revert or not. Partial rollback is a multi-dimensional decision: which segment to revert, how large is that segment, do we revert just the model or the entire stack, do we revert gradually or instantly? These decisions require more information, more analysis, and more judgment. Under incident pressure, this complexity can slow down decision-making and extend time to recovery. Full rollback is often faster simply because it is simpler.

## When Partial Rollback Makes Sense vs When Full Rollback Is Safer

Partial rollback makes sense when the affected segment is small, the degradation is severe for that segment, and the improvement for the unaffected segment is significant. If five percent of users are broken and ninety-five percent are better off, partial rollback preserves value for the ninety-five percent. If ninety-five percent of users are broken and five percent are better off, full rollback is the right call. The decision depends on the ratio of harm to benefit.

Partial rollback makes sense when the affected segment is well-defined and stable. If you can clearly identify the segment, geographic region equals EU or tenant ID equals 42, and that segment does not change over time, partial rollback is safe. If the affected segment is fuzzy, users whose queries contain certain keywords or users whose sessions are longer than ten minutes, partial rollback becomes hard to target accurately. Fuzzy segments lead to rollback errors where the wrong users are reverted or the right users are missed.

Full rollback is safer when the degradation is widespread, when the affected segment is hard to identify, or when partial rollback infrastructure is immature. If you do not have real-time segment-level monitoring, full rollback is the only reliable option. If you have never executed partial rollback before, an incident is not the time to try it for the first time. Practice partial rollback in non-critical scenarios first. Use it for A/B test rollbacks where the segment is predefined and the stakes are lower. Build confidence before you rely on it for high-stakes incidents.

Full rollback is also safer when time is critical. Partial rollback requires analysis, decision-making, and configuration. Full rollback is one button. If you are in the middle of an incident and degradation is escalating, full rollback gets the system safe immediately. You can always roll forward to a fixed version later. Partial rollback is an optimization for situations where you have time to be precise. When you do not have time, default to full rollback.

## Monitoring Partial Rollback: Ensuring Reverted Segments Return to Expected Behavior

After executing partial rollback, you must verify that the reverted segment returned to expected behavior. This is not automatic. The segment is now on the previous version, but that does not guarantee that metrics will improve instantly. The degradation might have been caused by state accumulated during the bad deployment. The previous version might not be warm enough to handle the reverted traffic. The targeting rules might have been applied incorrectly.

Monitor the reverted segment separately from the rest of the system. If you rolled back the EU region, watch the EU region's metrics closely for the next thirty minutes. Verify that hallucination rate returns to baseline. Verify that task success improves. Verify that latency remains acceptable. If metrics do not improve, the problem was not the version. It was something else, infrastructure, data, external dependencies, and you need to investigate further.

Also monitor the non-reverted segments to ensure they were not affected by the partial rollback. Sometimes rolling back one segment has unintended side effects on others. If rolling back the EU region changes load distribution in a way that causes latency spikes in the US region, you have created a new problem while solving the old one. Partial rollback should be zero-impact on non-reverted segments. If it is not, your rollback mechanism is not isolated enough.

The goal of partial rollback is to minimize disruption while fixing a segment-specific problem. Verification is what ensures that goal was met. Do not assume partial rollback worked. Confirm it with data. If the reverted segment does not improve, escalate to full rollback or further investigation. If the non-reverted segments degrade, revert the partial rollback and go back to uniform state. Partial rollback is a tool, not a guarantee.

## Partial Rollback as an Advanced Capability

Partial rollback is not a day-one capability. It is an advanced capability that requires mature infrastructure, real-time segment-level observability, and operational discipline. Build full rollback first. Make full rollback instant, reliable, and well-practiced. Only after full rollback is a solved problem should you invest in partial rollback. Teams that try to build partial rollback without mastering full rollback end up with neither working correctly.

When you do build partial rollback, build it incrementally. Start with A/B test rollback, which is the simplest form. Then add geographic rollback. Then add tenant-specific rollback. Each layer requires more infrastructure and more operational complexity. Do not try to build the fully general solution on day one. Build the specific solutions you need, prove they work, and expand from there.

Partial rollback is a powerful tool for reducing the cost of recovery. It allows you to fix problems for affected users without removing improvements for unaffected users. But it is not a replacement for instant full rollback. Full rollback is your safety net. Partial rollback is an optimization. Keep the safety net strong, and add the optimization only when you are ready.

The most difficult form of rollback is data-aware rollback: handling the fact that some users have already received outputs from the bad version, and those outputs cannot be unsent. This requires a different kind of recovery strategy, one that addresses the consequences of bad outputs rather than just preventing future ones.

