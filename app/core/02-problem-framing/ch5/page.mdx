# Chapter 5 — Input/Output Specification: Defining the Contract

Every AI task is, at its core, a function: something goes in, something comes out. The I/O specification defines exactly what that "something" is — on both sides.

This sounds mechanical. It isn't. The I/O spec is where abstract success criteria become concrete enough to implement and test. It's where you discover that "the system should answer user questions" actually means handling seventeen different input formats, three languages, adversarial prompts, empty inputs, and conversation histories of varying length. It's where you find out that "the output should be helpful" means structured JSON in one context and natural language in another.

Your I/O spec is the contract that connects product intent to engineering implementation to evaluation criteria. Every field you define becomes something you can test. Every edge case you catalogue becomes a scenario in your eval set. Every constraint you specify becomes a guardrail in production.

This chapter covers input specs, output specs, edge cases, uncertainty handling, tool contracts for agentic systems, and locale specifications for multilingual products.

---

## What This Chapter Covers

- **5.1** — Why I/O Specs Matter More Than You Think
- **5.2** — Input Specification: What the System Receives
- **5.3** — Input Variability and Edge Cases
- **5.4** — Output Specification: What the System Produces
- **5.5** — Output Quality Dimensions per Task Type
- **5.6** — Handling Uncertainty in Outputs
- **5.7** — I/O Specs for Multi-Step and Agentic Systems
- **5.8** — I/O Specs as Evaluation Scaffolding
- **5.9** — Versioning I/O Specs as Your Product Evolves
- **5.10** — Tool Contracts: Permissions, Idempotency, Rate Limits, Audit Logs
- **5.11** — Locale and Language Specs: Formats, Tone, Policy Differences, Fallback

---

*Let's start with why the I/O spec is the most underrated artifact in AI engineering.*
