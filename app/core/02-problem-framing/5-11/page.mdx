# 5.11 — Locale and Language Specs: Formats, Tone, Policy Differences, Fallback

In late 2024, a fintech startup with 90 employees launched an AI-powered expense management tool across 15 countries simultaneously. The system categorized receipts, generated expense reports, and surfaced spending insights in natural language. Their English-language product had been running for eight months with strong reviews. The international launch was supposed to be a localization project: translate the prompts, swap the currency symbols, ship it. Within the first month, they lost their largest German enterprise client, received a formal complaint from their French banking partner, and discovered that their Japanese expense categorizations were producing outputs that a native speaker described as "somewhere between a toddler and a legal document written by someone who learned Japanese from anime subtitles."

The German client left because the system formatted dates as month-day-year instead of day-month-year, displayed amounts with commas as thousands separators instead of periods, and used decimal points instead of decimal commas. Every expense report it generated was unreadable to their accounting department. The French banking partner filed a complaint because the system's natural language summaries used informal "tu" instead of formal "vous" when addressing users, violating the partner's brand guidelines and French business communication norms. The Japanese categorization failure was more subtle: the model had been prompted in English to categorize expenses, and the output was machine-translated Japanese that used literal translations of English category names instead of the standard Japanese accounting terminology that every bookkeeper in the country expected.

The company spent four months rebuilding their localization infrastructure. The total cost was $1.2 million, including lost revenue from churned clients, engineering time, and professional translation services. The CEO later said in an internal retrospective that they had treated localization as a cosmetic layer when it was actually a fundamental specification problem. Dates, numbers, tone, terminology, and even which expense categories exist are not universal constants. They are locale-specific requirements that must be defined in the I/O spec or the system will produce outputs that are technically functional and practically useless.

## Why Locale Is an I/O Specification Problem

Locale is not a feature you add after the product works. It is a set of constraints on every input and output your system processes. When you define your I/O spec without locale requirements, you are implicitly defining a spec for one locale, usually American English, and you are creating technical debt that compounds with every integration, every UI, and every downstream system that consumes your outputs.

The reason locale belongs in the I/O spec rather than in a translation layer is that locale affects the structure and semantics of your data, not just the surface language. A date formatted as "03/04/2026" means March 4th in the United States and April 3rd in Germany. A number displayed as "1,234.56" is one thousand two hundred thirty-four point five six in the US and an error in Germany, where the correct format is "1.234,56." A currency amount of "$1,500" is ambiguous without knowing whether the dollar sign refers to US dollars, Canadian dollars, Australian dollars, or any of the other currencies that use the dollar sign. These are not presentation issues. They are data integrity issues. If your system extracts a date from a German document and formats it in American style, the downstream system will process the wrong date. No amount of translation fixes that.

**Locale specification** in your I/O contract means defining, for each supported locale, the exact format for dates, times, numbers, currencies, addresses, phone numbers, and any other structured data your system processes. It means defining the tone and formality register for generated text. It means defining which categories, labels, and terminology are appropriate for each market. And it means defining what happens when the system encounters an input in a locale it does not support.

## Format Specifications by Locale

Every locale has conventions for how structured data is displayed, and these conventions are not optional. They are expectations that every user, every accountant, every compliance officer, and every downstream system in that locale assumes will be followed. Your I/O spec must define the format for each data type in each supported locale.

**Date formats** vary dramatically across locales. The United States uses month-day-year. Germany, France, and most of Europe use day-month-year. Japan uses year-month-day. China uses year-month-day with specific characters between the components. Some locales use slashes as separators, others use periods, others use hyphens. Your spec must define the exact date format string for each locale, and your system must apply that format consistently in both parsing and generation. If your system extracts a date from an input document, it must parse it according to the source locale's format. If your system generates a date in an output, it must format it according to the target locale's format. Mixing these up is one of the most common locale bugs, and it produces silent data corruption because the wrong date still looks like a valid date.

**Number formats** follow a similar pattern. The United States and United Kingdom use a period as the decimal separator and a comma as the thousands separator. Germany, France, Brazil, and much of continental Europe use a comma as the decimal separator and a period as the thousands separator. India uses a unique grouping system where the first group is three digits but subsequent groups are two digits, so one million is written as "10,00,000." Switzerland uses an apostrophe as the thousands separator. Your spec must define the number format for each locale and your system must apply it consistently. A system that displays "1,234.56" to a German user is displaying a number that reads as "one point two three four comma five six," which is nonsensical.

**Currency formats** add another layer. Some locales place the currency symbol before the number, others after. Some use a space between the symbol and the number, others do not. Some locales use the ISO 4217 currency code instead of a symbol. The euro is displayed as "1.234,56 EUR" in some European contexts and as "EUR 1,234.56" in others. Your spec must define the currency display format for each locale and must also specify how currency conversion is handled when the input currency differs from the display currency.

**Address formats** vary by country in ways that affect extraction tasks. US addresses follow a specific structure of street, city, state, zip code. Japanese addresses go from largest to smallest: prefecture, city, district, block, building. German addresses put the house number after the street name, not before. If your system extracts or generates addresses, the format spec must be locale-specific or the outputs will be unusable.

## Tone and Formality Registers

Language tone is not a universal setting you can toggle globally. Different locales have fundamentally different expectations for formality, and these expectations are not preferences — they are social contracts. Using the wrong register in a business context can be offensive, unprofessional, or simply confusing.

**Formality levels** in many languages are grammatically encoded, not just stylistic choices. French has "tu" for informal and "vous" for formal address. German has "du" and "Sie." Japanese has an entire system of honorific speech called keigo with three levels: teineigo for polite speech, sonkeigo for respectful speech about others, and kenjougo for humble speech about oneself. Spanish distinguishes "tú" and "usted" in most dialects. Korean has seven speech levels. When your system generates text in these languages, the formality level must match the context. A customer support chatbot addressing a banking customer in informal French is as jarring as a customer service agent calling a new client "dude" in English. It is not wrong in the sense of being ungrammatical. It is wrong in the sense of violating social expectations and damaging trust.

Your I/O spec must define the formality register for each locale and each context. A B2B product might use formal address in all locales. A consumer social app might use informal address in all locales. A product that serves both might need to switch registers based on user preferences or context. The spec should state explicitly: "In French, all user-facing text uses vous form. In German, all user-facing text uses Sie form. In Japanese, all user-facing text uses teineigo level." This is not a style guide suggestion. It is a hard requirement that the system must satisfy, and it should be evaluated the same way you evaluate any other output quality dimension.

**Cultural tone expectations** go beyond formality grammar. Some cultures expect directness in business communication. German and Dutch business writing tends to be direct and explicit. Japanese business communication tends to be indirect, with important information implied rather than stated explicitly. American English tends to be optimistic and action-oriented. British English tends to be more understated. A system that generates business summaries in the same direct American style across all locales will produce outputs that feel abrasive to Japanese users, overly casual to German users, and perfectly natural to American users. Your tone spec must account for these cultural communication norms.

## Policy Differences Across Jurisdictions

Locale is not just about language and formatting. It also encompasses legal and regulatory requirements that differ by jurisdiction. Your I/O spec must account for these differences because they affect what your system can say, what data it can process, and how outputs must be structured.

**Data privacy regulations** vary by jurisdiction and affect what information your system can include in outputs. Under GDPR, which applies to European Union users, your system cannot include personally identifiable information in outputs unless there is a lawful basis for processing. Under CCPA in California, users have the right to know what personal information is collected and to request deletion. Under APPI in Japan, there are specific rules about cross-border data transfer. Your I/O spec must define, for each locale, what data fields are permitted in outputs and what fields must be redacted, anonymized, or excluded.

**Content regulations** also vary. Germany has strict laws about hate speech and Holocaust denial. China has specific requirements about content that the government considers sensitive. The EU AI Act, now fully enforced in 2026, imposes transparency requirements on AI-generated content in high-risk domains. Some jurisdictions require that AI-generated content be labeled as such. Your system must comply with these regulations in each locale it serves, and the I/O spec is where these requirements are documented.

**Industry-specific regulations** add another layer. Financial advice is regulated differently in the United States, the United Kingdom, and the European Union. Healthcare information is governed by HIPAA in the United States but by different frameworks in other jurisdictions. Legal information varies by jurisdiction in ways that are fundamental to its correctness: a legal conclusion that is accurate under US law might be completely wrong under German law. If your system operates in regulated domains across multiple locales, the I/O spec must define jurisdiction-specific constraints on what the system can and cannot say.

**Category and taxonomy differences** are a subtler form of policy variation. Expense categories that make sense in the United States might not map cleanly to categories used in other markets. A "business lunch" deduction exists in many jurisdictions but the rules about what qualifies differ. Product categories in e-commerce vary by market. Medical diagnosis codes differ between ICD-10-CM used in the United States and the international ICD-10 standard. Your I/O spec must define locale-specific taxonomies where the categories themselves differ, not just the language used to describe them.

## Fallback Strategies for Unsupported Locales

No system supports every locale on day one. You need a clear strategy for what happens when the system encounters a locale it does not support. The fallback strategy must be defined in the I/O spec, not left as an engineering decision made under pressure during an incident.

**The worst fallback is silent degradation.** This is what the fintech startup did: they served English-formatted outputs to non-English users without any indication that the system was not operating in the user's locale. The user sees dates, numbers, and text that look wrong but has no way to know whether the system made an error or simply does not support their locale. Silent degradation erodes trust because users cannot distinguish between a localization gap and a bug.

**The second worst fallback is no output at all.** Refusing to process requests from unsupported locales is better than silent degradation, but it is still a poor user experience. Users who are blocked entirely will leave and not come back.

**The correct fallback is explicit degradation with disclosure.** The system should detect that the input locale is not fully supported, process the request using the closest supported locale, and clearly indicate to the user that the output may not be formatted or expressed according to their local conventions. The output should include a metadata field indicating which locale was used and whether it was the requested locale or a fallback. This way, downstream systems and users can decide how to handle the output.

Your fallback spec should define a **locale fallback chain** for each unsupported locale. Brazilian Portuguese might fall back to European Portuguese, then to Spanish, then to English. Swiss German might fall back to standard German. Canadian French might fall back to European French. The fallback chain should be based on linguistic and cultural proximity, not arbitrary defaults. And the spec should define which aspects of the output use the fallback locale: format only, tone only, terminology only, or everything.

You also need to define the **minimum viable locale support** for each market. Before you launch in a new market, what must be localized? At minimum, date and number formatting must be correct because these are data integrity issues. Currency display must be correct. Formality register must be appropriate. Category names must make sense. Everything else might be acceptable as a known limitation in an early launch, as long as it is disclosed.

## Locale-Aware Evaluation

Locale specifications are only useful if you evaluate against them. Your evaluation framework must test locale-specific requirements the same way it tests any other output quality dimension. This means having eval sets for each supported locale, with locale-specific ground truth that reflects local formatting, terminology, and tone expectations.

**Format evaluation** is the easiest to automate. You can write deterministic checks that verify date formats, number formats, currency displays, and address structures match the locale specification. These checks should run on every output and flag any format violations. A single date in the wrong format is a bug, not a tolerable imperfection.

**Tone evaluation** is harder and typically requires human evaluation by native speakers. A French speaker can immediately tell whether text uses tu or vous. A Japanese speaker can assess whether keigo is used correctly. A German speaker can evaluate whether the formality level is appropriate for a business context. You need native-speaker evaluators for each supported locale, and they need evaluation guidelines that specify the expected formality register and cultural tone norms.

**Terminology evaluation** requires domain expertise in each locale. A Japanese accountant can tell you whether expense category names match standard Japanese accounting terminology. A German legal professional can tell you whether legal terms are translated correctly or literally. Machine translation is not sufficient for terminology evaluation because machine translation often produces literally correct but professionally wrong translations.

**Policy compliance evaluation** requires legal review for each jurisdiction. Your legal team or external counsel must verify that outputs comply with local regulations. This is not a one-time check. Regulations change, and your evaluation must keep pace.

## Building Locale Into the I/O Spec from Day One

The fintech startup's $1.2 million mistake was avoidable. If they had included locale as a first-class dimension in their I/O spec from the beginning, they would have designed their system to handle locale-specific formatting, defined tone requirements for each market, mapped category taxonomies to local conventions, and built evaluation infrastructure that caught locale bugs before users did.

Even if you launch in a single locale, your I/O spec should include a locale field. Every output should carry metadata indicating which locale it was generated for. Every input should be tagged with its source locale. This infrastructure costs almost nothing to build upfront and saves enormous rework when you expand to new markets.

The discipline is the same as with uncertainty handling: acknowledge reality from the start. Your users are not all American English speakers. Your formats are not universal. Your tone expectations are not global. Your regulations are not uniform. Build these differences into your spec or discover them painfully in production.

You now have a complete I/O specification framework that covers inputs, outputs, edge cases, uncertainty, tool contracts, and locale requirements. The next step is to package everything from your problem framing work into artifacts that your evaluation and engineering teams can actually use. That is the framing-to-evaluation handoff, covered in Chapter 6.
