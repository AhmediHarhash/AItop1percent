# 5.11 — Locale and Language Specs: Formats, Tone, Policy Differences, Fallback

In late 2024, a fintech startup with 90 employees launched an AI-powered expense management tool across 15 countries simultaneously. The system categorized receipts, generated expense reports, and surfaced spending insights in natural language. Their English-language product had been running for eight months with strong reviews. The international launch was supposed to be a localization project: translate the prompts, swap the currency symbols, ship it. Within the first month, they lost their largest German enterprise client, received a formal complaint from their French banking partner, and discovered that their Japanese expense categorizations were producing outputs that a native speaker described as "somewhere between a toddler and a legal document written by someone who learned Japanese from anime subtitles."

The German client left because the system formatted dates as month-day-year instead of day-month-year, displayed amounts with commas as thousands separators instead of periods, and used decimal points instead of decimal commas. Every expense report it generated was unreadable to their accounting department. The French banking partner filed a complaint because the system's natural language summaries used informal "tu" instead of formal "vous" when addressing users, violating the partner's brand guidelines and French business communication norms. The Japanese categorization failure was more subtle: the model had been prompted in English to categorize expenses, and the output was machine-translated Japanese that used literal translations of English category names instead of the standard Japanese accounting terminology that every bookkeeper in the country expected.

The company spent four months rebuilding their localization infrastructure. The total cost was $1.2 million, including lost revenue from churned clients, engineering time, and professional translation services. The CEO later said in an internal retrospective that they had treated localization as a cosmetic layer when it was actually a fundamental specification problem. Dates, numbers, tone, terminology, and even which expense categories exist are not universal constants. They are locale-specific requirements that must be defined in the I/O spec or the system will produce outputs that are technically functional and practically useless.

## Why Locale Is an I/O Specification Problem

Locale is not a feature you add after the product works. It is a set of constraints on every input and output your system processes. When you define your I/O spec without locale requirements, you are implicitly defining a spec for one locale, usually American English, and you are creating technical debt that compounds with every integration, every UI, and every downstream system that consumes your outputs.

The reason locale belongs in the I/O spec rather than in a translation layer is that locale affects the structure and semantics of your data, not just the surface language. A date formatted as "03/04/2026" means March 4th in the United States and April 3rd in Germany. A number displayed as "1,234.56" is one thousand two hundred thirty-four point five six in the US and an error in Germany, where the correct format is "1.234,56." A currency amount of "$1,500" is ambiguous without knowing whether the dollar sign refers to US dollars, Canadian dollars, Australian dollars, or any of the other currencies that use the dollar sign. These are not presentation issues. They are data integrity issues. If your system extracts a date from a German document and formats it in American style, the downstream system will process the wrong date. No amount of translation fixes that.

**Locale specification** in your I/O contract means defining, for each supported locale, the exact format for dates, times, numbers, currencies, addresses, phone numbers, and any other structured data your system processes. It means defining the tone and formality register for generated text. It means defining which categories, labels, and terminology are appropriate for each market. And it means defining what happens when the system encounters an input in a locale it does not support.

## Format Specifications by Locale

Every locale has conventions for how structured data is displayed, and these conventions are not optional. They are expectations that every user, every accountant, every compliance officer, and every downstream system in that locale assumes will be followed. Your I/O spec must define the format for each data type in each supported locale.

**Date formats** vary dramatically across locales. The United States uses month-day-year. Germany, France, and most of Europe use day-month-year. Japan uses year-month-day. China uses year-month-day with specific characters between the components. Some locales use slashes as separators, others use periods, others use hyphens. Your spec must define the exact date format string for each locale, and your system must apply that format consistently in both parsing and generation. If your system extracts a date from an input document, it must parse it according to the source locale's format. If your system generates a date in an output, it must format it according to the target locale's format. Mixing these up is one of the most common locale bugs, and it produces silent data corruption because the wrong date still looks like a valid date.

**Number formats** follow a similar pattern. The United States and United Kingdom use a period as the decimal separator and a comma as the thousands separator. Germany, France, Brazil, and much of continental Europe use a comma as the decimal separator and a period as the thousands separator. India uses a unique grouping system where the first group is three digits but subsequent groups are two digits, so one million is written as "10,00,000." Switzerland uses an apostrophe as the thousands separator. Your spec must define the number format for each locale and your system must apply it consistently. A system that displays "1,234.56" to a German user is displaying a number that reads as "one point two three four comma five six," which is nonsensical.

**Currency formats** add another layer. Some locales place the currency symbol before the number, others after. Some use a space between the symbol and the number, others do not. Some locales use the ISO 4217 currency code instead of a symbol. The euro is displayed as "1.234,56 EUR" in some European contexts and as "EUR 1,234.56" in others. Your spec must define the currency display format for each locale and must also specify how currency conversion is handled when the input currency differs from the display currency.

**Address formats** vary by country in ways that affect extraction tasks. US addresses follow a specific structure of street, city, state, zip code. Japanese addresses go from largest to smallest: prefecture, city, district, block, building. German addresses put the house number after the street name, not before. If your system extracts or generates addresses, the format spec must be locale-specific or the outputs will be unusable.

## Tone and Formality Registers

Language tone is not a universal setting you can toggle globally. Different locales have fundamentally different expectations for formality, and these expectations are not preferences — they are social contracts. Using the wrong register in a business context can be offensive, unprofessional, or simply confusing.

**Formality levels** in many languages are grammatically encoded, not just stylistic choices. French has "tu" for informal and "vous" for formal address. German has "du" and "Sie." Japanese has an entire system of honorific speech called keigo with three levels: teineigo for polite speech, sonkeigo for respectful speech about others, and kenjougo for humble speech about oneself. Spanish distinguishes "tú" and "usted" in most dialects. Korean has seven speech levels. When your system generates text in these languages, the formality level must match the context. A customer support chatbot addressing a banking customer in informal French is as jarring as a customer service agent calling a new client "dude" in English. It is not wrong in the sense of being ungrammatical. It is wrong in the sense of violating social expectations and damaging trust.

Your I/O spec must define the formality register for each locale and each context. A B2B product might use formal address in all locales. A consumer social app might use informal address in all locales. A product that serves both might need to switch registers based on user preferences or context. The spec should state explicitly: "In French, all user-facing text uses vous form. In German, all user-facing text uses Sie form. In Japanese, all user-facing text uses teineigo level." This is not a style guide suggestion. It is a hard requirement that the system must satisfy, and it should be evaluated the same way you evaluate any other output quality dimension.

**Cultural tone expectations** go beyond formality grammar. Some cultures expect directness in business communication. German and Dutch business writing tends to be direct and explicit. Japanese business communication tends to be indirect, with important information implied rather than stated explicitly. American English tends to be optimistic and action-oriented. British English tends to be more understated. A system that generates business summaries in the same direct American style across all locales will produce outputs that feel abrasive to Japanese users, overly casual to German users, and perfectly natural to American users. Your tone spec must account for these cultural communication norms.

## Policy Differences Across Jurisdictions

Locale is not just about language and formatting. It also encompasses legal and regulatory requirements that differ by jurisdiction. Your I/O spec must account for these differences because they affect what your system can say, what data it can process, and how outputs must be structured.

**Data privacy regulations** vary by jurisdiction and affect what information your system can include in outputs. Under GDPR, which applies to European Union users, your system cannot include personally identifiable information in outputs unless there is a lawful basis for processing. Under CCPA in California, users have the right to know what personal information is collected and to request deletion. Under APPI in Japan, there are specific rules about cross-border data transfer. Your I/O spec must define, for each locale, what data fields are permitted in outputs and what fields must be redacted, anonymized, or excluded.

**Content regulations** also vary. Germany has strict laws about hate speech and Holocaust denial. China has specific requirements about content that the government considers sensitive. The EU AI Act, now fully enforced in 2026, imposes transparency requirements on AI-generated content in high-risk domains. Some jurisdictions require that AI-generated content be labeled as such. Your system must comply with these regulations in each locale it serves, and the I/O spec is where these requirements are documented.

**Industry-specific regulations** add another layer. Financial advice is regulated differently in the United States, the United Kingdom, and the European Union. Healthcare information is governed by HIPAA in the United States but by different frameworks in other jurisdictions. Legal information varies by jurisdiction in ways that are fundamental to its correctness: a legal conclusion that is accurate under US law might be completely wrong under German law. If your system operates in regulated domains across multiple locales, the I/O spec must define jurisdiction-specific constraints on what the system can and cannot say.

**Category and taxonomy differences** are a subtler form of policy variation. Expense categories that make sense in the United States might not map cleanly to categories used in other markets. A "business lunch" deduction exists in many jurisdictions but the rules about what qualifies differ. Product categories in e-commerce vary by market. Medical diagnosis codes differ between ICD-10-CM used in the United States and the international ICD-10 standard. Your I/O spec must define locale-specific taxonomies where the categories themselves differ, not just the language used to describe them.

## Fallback Strategies for Unsupported Locales

No system supports every locale on day one. You need a clear strategy for what happens when the system encounters a locale it does not support. The fallback strategy must be defined in the I/O spec, not left as an engineering decision made under pressure during an incident.

**The worst fallback is silent degradation.** This is what the fintech startup did: they served English-formatted outputs to non-English users without any indication that the system was not operating in the user's locale. The user sees dates, numbers, and text that look wrong but has no way to know whether the system made an error or simply does not support their locale. Silent degradation erodes trust because users cannot distinguish between a localization gap and a bug.

**The second worst fallback is no output at all.** Refusing to process requests from unsupported locales is better than silent degradation, but it is still a poor user experience. Users who are blocked entirely will leave and not come back.

**The correct fallback is explicit degradation with disclosure.** The system should detect that the input locale is not fully supported, process the request using the closest supported locale, and clearly indicate to the user that the output may not be formatted or expressed according to their local conventions. The output should include a metadata field indicating which locale was used and whether it was the requested locale or a fallback. This way, downstream systems and users can decide how to handle the output.

Your fallback spec should define a **locale fallback chain** for each unsupported locale. Brazilian Portuguese might fall back to European Portuguese, then to Spanish, then to English. Swiss German might fall back to standard German. Canadian French might fall back to European French. The fallback chain should be based on linguistic and cultural proximity, not arbitrary defaults. And the spec should define which aspects of the output use the fallback locale: format only, tone only, terminology only, or everything.

You also need to define the **minimum viable locale support** for each market. Before you launch in a new market, what must be localized? At minimum, date and number formatting must be correct because these are data integrity issues. Currency display must be correct. Formality register must be appropriate. Category names must make sense. Everything else might be acceptable as a known limitation in an early launch, as long as it is disclosed.

## Locale-Aware Evaluation

Locale specifications are only useful if you evaluate against them. Your evaluation framework must test locale-specific requirements the same way it tests any other output quality dimension. This means having eval sets for each supported locale, with locale-specific ground truth that reflects local formatting, terminology, and tone expectations.

**Format evaluation** is the easiest to automate. You can write deterministic checks that verify date formats, number formats, currency displays, and address structures match the locale specification. These checks should run on every output and flag any format violations. A single date in the wrong format is a bug, not a tolerable imperfection.

**Tone evaluation** is harder and typically requires human evaluation by native speakers. A French speaker can immediately tell whether text uses tu or vous. A Japanese speaker can assess whether keigo is used correctly. A German speaker can evaluate whether the formality level is appropriate for a business context. You need native-speaker evaluators for each supported locale, and they need evaluation guidelines that specify the expected formality register and cultural tone norms.

**Terminology evaluation** requires domain expertise in each locale. A Japanese accountant can tell you whether expense category names match standard Japanese accounting terminology. A German legal professional can tell you whether legal terms are translated correctly or literally. Machine translation is not sufficient for terminology evaluation because machine translation often produces literally correct but professionally wrong translations.

**Policy compliance evaluation** requires legal review for each jurisdiction. Your legal team or external counsel must verify that outputs comply with local regulations. This is not a one-time check. Regulations change, and your evaluation must keep pace.

## Building Locale Into the I/O Spec from Day One

The fintech startup's $1.2 million mistake was avoidable. If they had included locale as a first-class dimension in their I/O spec from the beginning, they would have designed their system to handle locale-specific formatting, defined tone requirements for each market, mapped category taxonomies to local conventions, and built evaluation infrastructure that caught locale bugs before users did.

Even if you launch in a single locale, your I/O spec should include a locale field. Every output should carry metadata indicating which locale it was generated for. Every input should be tagged with its source locale. This infrastructure costs almost nothing to build upfront and saves enormous rework when you expand to new markets.

The discipline is the same as with uncertainty handling: acknowledge reality from the start. Your users are not all American English speakers. Your formats are not universal. Your tone expectations are not global. Your regulations are not uniform. Build these differences into your spec or discover them painfully in production.

## The Locale-Specific Prompt Engineering Challenge

When you build prompts for multi-locale systems, you face a choice: write one prompt in English and rely on the model's multilingual capabilities, or write separate prompts in each target language. Both approaches have trade-offs that must be specified in your I/O contract.

The **English-only prompting strategy** uses English prompts regardless of the target output locale. You instruct the model in English to generate output in the target language with locale-specific formatting. This approach is simpler to maintain because you have one canonical prompt, and you rely on the model's cross-lingual transfer capabilities. The risk is that the model's understanding of your task might be strongest in English, and subtle requirements might not translate correctly when the model switches to the target language. A prompt that says "use formal business tone" in English might not produce the same formality level in Japanese or German, because the model's training data contains different proportions and styles of business text in each language.

The **native-language prompting strategy** writes the prompt in the target language. You have a French prompt for French outputs, a Japanese prompt for Japanese outputs, and so on. This approach gives you more control over tone and terminology because you can specify requirements using the exact words and grammatical constructions that you want in the output. The trade-off is complexity: you now have multiple prompts to maintain, and changes to your requirements must be propagated across all language versions. You also need native speakers to write and review each prompt, which increases your operational cost and requires more diverse expertise on your team.

Your I/O spec should define which strategy you are using and justify the choice based on your quality requirements and operational constraints. For low-stakes applications where approximate tone is acceptable, English-only prompting is usually sufficient. For high-stakes applications where precise formality and terminology are critical, native-language prompting is worth the additional complexity. Some teams use a hybrid approach where the core task instructions are in English but tone and style guidance is provided in the target language, combining the simplicity of single-prompt maintenance with the precision of native-language specification.

## Locale and Right-to-Left Language Support

Right-to-left languages like Arabic and Hebrew introduce layout and formatting challenges that go beyond simple text generation. Your I/O spec must address how RTL content is structured, displayed, and integrated with LTR content in mixed-language contexts.

**Text direction** must be specified at the field level, not just the document level. In a bilingual interface where some fields are in English and others in Arabic, each field needs explicit direction metadata. HTML uses the dir attribute for this, but if your outputs are consumed by systems that do not understand HTML, you need a different convention. Your spec might define that RTL fields are marked with a language tag that implies direction, or that direction is a separate metadata field in your output schema.

**Number and date handling in RTL contexts** is particularly tricky. Arabic-speaking countries use Arabic-Indic numerals in some contexts and Western Arabic numerals in others, depending on the country and the domain. Your spec must define which numeral system is used for each locale. Dates in RTL languages are often written right-to-left, but the internal structure might still follow Western conventions or might use locale-specific month names. Your spec must define the exact format and the exact character set for each component.

**Mixed directionality** within a single output is common when RTL text includes LTR elements like URLs, email addresses, or product codes. The Unicode bidirectional algorithm handles this automatically in most rendering engines, but if your outputs are consumed by systems that do not implement the bidi algorithm correctly, you need to provide explicit direction markers or escaping. Your spec should state whether your system is responsible for inserting bidi control characters or whether the consuming system handles directionality.

## Character Encoding and Script Handling

Locale specifications must include character encoding and script requirements to ensure that your outputs render correctly and are processable by downstream systems. In 2026, UTF-8 is the de facto standard, but not all systems support it correctly, and some locales use multiple scripts that must be handled distinctly.

**UTF-8 encoding** should be specified explicitly in your I/O contract, even though it is the standard. Some legacy systems still expect ISO-8859 or Windows-1252 encoding for Western European languages, or Shift-JIS for Japanese. Your spec must define what encoding your system outputs and whether it is responsible for transcoding when integrating with legacy systems. If your system produces UTF-8 but a downstream system requires Shift-JIS, the I/O contract must specify who handles the conversion and what happens if characters cannot be represented in the target encoding.

**Script variations** within a single language must be specified. Chinese can be written in Simplified or Traditional characters, and the choice depends on the region: mainland China uses Simplified, Taiwan and Hong Kong use Traditional. Serbian can be written in Cyrillic or Latin script. Your spec must define which script is used for each locale, and whether your system supports both or only one. If a user requests Traditional Chinese output but your system only supports Simplified, the fallback behavior must be defined: do you serve Simplified with a warning, or do you refuse the request entirely.

**Font and rendering considerations** are usually outside the scope of an I/O spec, but if your outputs include preformatted text or if you generate images with text, you must specify which scripts are supported and which fonts are used. A system that generates invoice PDFs must ensure that the fonts it embeds support all characters in the target locale. A system that generates text for display in a fixed-width terminal must account for the fact that CJK characters typically occupy two columns while Latin characters occupy one.

## Handling Locale-Specific Regulatory and Ethical Constraints

Locale specifications must address regulatory and ethical constraints that vary by jurisdiction. These constraints affect what your system can say, what data it can process, and how it must disclose its AI nature.

**Age verification requirements** differ by jurisdiction. In the European Union, the GDPR imposes strict rules on processing data from children under sixteen. In the United States, COPPA applies to children under thirteen. In South Korea, different rules apply. If your system interacts with users who might be minors, your I/O spec must define locale-specific age verification and parental consent workflows, and must specify what content or features are restricted based on the user's age and jurisdiction.

**AI disclosure requirements** are emerging in multiple jurisdictions. The EU AI Act requires that users be informed when they are interacting with an AI system in certain contexts. California's AB 2013 requires disclosure for certain types of bots. Your I/O spec must define how this disclosure is made in each locale, what language is used, and where in the user interface it appears. This is not a one-time legal review. It is an operational requirement that must be tested and monitored.

**Content restrictions** vary widely. Germany prohibits Nazi symbols and Holocaust denial. France prohibits hate speech more broadly than the United States. China has extensive restrictions on political content. Saudi Arabia has religious content restrictions. If your system generates content that might touch these areas, your I/O spec must define locale-specific content filters and must specify whether certain features are disabled entirely in certain locales. This is not censorship. It is compliance with local law, and the alternative is being blocked or fined.

**Defamation and libel standards** vary by jurisdiction in ways that affect content generation tasks. The United States has strong First Amendment protections and a high bar for libel. The United Kingdom has stricter defamation laws. Your system's content generation policies must account for these differences, especially if you generate news summaries, social media content, or public-facing communications. The I/O spec should define whether the system applies the most restrictive standard globally or whether it tailors its content policies to each jurisdiction.

## Locale-Aware Error Handling and Logging

When your system encounters errors or logs events, locale affects how those errors and logs are formatted and stored. Your I/O spec must address locale in your error handling and observability infrastructure.

**Error messages to users** should be localized to match the user's locale. An error message in English presented to a Japanese user is worse than useless: it signals that the system is not designed for that user. Your spec must define the set of error messages that can be shown, the translations for each supported locale, and the fallback behavior when a translation is missing. Some teams use error codes plus locale-specific message templates. Others generate error messages dynamically, which requires the model to produce correctly localized text under error conditions.

**Log messages for operators** are typically in a single language, usually English, because your engineering and operations team may not be multilingual. But the log must still capture locale-related metadata so you can debug locale-specific issues. Your spec should define what locale information is logged with each event: the input locale, the output locale, the detected locale if different from the requested locale, and any locale-related warnings or fallbacks that were triggered. This metadata is essential for diagnosing locale bugs and for monitoring the health of your localization infrastructure.

**Locale-specific failure modes** should be monitored separately. If your error rate is 2% overall but 15% for Japanese inputs, you have a locale-specific problem that will be masked by the overall metric. Your observability spec should define how metrics are sliced by locale and what alerts fire when locale-specific error rates exceed thresholds. This is not optional. Locale bugs are often silent: the system produces output, but the output is wrong in ways that only native speakers notice.

## The Localization Testing Matrix

Locale testing is not a one-time validation before launch. It is an ongoing discipline that must be built into your evaluation pipeline. Your I/O spec should reference a localization testing matrix that defines what is tested, how often, and by whom.

**Format testing** is fully automatable. You can write deterministic checks that validate date formats, number formats, currency displays, and character encoding for every supported locale. These checks should run on every build and should block deployment if any format violations are detected. A single date in the wrong format is a critical bug, not a tolerable imperfection.

**Translation accuracy testing** requires human review by native speakers. You cannot rely on automated translation quality metrics like BLEU or COMET for production evaluation because they do not capture tone, formality, or domain appropriateness. Your testing matrix should define how many outputs per locale are reviewed by humans each week or month, who the reviewers are, and what rubric they use. This is ongoing QA, not a one-time launch checklist.

**Cultural appropriateness testing** requires reviewers with cultural context, not just language fluency. A native speaker who grew up in the target culture can identify when tone is wrong, when examples are culturally inappropriate, or when generated content includes references that do not resonate. Your testing matrix should include cultural review for any content that is user-facing or public-facing, especially when you launch in a new market.

**Regulatory compliance testing** requires legal review for each jurisdiction. Your legal team or external counsel should review your system's outputs in each locale to ensure compliance with local content regulations, data protection laws, and AI disclosure requirements. This review should happen before launch and should be repeated whenever regulations change or whenever your system's capabilities change in ways that might affect compliance.

## The Multi-Locale Roadmap Strategy

Most teams cannot support every locale on day one. Your I/O spec should be paired with a multi-locale roadmap that defines which locales are supported when, what level of support each locale receives, and how you sequence locale expansion to derisk your effort.

**Tier 1 locales** receive full support: native-language prompts, professional translation, cultural review, full format compliance, and dedicated QA. These are your core markets where you have significant user bases or revenue. You allocate the resources to do localization correctly because the market justifies the investment.

**Tier 2 locales** receive partial support: English prompts with localized output, machine translation with spot-checking, automated format compliance, and sampled QA. These are markets where you have users but not enough to justify full localization investment. You provide a functional experience but you disclose the limitations.

**Tier 3 locales** receive minimal support: English prompts, best-effort localization, fallback to a closely related locale, and reactive bug fixing. These are exploratory markets where you are testing demand. You serve these users but you do not invest heavily until usage justifies it.

Your roadmap defines how locales are promoted from Tier 3 to Tier 2 to Tier 1 based on metrics like user count, revenue, error rates, and strategic importance. This prevents you from over-investing in locales that do not have product-market fit while ensuring that you can scale up quickly when a market takes off.

You now have a complete I/O specification framework that covers inputs, outputs, edge cases, uncertainty, tool contracts, and locale requirements. The next step is to package everything from your problem framing work into artifacts that your evaluation and engineering teams can actually use. That is the framing-to-evaluation handoff, covered in Chapter 6.
