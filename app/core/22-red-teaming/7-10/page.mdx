# 7.10 — Recursive Loop Attacks: Infinite Agent Chains

Why do most recursive loop attacks succeed? Because the team that designed the system never asked what happens when an agent calls itself, a tool triggers another tool, or a workflow enters an infinite state. In January 2026, a workflow automation agent entered a recursive loop that ran for 19 hours before manual intervention. The trigger: a user asked the agent to "monitor this document and notify me whenever it changes, then update the monitoring rules based on the notification." The agent interpreted this as: watch the document, detect a change, send a notification, update the rules based on the notification content, which caused the rules to change, which triggered the change detector, which sent another notification, which updated the rules, which triggered the detector again. The loop executed 67,000 iterations, sent 67,000 notifications, consumed 340 million tokens, and cost $41,000 before an engineer manually killed the process.

Recursive loops are not edge cases. They are predictable failures in systems that allow feedback cycles without bounds. And they are devastatingly effective attack vectors.

## How Recursive Loops Form

A recursive loop occurs when an action triggers a condition that causes the same action to execute again. In traditional software, recursion without a base case causes stack overflow. In AI systems, recursion without termination causes infinite model calls, infinite tool executions, infinite API requests, and unbounded costs.

The simplest form: an agent that can invoke itself. You build a meta-agent that selects which specialized agent to call based on the query. One of the options is "delegate to the meta-agent for complex multi-step reasoning." A user asks a genuinely complex question. The meta-agent decides the question is too complex for any specialized agent and delegates to itself. Which evaluates the question again. Which delegates to itself. Which evaluates the question again. Infinite loop.

The tool-based form: an agent has access to a scheduling tool and a task-creation tool. A user asks the agent to "schedule a daily task that creates a new task each time it runs." The agent creates a task that, when executed, creates another task, which creates another task, which creates another task. Exponential growth. Within 6 hours, the system has 130,000 queued tasks, all creating more tasks.

The memory-based form: an agent that stores every interaction in memory and retrieves all past interactions to inform the next response. Each interaction adds to memory. Each retrieval pulls the entire history. The history grows. Retrieval becomes slower and more expensive. The context window fills. The system begins summarizing the history, which it stores in memory, which it retrieves on the next interaction, which now includes the summary, which it summarizes again, which it stores. Memory grows without bound.

The multi-agent form: Agent A calls Agent B when it needs external data. Agent B calls Agent C to validate the data. Agent C calls Agent A to check context. Agent A calls Agent B. Loop.

## Agent-Spawning-Agent Attacks

The most dangerous recursive attack is the agent that spawns other agents. In systems where agents can dynamically create sub-agents to parallelize work, an attacker can craft prompts that trigger exponential agent creation.

A research agent can spawn sub-agents to search different databases in parallel. The attacker asks: "Research this topic by creating a sub-agent for every possible keyword variation and every possible database." The agent interprets this as spawning 4,000 sub-agents. Each sub-agent can spawn sub-agents. Within minutes, the system has created 280,000 agent instances, each consuming memory and making model calls.

A planning agent can create sub-agents to handle subtasks. The attacker asks: "Break this task into as many subtasks as possible, and for each subtask, create a sub-agent that further breaks it into subtasks." The agent creates 50 sub-agents. Each creates 50 more. Within 4 iterations, the system has 6.25 million queued agent tasks.

Defense requires hard limits on agent creation depth and breadth. No agent should be able to spawn more than 10 sub-agents per invocation. No agent should be able to spawn sub-agents more than 3 levels deep. No system should allow more than 100 active agent instances per user at any given time. When these limits are hit, fail gracefully. Do not silently ignore the request. Return an error: "Agent creation limit reached. Simplify your task or contact support."

Implement circuit breakers at the agent orchestration layer. If the number of active agents doubles in under 60 seconds, halt agent creation and alert. If the agent creation rate exceeds 50 agents per minute, halt and alert. If an agent has spawned more than 20 sub-agents in the last 10 minutes, flag it for review.

## Tool-Triggering-Tool Loops

Tools that trigger other tools create feedback cycles. A notification tool can trigger a logging tool. A logging tool can trigger an audit tool. An audit tool can trigger a notification tool. If the conditions are right, this becomes a loop.

In November 2025, a compliance monitoring agent entered a tool loop that executed for 14 hours. The system had three tools: a document scanner that detected policy changes, a notification tool that alerted compliance officers, and an audit logger that recorded all notifications. The audit logger was configured to notify compliance when more than 100 audit events occurred in an hour. The document scanner detected a policy change, which triggered a notification, which triggered an audit log, which triggered another notification because the audit count exceeded 100, which triggered another audit log, which triggered another notification. The loop executed 51,000 times before detection.

Defense requires breaking feedback cycles at the design level. No tool should trigger another tool that can trigger the original tool. If Tool A can call Tool B, and Tool B can call Tool C, then Tool C must not be able to call Tool A. Enforce this with a directed acyclic graph at the tool registry level. When registering a new tool, validate that its dependencies do not create cycles.

Implement per-tool execution limits. No tool should execute more than 100 times in a 10-minute window for a single user. When a tool hits this limit, pause execution and require human confirmation to continue. Monitor tool execution patterns. If a tool that normally executes 5 times per day suddenly executes 800 times in an hour, something is wrong. Halt execution and investigate.

## Self-Referential Prompt Injection

The most subtle recursive attack is the prompt that references itself or its own output in a way that causes the model to re-evaluate indefinitely. A summarization agent is asked: "Summarize this text, then summarize the summary, then summarize that summary, and continue until the summary is a single sentence." The agent generates a summary, then summarizes the summary, then summarizes that summary. Depending on the implementation, this either terminates naturally when the summary becomes short enough, or it loops indefinitely because the stopping condition is never met.

A translation agent is given: "Translate this text to French, then translate the French back to English, then translate the English to French again, and repeat until the translation stabilizes." The agent translates, back-translates, translates again. The text never stabilizes because translation is lossy. The loop continues indefinitely.

A research agent is prompted: "Find sources that support this claim, then find sources that critique those sources, then find sources that critique the critiques, and continue for 10 levels." The agent retrieves sources, then retrieves critiques, then retrieves critiques of critiques. Exponential growth in retrieval operations.

Defense requires detecting self-referential patterns in prompts. If a prompt contains instructions to repeat an operation on the output of that operation, flag it. If a prompt contains phrases like "continue until," "repeat indefinitely," "keep going until stable," or "iterate 100 times," apply strict iteration limits. Never allow unbounded iteration. Cap all loops at 10 iterations maximum.

Implement output comparison checks. If an agent generates output, then performs an operation on that output, compare the new output to the previous output. If they are identical for 3 consecutive iterations, terminate. The loop has converged. If they are different after 10 iterations, terminate anyway. The loop is not converging.

## Memory-Filling Loops

Memory systems are particularly vulnerable to recursive growth. An agent that stores every interaction in memory and retrieves all of memory on each interaction creates a positive feedback loop: more interactions mean larger memory, larger memory means slower retrieval, slower retrieval means more memory operations, more memory operations mean larger memory.

A customer support agent stores conversation history, tool calls, and retrieved documents in memory. After 50 interactions, memory contains 120,000 tokens. Every new interaction retrieves all 120,000 tokens, processes them, adds another 3,000 tokens to memory, then stores the expanded memory. Memory grows to 180,000 tokens. Then 250,000 tokens. Then 340,000 tokens. Retrieval cost increases quadratically. The system becomes unusable.

A research agent stores every query, every retrieved document, and every generated summary in memory. A user runs 200 queries over 3 days. Memory contains 2.4 million tokens. Every new query retrieves all 2.4 million tokens to maintain context. Retrieval cost is $4.80 per query. The agent is economically broken.

Defense requires memory pruning strategies. Do not store unlimited history. After 20 interactions, summarize the first 10 interactions into 2,000 tokens and drop the original turns. After 50 interactions, summarize the first 40 into 5,000 tokens. Memory should grow logarithmically, not linearly.

Implement memory size limits. Free users: 50,000 tokens of memory. Paid users: 200,000 tokens. Enterprise users: 1 million tokens. When memory exceeds the limit, automatically prune the oldest or least relevant content. Use relevance scoring to retain important context and drop noise.

## Detecting Loop Formation

Recursive loops are easier to prevent than to detect after formation. But detection is critical because prevention is never perfect. Monitor for loop signatures:

**Repeated identical operations**: If the same tool is called with the same parameters 10 times in 60 seconds, flag it. If the same model call with the same input is made 5 times in a row, flag it. Legitimate use rarely repeats identical operations.

**Exponential growth in operations**: If the operation count doubles every minute, you have exponential growth, which almost always indicates a recursive loop. Halt execution when operation count exceeds 10x the user's historical average.

**Cyclic call patterns**: Agent A calls Agent B calls Agent C calls Agent A. This is a cycle. Detect cycles by maintaining a call stack per user session. If the call stack contains the same agent or tool twice, you have a cycle. Break it.

**Unbounded memory growth**: If memory size increases by more than 50,000 tokens in 10 minutes, flag it. Legitimate interactions do not cause that rate of memory growth.

**Cost velocity spikes**: If a user's cost-per-minute rate suddenly increases 20x, flag it. Recursive loops cause extreme cost acceleration.

## Circuit Breakers and Limits

Circuit breakers are the last line of defense. When all else fails, the circuit breaker halts execution before the loop destroys your budget. Implement circuit breakers at multiple levels:

**Per-operation circuit breakers**: No single operation should execute more than 100 times in a 10-minute window per user. When this limit is hit, halt the operation and return an error.

**Per-user circuit breakers**: No user should trigger more than 1,000 model calls in an hour, create more than 50 agent instances in a session, or execute more than 500 tool calls in a day. When these limits are hit, disable the user's access and require manual review.

**System-wide circuit breakers**: If total system cost increases by more than 5x the hourly average, halt all non-critical operations and alert engineering. If total active agents exceed 10,000, halt agent creation system-wide.

**Time-based circuit breakers**: No operation should run for more than 10 minutes without checkpointing progress. No session should remain active for more than 6 hours without user interaction. No background task should run for more than 24 hours without manual confirmation.

Circuit breakers are not punishment. They are safety mechanisms. When a circuit breaker trips, log the event, notify the user, and provide clear guidance on what happened and how to avoid it. A well-designed circuit breaker prevents a $50,000 recursive loop and loses zero legitimate users.

## Defense Through Bounded Execution

The fundamental defense against recursive loops is bounded execution: every operation has a maximum depth, a maximum breadth, a maximum iteration count, and a maximum runtime. No operation is unbounded.

Agent calls are bounded at 3 levels of nesting. Tool calls are bounded at 100 per session. Memory growth is bounded at 1 million tokens. Iteration is bounded at 10 cycles. Runtime is bounded at 10 minutes. When any bound is reached, execution halts gracefully with a clear error message.

These bounds are not arbitrary. They are derived from observing legitimate usage patterns and setting limits at the 99.9th percentile. Legitimate users almost never need to nest agents 4 levels deep. Legitimate users almost never call a tool 150 times in a session. When usage exceeds these bounds, it is either a bug in user code or a deliberate attack. Either way, halting execution protects the system.

Recursive loops succeed when systems allow unbounded feedback cycles. They fail when every cycle has a break condition, every operation has a limit, and every anomaly triggers a circuit breaker. The attacker cannot force your agent to spawn infinite sub-agents if you cap agent creation at 10 per invocation. They cannot create infinite tool loops if you enforce acyclic dependencies. They cannot fill memory indefinitely if you prune aggressively.

Recursion is powerful. Unbounded recursion is catastrophic. The difference is a set of hard limits and the discipline to enforce them.

---

The final piece of tool abuse defense is systematic testing — red team approaches that find tool vulnerabilities before attackers do.
