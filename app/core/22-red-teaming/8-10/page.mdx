# 8.10 — Agent Sandboxing and Kill Switches

Why do most agent deployments lack kill switches? Because the team believes their containment will never fail. They have spent weeks building permission models, testing boundary enforcement, and validating scope restrictions. The agent works correctly in testing. The team ships it to production with monitoring and logging. They do not build the mechanism to stop it immediately if something goes wrong. When the agent begins executing unintended actions at scale, the team has no emergency brake. They watch the damage accumulate while they debug the root cause.

A kill switch is not a failure admission. It is a recognition that complex autonomous systems fail in unexpected ways. When failure happens, speed matters. The difference between stopping an agent in thirty seconds versus thirty minutes is the difference between contained incident and company-wide crisis.

## The Sandboxing Principle for Agents

Sandboxing isolates the agent from the rest of the infrastructure. The agent runs in a restricted environment where damage is contained. If the agent misbehaves, the sandbox limits the blast radius. Filesystem access is restricted to a temporary directory. Network access is restricted to specific endpoints. Resource consumption is capped. The agent cannot affect systems outside the sandbox.

Sandboxing for agents is more complex than sandboxing for applications. Agents require access to external systems to perform their tasks. A customer support agent must query databases and send emails. A deployment agent must interact with CI/CD infrastructure. Complete isolation defeats the agent's purpose. The sandbox must allow necessary interactions while preventing unauthorized ones.

The principle is least-privilege isolation. The agent has access to exactly the resources required for its defined tasks and no others. Access is granted through explicitly configured interfaces. Everything else is blocked. If the agent attempts to access a resource outside the sandbox, the attempt fails at the infrastructure level.

You verify sandboxing by running the agent in the sandbox and confirming that it can perform its intended tasks and cannot perform prohibited actions. The agent should successfully complete legitimate work and fail when attempting out-of-bounds operations. If legitimate work fails, the sandbox is too restrictive. If prohibited actions succeed, the sandbox is too permissive.

## Process and Container Isolation

Process isolation runs the agent in a separate operating system process with restricted permissions. The process cannot access files outside its working directory, cannot open network connections to unauthorized hosts, and cannot execute arbitrary system commands. Process-level permissions enforce the boundary.

Container isolation runs the agent inside a container with a minimal runtime environment. The container includes only the dependencies the agent needs. The filesystem is read-only except for a designated workspace. Network access is controlled through container networking policies. Resource limits prevent the agent from consuming excessive CPU, memory, or disk.

A financial automation agent in late 2025 ran in a container with read-only access to application binaries and read-write access to a temporary workspace. During testing, the agent attempted to modify system configuration files as part of a prompt injection attack. The container's read-only filesystem blocked the write. The agent's malicious action failed before it could affect the host system.

Container isolation provides defense in depth. The agent's logic might fail to prevent a prohibited action. The container's restrictions prevent the action from succeeding. Each layer compensates for failures in the other.

You test process and container isolation by attempting to break out of the isolation boundary. You instruct the agent to access the host filesystem, modify system settings, or execute privileged commands. Each attempt should fail with a permission error. Logs should capture the attempt. If any attempt succeeds, the isolation is insufficient.

## Network Sandboxing

Network sandboxing restricts the agent's network access to specific endpoints. The agent can reach internal services required for its tasks. It cannot reach arbitrary internal systems or external websites. Network policies enforce the restriction at the infrastructure level.

An agent that processes customer feedback needs to read from a feedback database and write to an analytics system. It does not need access to payment systems, authentication services, or external APIs. Network sandboxing allows connections to the feedback database and analytics system. All other network access is blocked.

Network sandboxing is implemented through firewall rules, network segmentation, or service mesh policies. The agent runs in a network zone with restricted egress. Allowed endpoints are whitelisted. Everything else is denied by default.

Testing network sandboxing involves instructing the agent to connect to prohibited endpoints and verifying that the connections are blocked. You provide tasks that require fetching data from unauthorized APIs, sending data to external systems, or scanning internal networks. Each connection attempt should fail at the network layer.

A sophisticated attack attempts to proxy through allowed endpoints. The agent can reach the analytics system. The attacker manipulates the agent into sending requests to the analytics system that the analytics system then forwards to prohibited destinations. Network sandboxing alone does not stop this. You need endpoint validation — the analytics system must validate requests and refuse to act as a proxy.

## Kill Switch Design Patterns

A kill switch is the mechanism that immediately stops an agent when triggered. The agent stops processing tasks, stops executing actions, and enters a safe state. Kill switches operate at multiple levels — application-level, infrastructure-level, and manual.

Application-level kill switches are controlled by the agent's runtime. The runtime monitors a kill switch flag. When the flag is set, the runtime halts the agent's execution loop, cancels in-progress tasks, and shuts down gracefully. The kill switch can be triggered by monitoring systems that detect anomalous behavior or by operators through a control interface.

Infrastructure-level kill switches terminate the agent's process or container immediately. The container orchestration system receives a kill command and forcibly stops the agent. In-progress actions are interrupted. The agent does not have an opportunity to complete cleanup. Infrastructure kill switches are the failsafe when application-level kill switches do not respond.

Manual kill switches are operator-controlled. A button, command, or API call allows a human to immediately stop the agent. Manual kill switches are the last resort when automated detection fails or when an operator observes dangerous behavior that automated systems have not detected.

A deployment agent in mid-2025 included both automated and manual kill switches. The automated kill switch monitored for deployment failures, permission errors, and unexpected resource access. If the agent triggered three permission errors in sixty seconds, the kill switch activated and halted execution. The manual kill switch allowed the on-call engineer to stop the agent instantly if they observed unexpected behavior during deployment.

Kill switches must be tested. You verify that triggering the kill switch actually stops the agent, that in-progress actions are safely terminated, and that the agent does not resume execution until explicitly re-enabled. Kill switches that fail when needed are worse than no kill switch — they create false confidence.

## Manual vs Automatic Termination

Manual termination requires human judgment. An operator observes agent behavior, determines that it is dangerous or incorrect, and triggers the kill switch. Manual termination is reliable when the operator is watching and has clear criteria for when to intervene. It fails when the agent operates autonomously for hours without supervision or when the operator lacks the context to recognize dangerous behavior.

Automatic termination relies on monitoring and detection rules. The system observes agent behavior, compares it to expected patterns, and triggers the kill switch when anomalies cross a threshold. Automatic termination responds faster than humans. It works without supervision. It fails when the detection rules do not cover the failure mode or when false positives cause unnecessary termination.

The correct approach is both. Automatic termination handles detectable failure modes quickly. Manual termination handles unexpected failures that automated systems miss. The agent includes instrumentation that allows operators to observe behavior in real-time and trigger termination if needed.

You test automatic termination by simulating failure conditions and verifying that the kill switch activates within the expected time window. You test manual termination by verifying that operators can trigger the kill switch through the control interface and that the agent stops immediately.

Termination must be reversible. After stopping the agent, you need the ability to investigate the cause, fix the issue, and re-enable the agent safely. Kill switches that require full redeployment to recover create operational friction that discourages their use.

## Testing Kill Switch Reliability

Kill switch reliability means the kill switch works every time it is triggered. A kill switch that works 95% of the time is a failure. When you need to stop a runaway agent, you need certainty.

Testing kill switch reliability involves triggering the kill switch under various conditions and verifying that the agent stops. You test during normal operation, during high load, during network partitions, and during partial system failures. The kill switch must work in every scenario.

A customer service agent in early 2026 had a kill switch that depended on a centralized control service. During testing, the network link to the control service failed. The agent continued executing because it could not reach the control service to check the kill switch status. The kill switch design failed under network partition.

Reliable kill switches use local state. The kill switch flag is stored locally and checked on every execution loop. Remote systems can set the flag, but the agent checks the local copy. If the network fails, the agent can still be stopped by setting the local flag through the container orchestration system or operating system signals.

You test kill switch reliability by introducing failure conditions and verifying that the kill switch still works. Network failures, disk failures, high CPU load, memory pressure. The kill switch must function regardless of system state.

## Recovery After Termination

Stopping the agent is the first step. Recovery is the second. After termination, you need to understand what the agent did, assess the damage, and determine whether it is safe to resume.

Recovery begins with forensics. Logs capture every action the agent took before termination. You review the logs to understand what triggered the kill switch and what actions the agent executed. If the agent accessed unauthorized resources, you determine what data was exposed. If the agent performed unauthorized actions, you assess whether those actions need to be reversed.

A financial agent terminated after attempting to access prohibited transaction records. Recovery involved reviewing access logs to confirm that the access was blocked, verifying that no data was exfiltrated, and analyzing the task context to understand why the agent attempted the access. The root cause was a prompt injection attack. The fix was improved input validation. The agent was re-enabled after the fix was deployed and tested.

Recovery also involves cleanup. If the agent wrote temporary files, those files are deleted. If the agent created partial state, that state is rolled back. The agent's workspace is reset to a clean state before resuming.

You test recovery by terminating the agent mid-task and verifying that you can analyze the logs, assess the actions, and safely resume or redeploy. Recovery procedures must be documented and tested regularly. An incident is not the time to figure out how recovery works.

## Building Reliable Emergency Stops

Reliable emergency stops require three components: fast detection, reliable termination, and clear recovery procedures. Detection identifies when the agent needs to be stopped. Termination stops it. Recovery determines what happens next.

Detection comes from monitoring, logging, and alerting. You monitor for boundary violations, permission errors, unexpected resource access, and task execution patterns that deviate from normal behavior. When detection triggers, the kill switch activates.

Termination must be local, fast, and definitive. The agent checks a local kill switch flag on every execution loop. Setting the flag stops the agent within seconds. Infrastructure-level termination provides backup if the application-level kill switch fails.

Recovery procedures are documented, tested, and accessible to on-call engineers. The procedures describe how to analyze the incident, assess the damage, determine root cause, and safely re-enable the agent. Recovery is not automatic. It requires human judgment.

You test the full emergency stop system by simulating agent failures and executing the detection, termination, and recovery workflow. The test measures time-to-stop, completeness of forensic data, and time-to-recovery. Each test identifies gaps in procedures, instrumentation, or automation.

Emergency stops are your last line of defense when containment fails and the agent begins executing harmful actions. The next challenge is what happens after the stop — understanding what the agent did and recovering from the incident.
