# Chapter 7 — Tool and Function Calling Architecture

Tools are how models act on the world. Poorly designed tools create chaos: hallucinated parameters, credential leaks, non-idempotent side effects, cascading retries. Good tool architecture defines schemas rigorously, enforces least privilege, and makes every call observable.

---

## What This Chapter Covers

- **7.1** — Tool Calling Fundamentals: Schema, Invocation, and Response
- **7.2** — Tool Schema Design: Names, Descriptions, and Parameter Types
- **7.3** — Tool Selection: How Models Choose Which Tool to Call
- **7.4** — Multi-Tool Orchestration and Sequential Tool Chains
- **7.5** — Parallel Tool Calling: When and How
- **7.6** — Tool Error Handling and Retry Patterns
- **7.7** — Tool Timeouts, Rate Limits, and Circuit Breakers
- **7.8** — Tool Authorization and Permission Models
- **7.9** — Tool Result Interpretation and Grounding
- **7.10** — Tool Hallucination: When Models Invent Tools or Parameters
- **7.11** — Tool Versioning and Backward Compatibility
- **7.12** — Tool Testing: Unit, Integration, and End-to-End
- **7.13** — Custom Tool Design for Domain-Specific APIs
- **7.14** — MCP (Model Context Protocol) and Tool Interoperability Standards
- **7.15** — Tool Observability: Logging, Tracing, and Debugging Tool Calls
- **7.16** — Tool Performance Optimization: Latency, Cost, and Caching
- **7.17** — Tool Governance: Approval, Review, and Compliance
- **7.18** — Idempotency Keys and Exactly-Once-ish Patterns
- **7.19** — Tool Side Effects: Transactional vs Non-Transactional Tools
- **7.20** — Secrets Handling: Never in Prompts, Vault Patterns, Scoped Tokens
- **7.21** — Sandboxing Tools and Data Minimization: Least Data, Least Privilege

---

*Tools are capabilities — design them like you'd design an API.*
