# 8.5 — Markdown and Rich Text Output Control

In April 2025, a technical documentation platform discovered that 30 percent of their AI-generated documentation required manual reformatting before publication. The AI wrote good content—accurate, clear, comprehensive—but the structure was inconsistent. Sometimes it used H2 headings for major sections, sometimes H3. Sometimes it formatted code blocks with language tags, sometimes without. Sometimes it used numbered lists, sometimes bullets, sometimes plain paragraphs with manual numbering. The documentation team spent hours reformatting outputs to match their style guide before publishing. The problem wasn't content quality—it was that the company had focused on getting the AI to generate correct information but hadn't invested in controlling output structure and formatting. After implementing strict markdown formatting rules in prompts and building post-processing validators that enforced style guide compliance, manual reformatting requirements dropped to 5 percent, and publishing velocity increased by 40 percent.

**Markdown control** matters when outputs are consumed by humans or rendered into documentation systems. Language models generate markdown fluently, but without explicit guidance, the formatting is inconsistent and often doesn't match organizational style guides or downstream rendering requirements. Production systems need to control heading hierarchies, list formatting, code block syntax, link styles, and emphasis patterns to produce outputs that are ready for publication without manual editing.

## Why Markdown Formatting Matters

Markdown is the standard format for technical documentation, README files, knowledge bases, blog posts, and conversational AI outputs. It's human-readable as plain text and renders cleanly to HTML. But markdown has flexibility that becomes a liability when you need consistency.

**Heading structure** affects document navigation, SEO, and accessibility. HTML heading tags (H1 through H6) create document outlines that screen readers use for navigation and search engines use for understanding content hierarchy. If your AI inconsistently uses H2 for some major sections and H3 for others, the document outline becomes incoherent. Users and systems that navigate by headings get confused.

**List formatting** affects readability and parseability. Numbered lists imply sequence or priority. Bullet lists imply equal-weight items. If the AI mixes list types arbitrarily or uses manual numbering instead of markdown's automatic numbering, readers struggle to understand structure, and downstream parsers that extract list items fail.

**Code block formatting** affects syntax highlighting and copyability. Fenced code blocks with language tags enable syntax highlighting in renderers. Code blocks without language tags render as plain text. Inline code versus block code distinguish short snippets from complete examples. Inconsistent code formatting degrades developer documentation quality.

**Link handling** affects reliability and user experience. Markdown supports reference links and inline links. Reference links separate link definitions from content, improving readability for long documents. Inline links keep URLs visible in plain text. If your AI mixes styles or generates malformed links (missing closing brackets, unescaped special characters), links break in rendered output.

**Emphasis patterns** use asterisks or underscores for italics and bold. Mixing conventions within a document looks sloppy. Overusing bold or italics for emphasis reduces its effectiveness. Underusing emphasis makes text monotonous. Consistent emphasis patterns improve readability.

## Prompting for Structured Markdown

The most effective markdown control happens at prompt time, specifying exactly how you want output formatted.

**Heading hierarchy specification** removes ambiguity. "Use H2 (##) for major sections, H3 (###) for subsections, H4 (####) for sub-subsections. Never skip heading levels. Never use H1, as that's reserved for the document title." This creates predictable structure that downstream processors can parse reliably.

For different use cases, heading levels might start at different points. If you're generating content that will be inserted into an existing document structure, you might say "Start with H3 headings for major sections" because H1 and H2 are already used by the parent document.

**List type specification** clarifies when to use bullets versus numbers. "Use numbered lists for sequential steps or ranked items. Use bullet lists for unordered collections. Use task lists (- [ ]) for actionable items. Never use manual numbering (typing '1.' instead of markdown's automatic numbering)."

**Code block requirements** enforce syntax highlighting and readability. "Wrap code in fenced code blocks using triple backticks. Always specify the language after the opening backticks (```python, ```javascript, ```bash). Use inline code (single backticks) for short snippets within sentences. Never use indentation-based code blocks."

**Link style consistency** chooses inline or reference links based on use case. "Use inline links [text](url) for all hyperlinks. Keep URLs clean and avoid encoded characters where possible." Or for long documents: "Use reference-style links [text][ref] with link definitions at the end of each section. This keeps the content readable in plain text."

**Emphasis guidelines** control bold and italic usage. "Use bold (**text**) for important terms on first use. Use italics (*text*) for emphasis within sentences. Never use both bold and italic on the same text. Never use underscores for emphasis; always use asterisks."

**Escape character handling** prevents markdown interpretation errors. "Escape special characters that shouldn't be interpreted as markdown: {"<"} less-than should be written as \{"<"} or {"<"} in contexts where it might be interpreted as HTML. Escape asterisks, underscores, and brackets when you want them literal, not formatting."

## Markdown Post-Processing Validation

Even with careful prompting, models sometimes generate non-compliant markdown. Post-processing validation catches and fixes errors.

**Heading validation** checks that heading hierarchies are correct. Scan for heading levels (count the # characters). Verify that headings don't skip levels (H2 directly to H4). Verify that heading levels increase by at most one (H2 to H3 is valid, H2 to H4 is invalid). Flag violations for fixing.

**List consistency checking** verifies that list items within a list use consistent markers. All items in a numbered list should use markdown's automatic numbering, not manual "1.", "2.", "3.". All items in a bullet list should use the same bullet character (-, *, or +, but not mixed).

**Code block syntax validation** confirms all code blocks use fenced syntax with language tags. Parse the markdown AST (abstract syntax tree), find code block nodes, verify they have language annotations. Flag code blocks without language tags or using indentation-based syntax for correction.

**Link integrity checking** parses links and verifies they're well-formed. Check that opening brackets [ have closing brackets ], that opening parentheses ( have closing parentheses ), that reference links have corresponding definitions. Optionally verify that URLs are valid (well-formed, accessible) though this adds latency.

**Emphasis balance checking** ensures bold and italic markers are properly paired. Each opening ** or * should have a closing ** or *. Unbalanced emphasis markers break markdown rendering. This can be validated with regex or AST parsing.

Validation should produce specific error reports: "Line 42: heading skips from H2 to H4", "Line 67: code block missing language tag", "Line 89: unbalanced bold marker". These reports enable targeted fixing rather than full regeneration.

## Automatic Markdown Repair

When validation finds errors, automatic repair fixes common issues without regenerating.

**Heading level normalization** adjusts invalid hierarchies. If a heading skips from H2 to H4, downgrade the H4 to H3. If a document starts with H3, consider promoting it to H2 or prepending a H2 section header. Heading repair requires understanding document semantics, so it's heuristic.

**List marker standardization** converts inconsistent list syntax to a canonical form. If a list mixes - and * bullets, convert all to -. If a list uses manual numbering, convert to markdown's automatic numbering. If a list has inconsistent indentation, normalize it.

**Code block standardization** converts indentation-based code blocks to fenced blocks. If language can't be inferred, use a generic ```text tag. Detect language from file extensions or context ("Here's the Python code:" followed by a code block implies ```python).

**Link repair** fixes common malformations. If a link is missing closing brackets or parentheses, add them. If a reference link definition is missing, either add a placeholder or convert to inline link. If URLs contain spaces, percent-encode them.

**Emphasis repair** balances unmatched markers. If there's an opening ** without a closing **, either add the closing marker at an appropriate point or remove the opening marker. This is heuristic and can change meaning, so conservative repair (removing rather than guessing where to close) is safer.

Automatic repair should be conservative. Only fix clear errors where the intended output is unambiguous. For ambiguous cases, flag for manual review or regenerate.

## Controlling Output Length and Structure

Markdown generation can run long or get off-topic. Length and structure controls keep outputs focused.

**Section length limits** constrain verbosity. "Each H2 section should be 200-400 words. Each H3 subsection should be 100-200 words. Aim for conciseness without sacrificing clarity." This prevents the model from generating excessively long sections that readers won't engage with.

**Heading count constraints** limit document complexity. "Use no more than 5 H2 sections. Each H2 section should have no more than 4 H3 subsections." This creates predictable document structures that fit UI layouts and reader attention spans.

**Content exclusions** prevent unwanted sections. "Do not include a 'Conclusion' section. Do not include a 'References' section unless specifically requested. Do not include placeholder sections like 'Coming soon' or 'To be determined'." This avoids boilerplate that adds no value.

**Style guide compliance** encodes organizational standards. "Follow the Microsoft Writing Style Guide: use sentence case for headings, use second person ('you' rather than 'one'), prefer active voice, avoid jargon." This ensures outputs match organizational voice and tone.

## Markdown for Different Consumers

Different systems that consume markdown have different requirements and constraints.

**GitHub-flavored markdown** adds extensions: task lists, tables, strikethrough, syntax-highlighted code blocks, auto-linked URLs. If you're generating README files or GitHub documentation, specify "Generate GitHub-flavored markdown. Use task lists (- [ ] item) for checklists. Use tables (| header |) for tabular data. Use ~~strikethrough~~ for deprecated information."

**CommonMark** is the standardized markdown spec without extensions. If your output needs to be portable across systems, specify "Generate CommonMark-compliant markdown. Do not use extensions like tables or task lists. Stick to headings, lists, code blocks, links, and emphasis."

**Platform-specific renderers** like Notion, Confluence, or Slack have markdown variants with quirks. Notion supports block-level equation rendering. Confluence uses wiki markup that's markdown-like but different. Slack's mrkdwn is a simplified subset. Research target platform requirements and specify accordingly.

**Static site generators** like Jekyll, Hugo, or Next.js often expect markdown with frontmatter (YAML metadata at the top of the file). If generating blog posts or documentation for SSGs, specify "Include YAML frontmatter with title, date, author, and tags. Separate frontmatter from content with --- delimiters."

## Stripping and Converting Formatting

Sometimes you need to remove or transform markdown for different contexts.

**Markdown to plain text** strips all formatting for use in systems that don't support markdown. Remove heading markers (##), convert lists to plain lines with dashes or numbers, remove emphasis markers (**), convert links to just their URL or just their text depending on context. Libraries like remark and unified provide markdown parsing and transformation.

**Markdown to HTML** renders markdown for web display. Most markdown parsers output HTML. Ensure the parser's configuration matches your security and styling requirements: sanitize HTML to prevent XSS if rendering user-generated content, add CSS classes for styling, configure syntax highlighting libraries for code blocks.

**Markdown to PDF** or other formats typically goes through HTML as an intermediate. Generate HTML from markdown, then use a rendering engine like Puppeteer or Playwright to generate PDF. This requires controlling HTML styling to ensure PDFs are formatted correctly.

**Rich text to markdown** converts formatted text from word processors or rich text editors to markdown. Libraries like turndown (JavaScript) and html2text (Python) convert HTML to markdown. This is useful when humans edit AI outputs in WYSIWYG editors and you need to store or version control the results as markdown.

Format conversion introduces edge cases: nested lists, tables (if using extended markdown), inline HTML, images. Test conversion pipelines with realistic examples to catch issues.

## Testing Markdown Quality

Markdown outputs need quality testing beyond content correctness.

**Rendering tests** verify markdown renders correctly in target systems. Render the markdown to HTML and inspect the output. Check that headings create the correct hierarchy ({"<"}h2{">"}, {"<"}h3{">"}, etc.), that lists render as expected ({"<"}ol{">"}, {"<"}ul{">"}), that code blocks have syntax highlighting, that links are clickable.

**Structure validation** uses markdown AST parsing to verify structure programmatically. Parse markdown with a library like remark (JavaScript) or mistune (Python), inspect the AST, verify heading levels, list types, code block languages. This catches structural errors without requiring full rendering.

**Style guide compliance tests** check formatting against organizational rules. If headings should be sentence case, verify capitalization. If lists should use specific bullet characters, verify consistency. If code blocks should always have language tags, verify all blocks comply. Automated style checkers like markdownlint (configurable rule-based linting) enforce style consistency.

**Readability scoring** uses metrics like Flesch-Kincaid or Gunning Fog to assess text complexity. While this measures content more than formatting, it's relevant for markdown outputs intended for broad audiences. If readability scores are too high (text too complex), revise prompts to request simpler language.

**Cross-platform rendering tests** verify markdown renders consistently across target platforms. If you're generating markdown for both web and mobile, test rendering on both. If markdown will be viewed in different tools (GitHub, Notion, VS Code), verify it renders correctly in each.

## Markdown Templates and Reusable Structures

For recurring document types, templates reduce variability and improve consistency.

**Template prompts** provide document structures as examples. "Generate a README using this structure: H2 'Overview', H2 'Installation', H2 'Usage' with H3 subsections for common tasks, H2 'API Reference' with H3 for each major function, H2 'Contributing', H2 'License'. Each section should be 200-400 words."

**Section-level generation** creates documents incrementally using templates. Rather than generating an entire document in one pass, generate each major section separately using section-specific prompts and templates. This gives you more control over structure and reduces the chance of the model drifting off-template partway through a long generation.

**Schema-driven markdown** uses metadata to drive document structure. You define a document schema (what sections are required, what order, what heading levels), then prompt the model to generate content for each section according to the schema. The schema ensures structural consistency across many generated documents.

Templates work well for technical documentation, API references, release notes, and other document types with standard structures. For creative or exploratory content where structure should vary, templates are too constraining.

## The Markdown Production Pipeline

Production markdown generation combines prompt engineering, validation, repair, and testing.

**Prompt layer** specifies formatting requirements, document structure, style guide compliance, and length constraints. The prompt creates initial quality gates that reduce downstream validation failures.

**Validation layer** parses generated markdown, checks heading hierarchies, list consistency, code block formatting, and link integrity. Validation produces detailed error reports about what's wrong and where.

**Repair layer** automatically fixes common errors where intention is unambiguous. Repair transforms markdown to meet requirements without regeneration.

**Quality gate** decides whether markdown is publication-ready, needs regeneration, or requires human review. Low error counts pass automatically. High error counts trigger regeneration with modified prompts. Ambiguous cases escalate to human review.

**Rendering verification** tests that markdown renders correctly in target systems before publishing. This catches platform-specific issues that validation missed.

**Monitoring** tracks markdown quality metrics over time: validation failure rates by error type, repair success rates, manual review rates, regeneration rates. These metrics inform prompt improvements and identify when model behavior changes.

Markdown is simple enough that small errors are tolerable in some contexts and catastrophic in others. A malformed link in a blog post is minor. A broken heading hierarchy in API documentation breaks navigation. The rigor of your markdown pipeline should match the criticality of your use case.

The next section examines code generation as structured output: controlling code formatting, enabling safe execution, validating generated code, and handling the unique challenges of code as both text and executable logic.
