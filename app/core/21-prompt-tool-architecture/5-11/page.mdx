# 5.11 â€” Prompt Documentation Standards

A Series B fintech company discovered in March 2024 that their loan approval AI had been rejecting qualified applicants for six months. The investigation revealed that a prompt update in September 2023 had subtly shifted the risk assessment criteria, but no one documented what changed or why. Engineers guessed at the original intent, regulators demanded explanations no one could provide, and the company paid $2.8 million in settlements. The prompt itself worked exactly as written. The problem was that no one could explain what it was supposed to do.

Prompt documentation is not an afterthought. It is the contract between your intent and your implementation, the map that guides debugging, and the record that proves compliance. Without it, every prompt becomes a black box that only its author understands, and even that knowledge expires the moment they move to another project.

## Why Documentation Fails Before It Starts

Most teams treat prompt documentation like code comments. They write a brief explanation at the top, describe what the prompt does, and move on. This approach fails because prompts are not just code. They are natural language instructions that encode business logic, domain knowledge, and nuanced behavioral expectations that resist simple summarization.

The documentation needs to capture not just what the prompt does, but why it does it that way. What business requirements drove specific phrasing choices. What edge cases required particular guardrails. What alternatives were tested and rejected. Without this context, future engineers inherit a set of magic words they cannot safely modify.

The second failure mode is documentation drift. Engineers update prompts but forget to update the documentation. The documented behavior diverges from actual behavior. Trust in documentation erodes until no one reads it anymore, and the documentation becomes actively misleading rather than merely incomplete.

## The Prompt Specification Format

Start with a structured specification template that every prompt must complete. The template should include prompt metadata, intent description, input schema, output schema, behavioral constraints, and known limitations. This is not optional documentation that engineers write if they feel like it. This is required metadata that gates deployment.

The prompt metadata section identifies the prompt by name, version, author, creation date, and last modified date. It links to the ticket or requirement that created the prompt. It specifies the model family and temperature settings. This section answers who, when, and what.

The intent description explains why this prompt exists and what business problem it solves. It describes the desired behavior in plain language that a product manager could understand. It specifies success criteria that define when the prompt is working correctly. This section is the contract between product requirements and technical implementation.

The input schema documents every variable the prompt accepts. For each variable, specify the type, format, required versus optional status, valid ranges or enumerations, and examples of valid inputs. If the prompt expects structured data, provide JSON schema definitions. If it expects free text, describe length limits and content expectations.

The output schema documents the expected response format. Specify whether outputs are structured JSON, markdown, plain text, or other formats. Define required fields, optional fields, and validation rules. Provide examples of valid outputs and examples of edge case outputs. This schema becomes the basis for automated validation tests.

## Behavioral Constraints and Guardrails

Document every explicit constraint you have embedded in the prompt. If the prompt must refuse certain requests, document what triggers refusal and what the refusal message should look like. If the prompt must follow specific formatting rules, document those rules and explain why they matter. If the prompt must maintain particular tone or style, define that tone with examples.

These constraints are often invisible to readers of the raw prompt text. A phrase like "respond professionally and concisely" means different things to different people. Your documentation must operationalize these subjective requirements with concrete examples that show what professional and concise looks like in practice.

Document the rationale behind non-obvious constraints. If the prompt includes a specific example or counter-example, explain why that example is there. If the prompt uses particular phrasing that seems redundant, explain what problem that phrasing prevents. Future maintainers need to know which parts of the prompt are load-bearing and which parts can be safely modified.

## Known Limitations and Edge Cases

Every prompt has limitations. It might struggle with certain input formats, produce inconsistent outputs for edge cases, or exhibit biases in particular domains. Document these limitations explicitly rather than hoping no one notices them. This documentation protects you when limitations cause issues and guides future improvements.

For each known limitation, describe the failure mode, estimate how often it occurs, document the workaround if one exists, and link to tickets tracking the fix. If a limitation is acceptable because the edge case rarely occurs, document that decision and the reasoning behind it. If a limitation exists because fixing it proved too expensive, document what you tried and why it did not work.

Edge case documentation should include specific examples. Do not just write "struggles with ambiguous inputs." Provide an example of an ambiguous input, show what the prompt produces, explain why that output is problematic, and describe the ideal output. This specificity transforms vague warnings into actionable debugging information.

## Changelog Maintenance as Documentation

The changelog is not separate from documentation. It is a critical part of the documentation that shows how the prompt evolved and why. Every prompt change should generate a changelog entry that describes what changed, why it changed, what problem it solved, and what impact you expect.

Structure changelog entries with a date, version number, change type, description, and rationale. Change types might include bug fix, feature addition, performance improvement, safety enhancement, or deprecation. The description should be specific enough that someone reading the changelog six months later understands exactly what changed.

The rationale section explains why the change was necessary. Link to the ticket, incident report, or user feedback that motivated the change. If the change involved testing multiple alternatives, summarize what you tested and why you chose this approach. This context prevents future engineers from reverting a fix because they do not understand why it was needed.

## Documentation for Failure Investigation

When a prompt fails, documentation determines whether you can debug it in minutes or days. The documentation should enable someone who did not write the prompt to understand what it should do, what it actually did, and where the discrepancy occurred. This requires examples of correct behavior and examples of incorrect behavior.

Include a troubleshooting section that lists common failure modes and diagnostic steps. If the prompt sometimes produces outputs that violate the schema, document what triggers schema violations and how to identify the cause. If the prompt sometimes refuses valid requests, document what valid requests look like and what refusal patterns indicate. These troubleshooting guides accumulate institutional knowledge that would otherwise exist only in senior engineers' heads.

Document dependencies and assumptions. If the prompt assumes inputs have been sanitized or validated upstream, document that assumption. If the prompt works correctly only when used with specific model versions or temperature settings, document those requirements. When dependencies change or assumptions break, the documentation points directly to the root cause.

## Documentation Validation and Review

Documentation is code, and like code it needs review and validation. Create automated checks that verify documentation exists, follows the template, and contains required sections. Flag prompts that have been modified without corresponding changelog updates. Enforce documentation standards at the pull request level before changes merge.

Peer review should specifically evaluate documentation quality, not just code quality. Reviewers should verify that the intent description matches the prompt implementation, that examples are accurate and comprehensive, that limitations are honestly disclosed, and that the changelog entry explains the change rationale. Documentation review catches misunderstandings before they reach production.

Periodically audit documentation accuracy. Sample deployed prompts and verify that their documentation matches their behavior. When you find drift, update the documentation and investigate why the drift occurred. If documentation consistently drifts for certain types of changes, improve your review process or add automated validation to catch that drift earlier.

## Integration with Existing Documentation Systems

Prompt documentation should live close to the prompt itself, ideally in the same repository using the same version control system. This proximity ensures that prompt updates and documentation updates happen in the same commit and get reviewed together. Storing documentation in separate wikis or documents guarantees eventual divergence.

Use documentation generation tools to extract structured information from your prompt specifications and generate browsable reference documentation. Engineers should be able to search for prompts by name, purpose, or input type and immediately see the full specification. This searchability makes documentation discoverable when someone needs it rather than requiring them to dig through source code.

Link prompt documentation to related system documentation. If a prompt processes outputs from another service, link to that service's documentation. If a prompt implements requirements from a product spec, link to that spec. These connections help engineers understand the broader context and trace requirements from conception through implementation.

## Documentation as Product Specification

Treat prompt documentation as the authoritative specification of prompt behavior. When product managers want to understand what a feature does, they should be able to read the prompt documentation without reading the prompt itself. When compliance teams audit AI behavior, they should be able to verify requirements against documentation. This standard requires documentation that is complete, accurate, and maintained with the same rigor as the code.

Documentation quality directly correlates with system maintainability. Well-documented prompts can be modified by any engineer on the team. Poorly documented prompts become tribal knowledge owned by whoever wrote them. As your prompt library grows, documentation determines whether it becomes a reusable asset or an unmaintainable liability.

The documentation you write today determines whether your AI system can be debugged, audited, and evolved tomorrow. Effective documentation captures not just what prompts do, but why they do it, what they cannot do, and how they have changed over time.
