# 7.3 — Session Hijacking and Replay Attacks

Authentication happens once. Access happens continuously. A user logs in at 9 AM, starts a conversation with an AI assistant, and interacts with it throughout the day. They never log in again. Every request after that first authentication relies on a session token — a credential that proves they authenticated earlier. That token is not their password. It is a temporary proof of identity. If an attacker obtains it, they do not need the password. They have something better: active, authenticated access.

In mid-2025, an e-commerce company traced a series of fraudulent orders back to session hijacking. Customers would authenticate, browse products using an AI shopping assistant, and add items to their cart. Minutes later, their session tokens would be used from different IP addresses to modify shipping addresses and complete purchases. The attacker was not stealing passwords. They were intercepting session tokens transmitted over improperly secured WebSocket connections. The tokens remained valid for eight hours. The attacker used them immediately, then sold them on underground markets where other attackers used them until expiration. Each token represented eight hours of authenticated access to everything that customer could do.

Session hijacking is the theft or forgery of session state. The attacker does not break authentication. They bypass it by stealing proof of prior authentication. The system cannot distinguish the attacker's requests from the legitimate user's requests because both carry the same token. The logs show normal activity. The session appears valid. The user is authenticated. The identity is correct. The person behind the keyboard is not.

## Stealing Session Tokens: Network and Client-Side Attacks

Session tokens are transmitted with every request. That makes them vulnerable at multiple points. The token may be intercepted in transit if the connection is not properly encrypted. It may be stolen from the client if the browser or application is compromised. It may be logged or cached in places the attacker can access. It may be exposed through side channels the developer never considered.

Network interception remains common on unsecured networks. A user connects to public Wi-Fi at a coffee shop. The AI application uses HTTPS for the initial login but downgrades to HTTP or insecure WebSocket for the ongoing conversation. The attacker on the same network runs a packet sniffer and captures every token transmitted in plaintext. They extract the tokens and replay them from their own device. The system accepts the requests because the tokens are valid. The user has no idea their session has been cloned.

Client-side theft exploits vulnerabilities in how tokens are stored. Many web applications store session tokens in browser cookies. If the cookies are not marked HttpOnly, JavaScript can access them. A cross-site scripting vulnerability allows the attacker to inject a script that reads the session cookie and sends it to an attacker-controlled server. The attacker receives the token, uses it to make authenticated requests, and accesses the victim's account. The user never logged out. The session remains active. The attacker has a copy.

Mobile applications store tokens in local storage or shared preferences. If the device is rooted or jailbroken, or if the application does not properly protect its storage, malware can read the token. A user installs a malicious app that requests excessive permissions. The malware reads tokens from other applications and exfiltrates them. The attacker receives dozens or hundreds of tokens from compromised devices, each representing an authenticated session to a different service.

The defense starts with encryption. All session tokens must be transmitted over TLS. No exceptions. Not just at login — for every request throughout the session. Web applications must enforce HTTPS. Mobile apps must pin certificates to prevent man-in-the-middle attacks. WebSocket connections must use WSS, not WS. If your architecture requires long-lived connections, those connections must be encrypted end-to-end.

On the client side, tokens must be stored in the most secure location available. In browsers, use HttpOnly and Secure flags on cookies. HttpOnly prevents JavaScript access, blocking XSS-based theft. Secure ensures the cookie is only transmitted over HTTPS. In mobile apps, use platform-provided secure storage — Keychain on iOS, Keystore on Android. Do not store tokens in shared preferences, local storage, or any location accessible to other apps or to a rooted device.

Never log session tokens. Developers often log full HTTP requests for debugging. If those logs include authorization headers, they include session tokens. The logs are stored in Elasticsearch, CloudWatch, or on-disk files. The attacker who gains read access to logs gains access to every session token that was logged. Redact tokens before logging. Log only non-sensitive request metadata.

## Replay Attacks: Reusing Captured Requests

A replay attack is simpler than session theft. The attacker does not steal a token and craft new requests. They capture an entire authenticated request and resend it. The system processes the replayed request identically to the original. If the request was "transfer 500 dollars to account 7823," the replay causes a second transfer. If the request was "retrieve all customer records," the replay exfiltrates the data again.

Replay attacks are effective when requests are stateless and reusable. Traditional REST APIs often accept the same request multiple times. If the request is idempotent, resending it has no additional effect. But many AI operations are not idempotent. Asking an AI to send an email sends it again. Asking an AI to delete a record deletes it again if it has been restored. Asking an AI to execute a tool call executes it multiple times if the call has side effects.

A customer support AI in early 2026 was exploited through replay attacks. The AI allowed authenticated support agents to issue refunds through natural language commands. An attacker compromised a support agent's device and captured authenticated requests. They replayed the refund requests hundreds of times, each time with a different account number crafted by modifying a single parameter in the captured request. The system processed each replay as legitimate because the session token was valid and the request format matched prior legitimate requests. The company lost forty-seven thousand dollars before detecting the pattern.

Preventing replay requires tracking request uniqueness. The simplest mechanism is a nonce — a unique identifier included in every request. The server tracks which nonces it has seen. If a request arrives with a previously used nonce, the server rejects it. Nonces must be unpredictable, single-use, and bound to a specific session. The attacker cannot reuse a nonce because it has been marked consumed. They cannot forge a new nonce because it must be issued by the server or cryptographically signed.

For operations with significant side effects, require explicit confirmation. A single request to delete a dataset or transfer money should not be sufficient. The system should return a confirmation token. The client must submit a second request with that token to confirm intent. The confirmation token is single-use and expires quickly. The attacker who replays the first request receives a new confirmation token, but unless they also replay the confirmation, the operation does not complete.

Rate limiting provides partial defense. If the attacker replays a request ten times per second, rate limiting blocks most attempts. But rate limiting alone is insufficient. The attacker who replays once per hour may evade rate limits while still causing damage. Combine rate limiting with nonces, confirmation flows, and anomaly detection.

## Session Fixation: Forcing a Known Session

Session fixation is the inverse of session hijacking. Instead of stealing a victim's session, the attacker creates a session and tricks the victim into using it. The attacker generates a session identifier, sends it to the victim through a phishing link or malicious script, and waits for the victim to authenticate. When the victim logs in, the system associates their authenticated identity with the attacker-controlled session. The attacker now has access to the authenticated session without ever stealing credentials.

Session fixation in AI systems targets long-lived conversational sessions. The attacker initiates a conversation with the AI, receives a conversation ID, and sends that ID to the victim through a link: "continue your support conversation here." The victim clicks the link, authenticates, and continues the conversation. The system binds the victim's authenticated identity to the conversation the attacker started. The attacker, who still has access to that conversation, can now see the victim's messages, tool call results, and any data the AI retrieves on the victim's behalf.

A healthcare AI assistant was exploited this way in late 2025. The system allowed users to share conversation links for collaborative diagnosis discussions. An attacker initiated a conversation, obtained the conversation URL, and sent it to a physician claiming it was a shared case review. The physician clicked the link, authenticated with their hospital credentials, and began discussing a patient case. The attacker, monitoring the same conversation, saw patient names, diagnoses, and treatment plans. The physician had no indication they were in a conversation initiated by an attacker. The sharing feature had no mechanism to indicate conversation ownership or to require consent before joining a shared session.

Preventing session fixation requires regenerating session identifiers after authentication. The session ID used before login must not be the same as the session ID used after login. When the victim authenticates, the system issues a new session token. The old token is invalidated. The attacker, who knows only the pre-authentication token, cannot access the authenticated session.

For conversational AI, implement conversation ownership and access control. When a user starts a conversation, bind it to their authenticated identity. If another user attempts to access that conversation, require explicit sharing permission. Display clear indicators of who initiated the conversation and who has access. Do not allow anonymous conversation initiation followed by authenticated continuation. The session and conversation identity must be bound at creation, not at first authentication.

## The Long-Lived Session Problem in AI Assistants

Traditional web sessions last minutes to hours. AI assistant sessions last days to weeks. A user starts a research project, interacts with an AI over multiple days, and expects the conversation to persist. The session token that authenticated them on Monday must remain valid on Friday. Long-lived tokens increase hijack risk. The attacker has a longer window to steal the token. If the token is stolen, it remains valid longer.

The tension is between usability and security. Forcing the user to reauthenticate every fifteen minutes destroys the conversational experience. Allowing tokens to remain valid indefinitely makes compromise nearly unrecoverable. The solution is token rotation. The initial session token is short-lived. It expires after minutes or hours. The system also issues a refresh token with a longer lifetime. When the session token expires, the client uses the refresh token to request a new session token. The refresh token is used infrequently, reducing its exposure. The session token is used constantly but expires quickly.

If the session token is stolen, the attacker has limited time to use it before it expires. If the refresh token is stolen, the system can detect anomalies when it is used — the refresh token is normally used once per hour, but the attacker is using it every minute. The system can invalidate the refresh token and force reauthentication. The legitimate user is inconvenienced but protected.

For AI assistants with persistent state, tie reauthentication to risk. Low-risk operations — reading prior messages, asking general questions — require only an active session token. High-risk operations — modifying data, invoking tools with side effects, accessing sensitive resources — require recent reauthentication. The user who resumed a conversation from last week can browse history immediately but must reauthenticate before executing a database query. The system balances convenience and security by escalating verification only when necessary.

## Binding Sessions to Device and Context

A session token proves the user authenticated. It does not prove the same device or context is still in use. The user authenticates on their laptop. The attacker steals the token and uses it from their desktop. The system sees the same token and grants access. Binding sessions to device and context prevents this token reuse.

Device binding ties a session token to a specific device or browser. The system records a device fingerprint when the user authenticates — browser version, operating system, screen resolution, installed plugins. That fingerprint is stored with the session. Every subsequent request must present both the session token and a matching fingerprint. The attacker who steals the token cannot replicate the fingerprint. Their requests are rejected even though the token is valid.

Device fingerprinting is imperfect. Fingerprints can be spoofed. Legitimate users may have changing fingerprints if they update their browser or OS. Use fingerprinting as an additional signal, not as a sole security control. If the fingerprint changes, do not immediately reject the request. Instead, require additional verification — a second factor, a confirmation email, or a CAPTCHA.

Context binding ties a session to network and geographic context. The user authenticated from an IP address in California. Requests from that session should originate from similar IP ranges. If a request arrives from an IP in Russia ten minutes later, the session is likely hijacked. The system can block the request, invalidate the session, or require reauthentication.

Context binding must account for legitimate mobility. A user authenticates at home, then travels to the office. Their IP changes. A user authenticates on Wi-Fi, then switches to cellular. Their IP changes. Treat context changes as risk signals, not as definitive proof of compromise. Escalate verification when context changes dramatically — different country, different ISP, different time zone. Allow minor variations without friction.

## Detection Through Behavioral Analysis

Even when tokens are stolen, the attacker's behavior differs from the legitimate user's. The user asks five questions per hour. The attacker asks fifty. The user queries data relevant to their job function. The attacker queries everything. The user's requests follow conversational patterns. The attacker's requests are scripted or bulk-generated. Behavioral analysis catches hijacked sessions that credential checks miss.

Build behavioral baselines for every user. Track request frequency, query types, accessed resources, tool usage patterns, and time-of-day activity. Detect deviations in real-time. When a session exhibits behavior that does not match its owner's baseline, flag it for review or require reauthentication.

A financial AI platform in early 2026 caught session hijacking through behavioral analysis. A wealth management advisor's session token was stolen through a phishing attack. The attacker used the token to access client portfolios. The advisor typically accessed five to eight portfolios per day, always during business hours, and spent an average of twelve minutes per client reviewing data before moving to the next. The attacker accessed forty portfolios in twenty minutes, spending less than thirty seconds per client. The behavioral analysis system flagged the session as anomalous, invalidated the token, and sent an alert to the advisor. The advisor confirmed they had not accessed those accounts. The company locked the compromised account and initiated incident response within six minutes of the initial hijack.

Behavioral detection is not foolproof. Sophisticated attackers mimic normal behavior. They query data slowly, during business hours, using patterns that match the victim. But most attackers optimize for speed. They extract maximum value before detection. Behavioral analysis raises the cost of successful hijacking by forcing the attacker to blend in, reducing how much damage they can cause before being caught.

## Building Session Security for AI at Scale

Session security in AI systems requires rethinking assumptions. Sessions last longer. Users interact through natural language, making automated attack scripting harder to detect. Conversational state persists across sessions, creating additional hijack vectors. Tools and agents act autonomously, requiring delegation without exposing session tokens.

Transmit all tokens over encrypted channels. Store tokens in secure locations. Rotate tokens frequently. Bind tokens to device and context. Track nonces to prevent replay. Regenerate session identifiers after authentication to prevent fixation. Build behavioral baselines to detect hijacked sessions in use.

Never assume that possession of a valid token proves identity. It proves only that someone, at some point, authenticated. The current holder may not be that person. Treat every high-risk operation as a new authentication event. Require recent proof of identity before executing operations with significant impact. Log every session event to immutable storage so compromised sessions can be investigated after the fact.

The attacker who cannot hijack a session must go back to stealing credentials. The system that defends sessions forces attackers into harder, more detectable attacks. The next challenge is authorization — ensuring that even authenticated users can only access what they are entitled to.

