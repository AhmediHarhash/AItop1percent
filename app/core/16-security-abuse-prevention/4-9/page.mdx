# 4.9 — Defense: Human Approval for High-Risk Actions

The agent was functioning perfectly. It had passed validation. Its tool calls were correctly formatted. Its reasoning was sound. It was about to delete two years of archived customer support tickets because a prompt had convinced it that "cleaning up legacy data" was necessary for "system optimization." The tool it was calling had permissions to execute the delete. The arguments were validated. The action was irreversible. There was no human in the loop. The delete executed. The company spent six weeks recovering what they could from backups.

Some actions are too consequential to delegate to an agent without human oversight, no matter how sophisticated the validation, no matter how well-designed the tools. The cost of being wrong one time is higher than the cost of slowing down the workflow every time. Human approval is the final defense layer for high-risk operations. It's not a failure of automation. It's an acknowledgment that certain decisions require human judgment, context, and accountability that models cannot provide.

## The Approval Threshold

Not every action requires approval. If you gate everything behind a human check, the agent becomes a suggestion engine rather than an autonomous system. The value proposition of agents is that they act independently within defined boundaries. The question is where to draw the boundary between automatic execution and required approval. That line is defined by risk.

**Irreversibility** is the first criterion. Actions that can't be undone require approval. Deleting data, deploying code to production, transferring money, revoking access, terminating services — these are one-way doors. A model might have good reasons to recommend the action. But if the recommendation is based on a misunderstanding, a misinterpreted prompt, or adversarial manipulation, the damage is permanent. Approval adds a checkpoint where a human can verify intent and correctness before execution.

**External impact** is the second criterion. Actions that affect systems or people outside your control require approval. Sending emails to customers, posting to public APIs, making purchases from vendors, modifying user-visible content — these actions have consequences beyond your infrastructure. A mistaken internal database update can be rolled back. A mistaken email to ten thousand customers cannot. If the action crosses the boundary between your systems and the outside world, a human should confirm it first.

**Privilege escalation** is the third criterion. Actions that grant additional permissions, create new access paths, or modify security controls require approval. Adding a user to an admin group, generating API keys, changing firewall rules, modifying IAM policies — these change the security posture of the system. Even if the action seems reasonable in context, it might create an access path the attacker intends to exploit later. Approval ensures that permission changes are deliberate and reviewed.

**Cost thresholds** are the fourth criterion. Actions that spend money or consume expensive resources above a certain threshold require approval. Provisioning cloud infrastructure, purchasing licenses, running large-scale batch jobs — these have financial impact. The threshold depends on your business, but the principle is consistent: agents can operate freely within a budget, but exceeding it requires confirmation.

In practice, most production agent systems define a tiered approval model. Low-risk actions execute automatically. Medium-risk actions require review after execution, flagged for periodic audit. High-risk actions require approval before execution, blocking the workflow until a human confirms.

## Designing Approval Workflows That Don't Break UX

The worst approval workflow is one that adds so much friction that users bypass it. If the approval step takes three days, requires filling out a form, and involves multiple sign-offs, users will find ways to route around it. They'll create workarounds. They'll submit approvals in bulk without reading them. They'll complain until the approval requirement is removed. The workflow must be fast, lightweight, and integrated into the user experience so naturally that it feels like part of the process, not an obstacle.

Inline approval is the most seamless pattern. The agent explains what it's about to do, presents the exact action and its consequences, and asks for confirmation before proceeding. The user sees the request in the same interface where they're already interacting with the agent. They click approve or deny. The agent continues or stops. The entire flow takes seconds. This works for synchronous use cases where the user is present and the action is time-sensitive.

Asynchronous approval works when the action isn't urgent. The agent queues the request and notifies the approver via Slack, email, or a dashboard. The approver reviews the request when convenient, approves or denies it, and the agent executes or cancels accordingly. This pattern supports workflows where agents operate in the background or where approval authority is delegated to a different person than the user who initiated the request.

In November 2025, a procurement agent needed approval for purchases above five thousand dollars. The team built an approval bot that posted to a dedicated Slack channel with the item, cost, justification, and two buttons: approve or deny. The VP of Operations monitored the channel and typically responded within an hour. The workflow added minimal latency for legitimate requests and provided a clear audit trail. The agent couldn't proceed without confirmation, but the confirmation was fast enough that it didn't block business operations.

The key to successful approval workflows is clarity. The request presented to the approver must include everything needed to make an informed decision. The exact action the agent will take. The resources it will affect. The cost or risk involved. The justification based on the conversation context. The consequences of approval versus denial. If the approver has to ask follow-up questions or investigate context, the workflow has failed. The request should be self-contained.

## Tiered Approval Levels

Not all approvals need the same level of scrutiny. A three-tier model balances safety and velocity. **Automatic execution** for low-risk actions: reading data, generating reports, making queries, performing calculations. These actions don't modify state, don't affect external systems, and can be logged and audited after the fact. No approval required.

**Review-required execution** for medium-risk actions: modifying non-critical configuration, updating internal documentation, making low-value purchases, sending internal notifications. These actions execute immediately but are flagged for periodic human review. A manager or auditor reviews the log of these actions weekly or monthly to ensure they're consistent with policy. If anomalies are detected, they're investigated. If the action log shows a pattern of misuse, approval requirements are tightened.

**Approval-required execution** for high-risk actions: deleting data, deploying to production, granting permissions, making financial transactions above a threshold, sending external communications. These actions block until a human approves. The agent waits. If approval is denied, the agent informs the user and does not execute the action. If approval is granted, the agent proceeds and logs both the request and the approval for audit purposes.

Some organizations add a fourth tier: **multi-party approval** for the riskiest actions. Deploying to production in a regulated environment might require approval from both the engineering lead and the compliance officer. Transferring large sums of money might require approval from two signatories. Revoking access for a privileged user might require approval from security and HR. Multi-party approval is rare but appropriate for actions where the cost of a mistake justifies the extra overhead.

The tiers should be enforced by the tool, not by the prompt. A tool that deletes data should check the approval tier for the requested operation and refuse to execute without the required confirmation. The model can't bypass this check by rewording the request. The enforcement is structural.

## When to Require Approval

A fintech agent in early 2026 had a tool for transferring funds between customer accounts. Transfers under one hundred dollars executed automatically. Transfers between one hundred and one thousand dollars required inline user confirmation. Transfers above one thousand dollars required approval from the user plus a secondary review from the fraud prevention team, which added a two-hour delay on average. The thresholds were calibrated based on fraud risk, customer complaints, and operational velocity. Below one hundred dollars, fraud losses were manageable and speed mattered. Above one thousand dollars, the cost of a single fraudulent transfer justified the review delay.

Approval requirements should be based on measured risk, not fear. If you require approval for everything, you've built a chatbot that makes suggestions. If you require approval for nothing, you've built a system that will eventually cause a disaster. The correct threshold is the point where the expected cost of automated errors exceeds the operational cost of approval workflows.

This means quantifying risk. How often does the agent make mistakes on this action type? What's the cost of those mistakes? What's the cost in time and human effort to review approval requests? If the agent is wrong one percent of the time and each mistake costs ten thousand dollars, and you handle one hundred requests per month, you're looking at ten thousand dollars in expected losses per month. If review costs ten minutes per request and your reviewers cost one hundred dollars per hour, approval adds one hundred sixty-seven dollars per month in labor cost. The trade-off is obvious: require approval.

But if the agent is wrong one percent of the time and each mistake costs ten dollars, expected losses are ten dollars per month. Approval costs one hundred sixty-seven dollars. The approval workflow is more expensive than the mistakes. Let the agent execute automatically and monitor the logs for anomalies.

This analysis should be revisited regularly. As agents improve, error rates drop and approval thresholds can be raised. As the stakes of your business change, thresholds should be adjusted. An early-stage startup might tolerate higher risk for faster iteration. A publicly traded company in a regulated industry cannot.

## Approval Fatigue and Its Risks

The finance team approved seventy-three procurement requests in one week. Most were routine: software licenses, cloud credits, minor vendor invoices. On request seventy-four, the approver saw another line item for cloud infrastructure and clicked approve without reading the details. The cost was forty-seven thousand dollars. The request was generated by an adversarial prompt that convinced the procurement agent to provision GPU clusters for "model training." The approver had developed approval fatigue. The workflow had trained them to click through requests without scrutiny because most requests were legitimate and the volume was overwhelming.

Approval fatigue is the greatest risk to approval-based defenses. When humans are asked to approve too many actions, they stop reading. Approval becomes a rubber stamp. The workflow provides an illusion of safety without actual oversight. The solution is not to remove approvals — it's to reduce the volume of approval requests so that each one receives genuine attention.

This means tightening the automatic execution tier. If an action can be made low-risk through better scoping, better validation, or better tool design, make that change and remove the approval requirement. A tool that could delete any file required approval for every deletion. A redesigned tool that can only delete files in a specific temp directory no longer needs approval for each call. The risk has been eliminated through scoping.

It also means batching approvals intelligently. Instead of asking for approval on seventy individual line items, group them into logical sets and present them as one approval decision with a detailed breakdown. The approver reviews the batch, sees the summary, and approves the set. This only works if the actions in the batch are actually related and at similar risk levels. Mixing high-risk and low-risk actions in one batch hides the dangerous request in the noise.

Approval workflows should include context that helps the approver notice anomalies. Highlighting requests that deviate from normal patterns. Flagging unusually high costs. Showing historical trends. If the typical weekly procurement spend is five thousand dollars and this week's requests total fifty thousand, the approver should see that signal immediately. The workflow should make abnormal requests visually distinct so they trigger scrutiny.

## The Latency Versus Safety Trade-Off

Approval adds latency. That latency has a cost. In customer support, every minute of delay is a worse customer experience. In trading systems, every second matters. In incident response, approval workflows can mean the difference between mitigating a problem and letting it cascade. The trade-off is real.

But latency can be managed. Inline approval for synchronous workflows adds only the time it takes the user to read and confirm — often under ten seconds. Asynchronous approval with SLA-driven escalation ensures that requests don't sit unreviewed for days. Push notifications, Slack integrations, and mobile approval interfaces reduce the time between request and decision. The goal is to make approval fast enough that it doesn't break the user experience while still providing the safety check that prevents catastrophic actions.

Some systems implement conditional approval. The agent proceeds with execution but the action is reversible for a short time window. A user approves a data deletion. The agent marks the data as deleted but retains it for seven days. If the deletion was a mistake, the data can be restored. The approval workflow added safety without blocking the operation. This pattern works for actions that can be staged or made reversible.

Emergency bypass is the escape hatch for situations where approval latency is unacceptable. A production outage requires immediate remediation. The agent needs to restart services, roll back deployments, or reroute traffic. Waiting for approval means more downtime. The system allows a privileged user to invoke emergency bypass, which lets the agent execute high-risk actions without approval but logs every bypassed action to an audit system and pages the security team. The bypass exists, but it's monitored, restricted, and audited. It's not a backdoor. It's a controlled exception.

## Approval as Accountability

Approval workflows serve a second purpose beyond security: they create accountability. When a human approves an action, they take responsibility for the outcome. If the action causes harm, there's a clear decision point and a person who made the call. This matters for regulatory compliance, for incident post-mortems, and for organizational trust.

In a system where agents execute autonomously without approval, responsibility is diffuse. Who is accountable when the agent makes a mistake? The engineer who designed the tool? The person who wrote the prompt? The user who initiated the request? The model provider? Approval cuts through this ambiguity. The approver is accountable. They reviewed the action, understood the consequences, and confirmed it should proceed.

This is why approval workflows must present sufficient context. The approver can only be accountable if they had the information needed to make an informed decision. If the approval request hides details, omits risks, or misrepresents the action, the accountability is undermined. The workflow must be designed so that an informed approval is possible.

Approval also provides a natural point for documentation. The approver can add a note explaining why they approved or denied the request. That note becomes part of the audit log. It provides context for future reviews. It helps teams understand the reasoning behind decisions. It turns approval from a binary gate into a documented decision-making process.

## Building Approval Into Tool Design

Approval is not an afterthought. It's part of the tool's design. When you build a tool that performs high-risk actions, the tool includes the approval logic. It checks whether the current action requires approval based on its tier. It surfaces the approval request in the appropriate interface. It waits for confirmation. It proceeds only when approval is granted.

The model doesn't manage approval. The model calls the tool. The tool handles the approval workflow. This separation ensures that adversarial prompts can't convince the model to skip approval or misrepresent the action to the approver. The tool is the enforcement point.

Approval workflows are the final layer in a defense-in-depth strategy for tool security. Least-privilege design constrains what tools can do. Validation and sandboxing ensure tools can't be misused through malicious inputs. Approval ensures that even legitimate use of powerful tools is reviewed before execution. Together, these layers make tool-calling agents safe enough to deploy in production environments where mistakes have real consequences. The next chapter addresses the second category of capability abuse: data exfiltration and privacy violations, where the agent's ability to access and retrieve information becomes the attack surface.

