# 9.7 — Defense: Action Budgets and Step Limits

An agent with no limits is a security incident waiting to happen. The problem is not theoretical. In October 2025, a B2B SaaS company deployed a customer support agent with full write access to their ticketing system and no action constraints. Within three hours, a single malicious prompt caused the agent to loop through a ticket creation routine 14,000 times, generating support tickets for every historical user in the database. The cost was immediate: $28,000 in API calls that morning, three days of manual cleanup, and lost trust from enterprise customers who watched their ticket queues explode with nonsense. The root cause was not a sophisticated jailbreak. It was the absence of basic budget enforcement.

The principle is simple: if an agent can take unlimited actions, an attacker will find a way to make it take unlimited actions. Budgets are not about cost control alone. They are about preventing runaway behavior, containing damage, and making the worst-case scenario survivable. Every agent needs constraints on what it can do, how many times it can do it, and how much it can spend before requiring human intervention. Without budgets, you are trusting that nothing will ever go wrong — and that trust is misplaced every single time.

## The Three Budget Dimensions

An effective agent budget system operates across three dimensions simultaneously: action count, resource cost, and execution time. Each dimension catches a different category of abuse.

**Action budgets** limit how many operations the agent can perform in a single session or per unit of time. A customer service agent might be allowed 50 tool calls per conversation, or 200 API requests per hour. These limits prevent infinite loops, recursive escalation, and prompt injections that cause the agent to spam internal systems. When the agent hits the action limit, it stops — no more tool calls, no more execution, human review required. The number you choose depends on the task. A simple Q&A agent might need 10 actions per session. A complex research agent might need 500. The key is that the number exists and is enforced before execution, not discovered after the incident.

**Cost budgets** cap the financial impact of agent behavior. Every tool call has a cost: the LLM inference cost, the API call cost if the tool hits external services, and the infrastructure cost for data access. A cost budget tracks cumulative spend during the agent's execution and halts the agent when it crosses a threshold. For a document summarization agent, you might set a per-document budget of three dollars. For a data pipeline agent, you might set a per-run budget of fifty dollars. Cost budgets protect you from the agent that decides the best way to answer a question is to call an expensive third-party API 10,000 times. They also make incidents survivable — the damage is bounded, not catastrophic.

**Step limits** constrain how many reasoning cycles or turns the agent can execute before requiring escalation. A step is one full cycle of reasoning, tool selection, tool execution, and state update. For most tasks, legitimate agent behavior completes in 5 to 20 steps. A step limit of 30 or 50 catches the agent that gets stuck in a planning loop, repeatedly attempts the same failed action, or is being steered by an adversarial prompt into perpetual deliberation. Step limits are the cheapest form of safety — they cost nothing to enforce and prevent the majority of runaway scenarios. The attacker who wants your agent to waste resources has to accomplish their goal in fewer steps than your limit allows.

## Granular Budgets Per Action Type

Not all actions carry the same risk. A flat budget treats reading a file the same as deleting a file, treats calling a public API the same as writing to a production database. That uniformity creates two problems: it either allows too much risk or blocks too much productivity. The solution is **granular budgets** — separate limits for different action types based on their reversibility and impact.

You define action classes by danger level. Read operations — retrieving documents, querying databases, calling GET endpoints — are low risk and get generous budgets. An agent might be allowed 500 reads per session. Write operations that modify non-critical data — creating draft tickets, logging events, updating cache — are medium risk and get moderate budgets. An agent might be allowed 50 non-critical writes per session. High-risk operations — deleting records, sending external communications, executing privileged commands, spending money — are high risk and get tight budgets. An agent might be allowed 5 high-risk actions per session, or zero without explicit approval.

Granular budgets let you scale autonomy without scaling danger. The research agent that needs to read 200 documents is not blocked by a flat 50-action limit. The customer support agent that needs to update 30 tickets is not constrained by the same limit that prevents it from deleting user accounts. You give the agent room to work in safe dimensions while locking down the dangerous ones. The budgets are enforced at the tool invocation layer — before the tool executes, the system checks whether the agent has budget remaining for that action type. If yes, proceed and decrement. If no, deny and log.

The breakdown you choose reflects your risk model. A typical enterprise deployment might use five action classes: read, non-critical write, external API call, critical write, and privileged operation. Each class has its own per-session and per-hour budget. The agent's framework tracks consumption in real time and surfaces budget status in logs and monitoring dashboards. When the agent exhausts a budget, the framework either halts execution or escalates to a human depending on the task's urgency.

## Budget Reset Policies and Time Windows

Budgets are meaningless if they reset too frequently or never reset at all. A per-session budget that resets every time the agent starts a new conversation prevents long-running abuse but allows an attacker to trigger thousands of sessions. A lifetime budget that never resets eventually locks the agent out of all functionality after enough legitimate use. The solution is **time-windowed budgets** with explicit reset policies that match your operational rhythm.

Most production systems use rolling time windows. A per-hour budget allows the agent to consume its full allocation every hour, then resets. A per-day budget resets at midnight. A per-session budget resets when the session ends, but sessions have maximum lifetimes to prevent indefinite execution. The window you choose depends on usage patterns. For high-throughput agents processing hundreds of requests per day, hourly windows provide fine-grained control. For low-throughput agents handling occasional tasks, daily windows reduce operational complexity.

Stacking budgets across multiple time windows adds depth. An agent might have a per-session limit of 50 actions, a per-hour limit of 200 actions, and a per-day limit of 1,000 actions. All three limits are enforced simultaneously. The per-session limit prevents a single malicious conversation from consuming excessive resources. The per-hour limit prevents an attacker from spawning 50 sessions in rapid succession. The per-day limit provides an absolute ceiling that protects the system even if hourly budgets are exploited through timing attacks. When any limit is hit, the agent stops. The most restrictive limit always wins.

Reset policies also govern recovery from incidents. After a budget violation, you can require manual review before the budget resets, implement exponential backoff for repeated violations, or temporarily lower the agent's limits until trust is restored. A customer service agent that hits its action limit five times in one day might have its budget reduced by 50 percent for the next 24 hours. A data processing agent that repeatedly exhausts its cost budget might require approval from a senior engineer before resuming. The reset is not automatic — it is conditional on demonstrating that the problem has been addressed.

## Implementing Budget Enforcement in Agent Frameworks

Budget enforcement is not optional configuration. It is core infrastructure that sits between the agent's decision layer and the tool execution layer. Every tool call passes through a budget validator before execution. The validator checks current consumption against defined limits, logs the decision, and either allows or denies the action. This happens synchronously — the agent does not proceed until the validator responds.

The validator maintains state for each active agent session. State includes the session identifier, the agent's identity, current consumption across all budget dimensions, the time window boundaries, and any active restrictions from prior violations. This state lives in fast storage — Redis, Memcached, or in-memory maps for single-instance deployments. The lookup must complete in single-digit milliseconds because it happens on every tool call. Slow budget checks become throughput bottlenecks that make the agent unusable.

When the validator denies an action due to budget exhaustion, it does not silently fail. It returns a specific error code that the agent framework can interpret: budget exceeded, action type, current consumption, limit value, time until reset. The agent's orchestration layer decides what to do next. For critical tasks, it might escalate to a human and pause execution. For non-critical tasks, it might terminate the session and log the incident. For partial-success scenarios, it might return results from completed actions and explain what was not attempted due to limits. The user or calling system knows exactly why the agent stopped.

Monitoring and alerting are inseparable from budget enforcement. Every budget denial generates a log entry with full context: the agent, the denied action, the violated limit, the prompt or task that triggered the behavior, and the session history leading up to the denial. These logs feed into anomaly detection systems that identify patterns — the same user triggering budget violations repeatedly, budget violations clustered around specific tasks, or sudden spikes in consumption that suggest an active attack. High-severity violations trigger immediate alerts to the security team. The goal is not just to stop the bad action but to understand whether it represents targeted abuse or a systemic issue.

## Why Budgets Fail and How to Fix Them

The most common budget failure is **setting limits too high**. Teams building agents for the first time often overestimate legitimate usage and set budgets that feel generous but still allow catastrophic abuse. An action budget of 10,000 per session might seem reasonable for a complex agent, but it is large enough to permit serious damage. The fix is empirical: deploy with conservative limits, measure actual legitimate usage over the first month, then adjust upward by 20 percent to create headroom. Start restrictive, not permissive. You can always loosen a budget that blocks legitimate work. You cannot un-spend the money from an under-budgeted agent that went rogue.

The second failure mode is **ignoring budget stacking**. An agent with a per-session budget of 100 actions sounds safe until you realize it can spawn 50 parallel sessions and consume 5,000 actions simultaneously. Budgets must stack across sessions, users, and time windows to prevent this. A user-level budget caps the total actions across all of that user's active agent sessions. A system-level budget caps the total actions across all agents in the deployment. When any budget is hit, the restrictive behavior applies. The attacker cannot bypass session limits by creating more sessions.

The third failure is **no budget visibility for the agent itself**. If the agent does not know how much budget remains, it cannot plan effectively. It might attempt a 50-action research task when only 10 actions remain, fail halfway through, and leave the user with incomplete results. The solution is to expose budget status as context in the agent's prompt or as a tool the agent can query. The agent sees: "You have 40 actions remaining in this session, 150 remaining this hour." It can reason about whether the task is achievable within limits, warn the user that the request might require escalation, or break the task into smaller chunks that fit within budget. Transparency turns budgets from hard walls into planning constraints.

The fourth failure is **treating budget violations as pure security events**. Many violations are not attacks — they are legitimate tasks that hit undersized budgets, agent bugs that cause inefficient tool use, or poorly designed prompts that encourage wasteful behavior. If every violation triggers a security alert, the security team drowns in noise and starts ignoring the alerts. The fix is categorization. Separate accidental overruns from suspicious patterns. A first-time violation that slightly exceeds limits is logged and flagged for review. A repeated violation from the same user with identical behavior is escalated as potential abuse. A violation accompanied by unusual prompt patterns or rapid session creation is treated as an active incident. Context determines response.

## The Budget Negotiation Problem

Users hate budgets. Agents that stop mid-task and say "budget exceeded, escalating to human" feel broken, especially when the task was legitimate. The challenge is communicating limits without making the system feel arbitrary or obstructive. The solution is **budget negotiation** — when the agent approaches a limit, it warns the user and offers options.

The agent might say: "This research task will require approximately 80 actions. You have 50 remaining in this session. I can complete the first three sources now and resume after budget reset, or you can request extended budget approval for this session." The user chooses. They are not blocked — they are informed and empowered. The negotiation flow is baked into the agent's conversational design. The agent tracks consumption, predicts when it will hit limits based on the current task, and surfaces that prediction before it becomes a hard stop.

For high-value users or critical tasks, you implement **temporary budget overrides**. An engineer debugging a production incident can request a 10x action budget increase for the next hour, subject to manager approval. A customer success agent handling an escalated enterprise case can request extended write permissions, subject to automated approval if the customer account is verified. The override is logged, time-limited, and auditable. It prevents budgets from blocking critical work while maintaining accountability. The attacker cannot request overrides without triggering review because the request itself is logged and monitored.

Budgets are not about saying no. They are about saying yes with constraints. The best agent systems make budgets invisible during normal operation and explicit only when limits matter. The user should never think about budgets until the task requires more than the default allows — and when that happens, the system should make the path forward clear, fast, and traceable.

The next layer of agent security moves from resource limits to specific action approval: when the agent decides to take a high-risk action, how do you ensure a human reviews it without destroying the throughput that makes agents valuable in the first place?

