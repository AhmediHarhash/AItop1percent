# 8.2 â€” RTL Support and UI Mirroring: Arabic, Hebrew, and Bidirectional Layouts

Right-to-left support is not flipping the text direction. It is mirroring the entire spatial logic of your interface -- navigation, icons, progress indicators, form layouts, scroll behavior, animation direction, and visual hierarchy. A product that merely sets a CSS direction attribute to RTL and calls it done has completed perhaps 20 percent of the work. The remaining 80 percent is the difference between an interface that technically renders right-to-left and one that actually feels native to an RTL reader.

The distinction matters because RTL users are not a niche. Arabic alone has over 420 million speakers. Add Farsi at 110 million, Urdu at over 230 million, and Hebrew at 9 million, and you are looking at roughly 770 million people whose primary reading direction is right-to-left. If your product serves any market in the Middle East, North Africa, Iran, Pakistan, or Israel, RTL support is not a feature. It is a requirement for basic usability.

## What Mirroring Actually Means

When an English-speaking designer lays out an interface, spatial logic flows from left to right. The eye enters from the upper left. Navigation sits on the left. Content flows rightward. Progress bars fill from left to right. "Back" means moving left. "Forward" means moving right. These spatial assumptions are so deeply embedded that designers rarely think about them explicitly. They are the invisible grammar of LTR interfaces.

For RTL users, every one of these assumptions reverses. The eye enters from the upper right. Navigation should sit on the right. Content flows leftward. Progress bars fill from right to left. "Back" means moving right. "Forward" means moving left. Mirroring an interface means flipping this entire spatial grammar along the vertical axis, as if you held the screen up to a mirror.

In practice, mirroring means the following. Sidebars and navigation panels move from the left edge to the right edge. Breadcrumbs read from right to left, with the hierarchy flowing rightward toward the root. Checkboxes and radio buttons sit on the right side of their labels, not the left. Slide-out panels animate from the right edge instead of the left. Pagination controls place "previous" on the right and "next" on the left. Tooltips and popovers appear on the right side of their trigger element by default. Carousels and horizontal scrolling move in the opposite direction. Even the subtle details matter: a list of search results should right-align its text, and the selection indicator should appear on the right margin.

The mental model shift is this: take your existing interface, hold it up to a vertical mirror, and what you see should be the RTL version. With specific exceptions.

## The Exceptions: What Does Not Mirror

Not everything flips. This is where teams make their most common mistakes -- either mirroring things that should stay fixed, or failing to mirror things that should flip.

**Numbers stay left-to-right.** Arabic text reads right-to-left, but Arabic numerals read left-to-right. The number 12,345 is read starting from the one on the left, not the five on the right, even in an Arabic sentence. This means numerical data, phone numbers, mathematical expressions, and numerical identifiers maintain their LTR directionality within an RTL context.

**Media playback controls stay fixed.** Play, pause, fast-forward, and rewind buttons maintain their universal orientation. Play points right. Rewind points left. These conventions are global and do not mirror. Volume sliders, however, are more nuanced -- some implementations mirror them (filling from right to left), while others keep them LTR. The safest approach is to test with native users.

**Clocks and circular indicators stay fixed.** Time flows clockwise in RTL cultures just as it does in LTR cultures. Circular progress indicators, clock faces, and any circular motion should not reverse direction.

**Brand logos and trademarks stay fixed.** Your company logo should not be mirrored. Nor should partner logos, certification marks, or any branded visual element.

**Checkmarks and universal symbols stay fixed.** A checkmark looks the same in every culture. So does a magnifying glass icon, a gear icon, or a home icon. Icons that don't imply horizontal direction should not be mirrored.

**What must mirror.** Arrows and chevrons that indicate navigation direction must mirror. A right-pointing arrow that means "next" in LTR must become a left-pointing arrow in RTL. A left-pointing "back" arrow must become a right-pointing arrow. Sliding toggle switches should mirror. Progress bars that represent sequential progress should fill from right to left. Any icon that implies horizontal direction -- send icons that point right, forward arrows, undo/redo arrows -- must flip.

The rule of thumb: if the icon's direction encodes meaning about movement, sequence, or navigation within the interface, mirror it. If the icon represents an external convention (play buttons, clocks) or a non-directional concept (settings, search, home), leave it.

## Bidirectional Text: The Hardest Problem

When an Arabic sentence contains an English brand name, a URL, an email address, or a number, you have bidirectional text: RTL and LTR content in the same line. The Unicode Bidirectional Algorithm (often called the BiDi algorithm) handles the rendering of mixed-direction text, and it is one of the most complex text-processing specifications in computing.

The BiDi algorithm assigns a directionality to each character in a string. Arabic characters are classified as RTL. Latin characters are classified as LTR. Numbers are classified as "European numbers" with special rules. Punctuation is classified as "neutral" and inherits its direction from surrounding characters. The algorithm then arranges the characters for display, creating a visual ordering that differs from the logical (memory) ordering of the characters.

For simple cases, the algorithm works correctly without intervention. An Arabic sentence with an embedded English word will render with the Arabic text flowing right-to-left and the English word embedded left-to-right within the sentence, and the overall sentence will appear correct to a bilingual reader.

The problems arise in complex cases. An Arabic sentence that contains a URL with path segments and query parameters can produce unexpected rendering because the slashes, dots, and equals signs in the URL are neutral characters whose direction is ambiguous. An Arabic sentence with parenthetical English text can produce misplaced parentheses because the opening and closing parentheses are "mirrored" by the BiDi algorithm. An Arabic paragraph that contains a code snippet or a technical identifier with mixed Latin characters and numbers can produce a visual ordering that doesn't match either reading direction.

These edge cases are especially common in AI products because model outputs frequently contain mixed-script content. An Arabic-language AI assistant responding to a technical question might produce a response that mixes Arabic explanation with English technical terms, version numbers, product names, and formatted values. Each of these embedded LTR segments interacts with the BiDi algorithm, and the results are not always what you expect.

The practical mitigation has three layers. First, use explicit directional marks in your rendering pipeline. The Unicode specification includes invisible characters -- Left-to-Right Mark and Right-to-Left Mark -- that can be inserted at strategic points to disambiguate directional resolution. When your model produces output that will be rendered in an RTL context, your post-processing pipeline should insert directional marks around embedded LTR content like URLs, email addresses, and technical identifiers. Second, wrap embedded LTR content in explicit directional isolates. These are HTML-level or Unicode-level markers that tell the rendering engine to treat a segment of text as an isolated directional run, preventing it from interfering with the surrounding RTL context. Third, test your actual model output in an RTL rendering environment. BiDi issues are almost impossible to predict from the logical string alone -- you must see the rendered output to spot problems.

## Common Failures in AI Products

AI products have a specific set of RTL failures that go beyond standard web localization. The model output is dynamic, unpredictable, and often longer and more complex than pre-written interface text. This makes AI products especially vulnerable to the following failures.

**Chat bubble alignment.** In a conversational AI interface, user messages typically appear on the right and assistant messages on the left (in LTR layouts). In RTL, this should mirror: user messages on the left, assistant messages on the right. But many chat frameworks hardcode the alignment, producing an interface where the spatial relationship between user and assistant feels inverted.

**Streaming text direction.** When the model streams its response token by token, the tokens must render in the correct direction. Streaming RTL text that renders each new token on the right end of the line (as LTR streaming would) instead of extending the text from the right produces a disorienting animation where the text appears to build in the wrong direction. The user sees characters appearing on the wrong side of the growing text block.

**Code-mixed model output.** When an Arabic-language model response includes English technical terms, code identifiers, or numerical references, the BiDi algorithm produces unpredictable visual ordering. A model responding about API endpoints might produce a sentence where the Arabic explanation and the English endpoint URL render in a visually confusing arrangement. Without explicit directional isolation around the English segments, the sentence can become unreadable.

**Markdown rendering in RTL.** Many AI products render model output as Markdown -- headings, bold text, lists, links. Markdown renderers that don't account for RTL produce misaligned headings, lists that bullet on the wrong side, and links where the display text and URL interact badly with the BiDi algorithm. If your product renders model output as Markdown, your Markdown renderer must be RTL-aware.

**Right-aligned input fields.** Text input fields for RTL languages should right-align the cursor and text entry point. A user typing Arabic in a left-aligned input field fights the cursor on every character. The text appears to build from the wrong side, and the cursor position feels unpredictable. This is one of the most commonly reported frustrations among RTL users of AI products.

## CSS Logical Properties and Framework Support

The modern approach to RTL support in web interfaces uses CSS logical properties, which replace directional physical properties with flow-relative alternatives. Instead of margin-left and margin-right, you use margin-inline-start and margin-inline-end. Instead of padding-left and padding-right, you use padding-inline-start and padding-inline-end. Instead of left and right for positioning, you use inset-inline-start and inset-inline-end. Instead of text-align left, you use text-align start.

Logical properties automatically adapt to the document's writing direction. When the document direction is LTR, margin-inline-start resolves to margin-left. When the direction is RTL, it resolves to margin-right. This means a single stylesheet handles both directions without any overrides, media queries, or conditional logic. The layout mirrors automatically.

As of 2026, CSS logical properties have full support across all major browsers. There is no compatibility excuse for using physical properties in new code. For existing codebases, the migration path is to audit the stylesheet for physical properties (left, right, margin-left, margin-right, padding-left, padding-right, border-left, border-right, float left/right) and replace them with their logical equivalents. Automated tools and linting rules can flag physical properties and suggest replacements.

React, Angular, Vue, and their associated UI component libraries have varying levels of RTL support. Material UI provides built-in RTL through its theme system. Tailwind CSS supports logical properties through its RTL plugin. Ant Design has RTL support as a configuration option. If you're choosing a UI framework for a product that will serve RTL markets, RTL support quality should be a selection criterion, not an afterthought.

The critical principle is this: build with logical properties from the start and RTL support is nearly automatic. Retrofit physical properties after the interface is built, and you will spend weeks hunting down every margin-left that should be margin-inline-start, every absolute position that should use logical insets, every animation that moves in the wrong direction.

## Testing RTL: What to Automate and What Requires Humans

RTL testing requires both automated and human approaches, and neither alone is sufficient.

**Automated visual regression testing** catches layout mirroring issues. Take screenshots of every page and component in both LTR and RTL modes. Compare the RTL screenshots against the expected mirrored layout. Flag any component where the visual layout doesn't mirror correctly: navigation on the wrong side, icons pointing the wrong direction, alignment inconsistencies. Visual regression tools can run these comparisons on every code change, catching RTL regressions before they reach production.

**Automated BiDi text rendering tests** catch text direction issues. Create a test suite of strings that exercise BiDi edge cases: Arabic text with embedded English words, RTL text with URLs, RTL text with parenthetical LTR content, RTL text with numbers. Render each string in your interface components and verify that the visual output matches the expected rendering. These tests are harder to automate than layout tests because the "expected" rendering for BiDi text can be complex, but a curated set of representative test strings covers the most common failure modes.

**Native speaker UX testing** catches everything else. Automated tests verify that the interface renders correctly according to technical specifications. Native Arabic or Hebrew speakers verify that the interface feels correct -- that the spatial logic is intuitive, that the reading flow is natural, that nothing feels "off" in a way that technical tests can't capture. Plan for at least five to eight native speaker sessions per major release, with testers who regularly use RTL interfaces (not bilingual speakers who primarily use LTR devices, as they may have adapted to LTR conventions and miss issues that monolingual RTL users would notice immediately).

**Ongoing monitoring in production** catches the failures that slip through testing. Track per-locale engagement metrics, error rates, and user feedback for RTL locales. A sudden spike in bounce rates for Arabic users after a release, when the release didn't intentionally change any RTL behavior, is a signal that a regression was introduced. The faster you detect it, the less market damage it causes.

## The Market Cost of Skipping RTL

The arithmetic is straightforward. The Middle East and North Africa represent a rapidly growing market for AI products, with Gulf states investing heavily in AI adoption and digital transformation since the mid-2020s. Pakistan is one of the world's largest smartphone markets. Iran has a sophisticated tech-savvy population. Israel is a global tech hub. If your product cannot properly serve RTL users, you cannot serve any of these markets.

Some teams attempt a middle ground: serve RTL markets with an LTR interface but RTL text content. This is the worst possible approach. It creates a dissonant experience where the text reads right-to-left but the navigation, icons, and spatial logic all point the wrong way. Users find this more confusing than a pure LTR interface because the mixed signals create cognitive friction on every interaction. It is better to not claim RTL support at all than to provide broken RTL support that confirms The Broken Language Conclusion from the previous subchapter.

The investment required for proper RTL support is front-loaded. If you build with CSS logical properties from the start, use an RTL-aware component library, and include RTL in your design system, the marginal cost of RTL support in new features is near zero. Most of the work is in the initial architecture decisions. Once the foundation is correct, new components inherit RTL behavior automatically.

RTL covers the directional dimension of multilingual UX. But direction is only one axis of typographic complexity. The next subchapter moves to the other end of the spectrum: the CJK writing systems -- Chinese, Japanese, and Korean -- where the challenges are not about direction but about character width, word boundaries, line-breaking rules, and font systems that must handle tens of thousands of glyphs.