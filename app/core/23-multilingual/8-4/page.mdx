# 8.4 â€” Form Validation Across Locales: Names, Addresses, Dates, and Numbers

**The ASCII Name Gate** is the most common and most insulting form validation failure in multilingual products. It works like this: a developer writes a validation rule that accepts only characters in the range A through Z, maybe a through z, maybe a hyphen and an apostrophe. The validation "passes" during testing because the entire test team has names that fit within the English alphabet. The product ships. And then half the world's population discovers they do not exist.

Jose cannot sign up because the accent on the e is not in the ASCII range. Muller is rejected because the umlaut over the u is an unrecognized character. Bjork fails because the o with a stroke is not a "letter" according to the validation rule. And those are European names using Latin scripts with minor additions. Move beyond the Latin alphabet entirely and the gate becomes a wall. Arabic names, Chinese names, Cyrillic names, Devanagari names, Tamil names, Thai names -- all rejected. Not because the system can't store them. Modern databases handle Unicode perfectly. The rejection happens because someone wrote a validation rule that treats English as the universe of possible human names.

The damage is not just functional. It is personal. When a form tells a user that their name is invalid, it tells them that they are invalid. That their identity does not fit. That this product was not built for people like them. No amount of model quality, no depth of multilingual AI capability, can recover from an interface that rejects someone's name.

## Name Validation: The Field That Demands Humility

The only honest rule for name validation is this: you do not know what a valid name looks like. Any rule you write based on your cultural assumptions about names will be wrong for someone.

Names can contain characters from every Unicode script. Accented Latin characters are the starting point, not the edge case. Names in Arabic script flow right to left. Names in Chinese are typically two or three characters from a set of tens of thousands. Names in Devanagari, used across Hindi, Marathi, Nepali, and Sanskrit, use a script with complex combining characters. Names in Thai use tone marks above consonants. Names in Korean use Hangul syllable blocks that may look like single characters but are composed of two or three phonetic components. Every one of these is a perfectly valid name, and your form field must accept all of them.

Length assumptions are equally dangerous. Many Western systems impose a minimum name length of two or three characters. But single-character surnames exist in Chinese -- the character Ma, for instance, is one of the most common surnames in China, and it is one character. In some Indonesian cultures, people have a single name with no surname at all. The Indonesian president Sukarno had one name. A minimum-length rule of two characters rejects perfectly valid names from cultures with hundreds of millions of people. On the other end, some Polynesian, Sri Lankan, and South Indian names can exceed forty characters. A maximum-length field set to twenty characters -- common in form designs optimized for English-length names -- truncates real names.

Hyphenated names, names with apostrophes, and names with spaces within what a Western system considers a "first name" or "last name" all challenge standard validation. O'Brien has an apostrophe. Saint-Exupery has a hyphen. Mary Jane has a space in what she considers her first name. Nunes da Silva has a particle that is part of the surname but is lowercase and contains a space. Your validation must accept all of these.

The "first name, last name" field structure itself is culturally biased. In Chinese, Japanese, and Korean, the family name comes first and the given name comes second. In Hungarian and parts of East Asia, the order is similarly reversed from the English expectation. In Iceland, people use patronymic naming -- a person's "last name" is their father's first name plus "son" or "dottir," and it changes every generation, meaning a father and child have different "last names." In many Spanish-speaking countries, people use two surnames: one from their father and one from their mother. A form with two fields labeled "First Name" and "Last Name" cannot capture these naming structures without forcing the user to misrepresent their identity.

The practical solution is straightforward. For name input, accept any Unicode characters. Set a generous maximum length -- 100 characters is safe. Do not impose a minimum length. If you need to distinguish given name from family name, consider a single "Full Name" field or, at minimum, label the fields in a culturally neutral way. Never validate names against a character allowlist. The only characters that should be rejected in a name field are control characters and null bytes that could cause injection attacks. Everything else is someone's name.

## Address Validation: More Than Two Hundred Formats

There are more than two hundred address formats in use worldwide, and they differ in nearly every structural dimension. The US format of street number, street name, city, state, ZIP code is one format. The rest of the world does not use it.

Japanese addresses work from the largest geographic unit to the smallest, which is the opposite of the Western convention. A Japanese address starts with the prefecture, then the city, then the ward, then the district, then the block number, and finally the building number. There are no street names in most Japanese neighborhoods. The address identifies a location by its position within a numbered grid of blocks, not by a named street. A form that requires a "Street Address" field makes no sense for Japanese users, because their address does not contain a street name.

In the United Kingdom, the postcode comes before the city on the final line, and UK postcodes have a specific alphanumeric format that differs from US ZIP codes. German addresses place the postal code before the city name, with no state field. Brazilian addresses include a "complemento" field for apartment numbers, floor numbers, and building names that doesn't map neatly to the US concept of "Address Line 2." Indian addresses may include a landmark -- "near the railway station" or "opposite the temple" -- as a standard component of the address because street numbering in many Indian cities is inconsistent.

Some countries do not use postal codes at all. Ireland did not have a national postal code system until 2015, when Eircode was introduced, and many Irish addresses still rely on town names and geographic descriptions rather than codes. Several countries in Africa and the Middle East use P.O. box numbers instead of street addresses because street-level addressing infrastructure does not exist in all areas.

The fix is not to validate addresses against a single format. It is to use locale-aware address forms that adjust their field structure to match the country the user selects. Google's open-source address metadata library provides address format templates for every country, including the field order, required fields, and postal code format. When a user selects Japan, your form should present the fields in Japanese address order. When they select the United States, the form should present the US structure. When they select a country without postal codes, the postal code field should disappear.

If you are using AI to process addresses -- extracting addresses from documents, validating addresses in user messages, or generating address-aware content -- your AI pipeline must understand that address formats vary by country. An address parser trained primarily on US addresses will misparse Japanese addresses, UK addresses, and Indian addresses. Address parsing and validation are not tasks where one set of rules works globally.

## Date Validation: Ambiguity That Creates Real Errors

The number 03/04/2026 is genuinely ambiguous. In the United States, it means March 4, 2026. In the United Kingdom, Germany, France, India, and most of the world, it means April 3, 2026. In Japan, China, and Korea, the conventional format would be 2026/04/03 or 2026-04-03, with the year first. This is not a display preference. It is a data integrity issue.

When your form accepts a date as a freeform string and does not know the user's locale, you cannot parse the date correctly. If a British user enters "03/04/2026" meaning April 3, and your system parses it as March 4, you have a silent data error that may never be caught. In a scheduling application, this means meetings booked on the wrong day. In a healthcare application, this means medications scheduled for the wrong date. In a financial application, this means transactions recorded against the wrong period. The consequences range from inconvenient to dangerous.

The solution is twofold. For user-facing date input, use a date picker component that renders the date in the user's locale format but stores the date in an unambiguous format -- ISO 8601, which writes 2026-04-03 with no ambiguity about which number is the month and which is the day. When the user sees "03/04/2026" in their local format, they know it means April 3 because that is how they read dates. When the system stores "2026-04-03," there is no ambiguity.

For AI-processed dates -- dates extracted from user messages, documents, or other inputs -- your parsing logic must be locale-aware. If the user's locale is en-US, "03/04/2026" means March 4. If the user's locale is en-GB, it means April 3. If the locale is ambiguous, you have three options: ask the user to clarify, default to ISO 8601 format in the system's prompts and outputs, or present the parsed date back to the user for confirmation before acting on it. The worst option is to silently assume one interpretation without telling the user.

Time formats add another layer. The United States uses 12-hour time with AM and PM. Most of Europe, Latin America, East Asia, and Africa use 24-hour time. "3:30 PM" is natural to an American user and awkward to a German user who expects "15:30." Display times in the format the user's locale expects, and store them in 24-hour format or as UTC timestamps internally.

## Number Validation: When a Period Is Not a Period

In the United States and the United Kingdom, the decimal separator is a period and the thousands separator is a comma. The number one thousand two hundred thirty-four and fifty-six hundredths is written 1,234.56. In Germany, France, Spain, and much of Europe, the decimal separator is a comma and the thousands separator is a period. The same number is 1.234,56. In Switzerland, the thousands separator is an apostrophe: 1'234.56. In India, the grouping pattern is different: 1,23,456.78 groups after the thousands place in pairs rather than triples.

If your form accepts a numeric input as a freeform string, the value "1.000" means one thousand in Germany and one point zero zero zero in the United States. If your parsing logic does not know the user's locale, it will parse the number incorrectly. In financial applications, this means transactions for the wrong amounts. In scientific applications, this means measurements off by orders of magnitude. In AI products that process numerical data from user input, this means the model receives incorrect numbers in its context, corrupting every downstream calculation.

The fix involves multiple layers. For numeric input fields, use locale-aware number formatting and parsing. The browser's Internationalization API provides locale-aware number formatting out of the box. When the user types a number, parse it according to their locale's conventions, then store it as a locale-independent numeric value. When displaying numbers back to the user, format them according to their locale.

For AI-processed numbers -- values extracted from user messages, documents, or conversations -- your extraction logic must be locale-aware. If a French user writes "the budget is 1.500,00 euros," the value is one thousand five hundred euros, not one and a half euros. If your number extraction uses a parser that assumes US formatting, every European number with a period as a thousands separator will be parsed incorrectly.

Currency formatting adds another dimension. The position of the currency symbol, the use of spaces, and the symbol itself vary by locale. In the United States, the dollar sign precedes the number with no space: $1,234.56. In France, the euro sign follows the number with a non-breaking space: 1 234,56 followed by the euro symbol. In Japan, the yen sign precedes the number with no separator for amounts under ten thousand. Your display layer must format currency according to the user's locale, not your system's default locale.

## Phone Number Validation: Abandon Regex, Use a Library

Phone numbers are one of the most commonly misvalidated form fields because teams attempt to validate them with regular expressions. The problem is that phone number formats vary by country in ways that no reasonable regex can capture.

US phone numbers are ten digits in the format of a three-digit area code followed by a seven-digit number. UK phone numbers are ten or eleven digits depending on the area code, with different lengths for London, mobile, and regional numbers. Indian phone numbers are ten digits starting with specific digits. Japanese phone numbers vary from nine to eleven digits depending on whether they are landline or mobile and which area code applies. Chinese phone numbers are eleven digits for mobile and vary for landline. German phone numbers have variable-length area codes and variable-length subscriber numbers, making the total length unpredictable.

A regex that validates US phone numbers will reject valid UK numbers. A regex that validates ten-digit numbers will reject valid Japanese and German numbers. A regex that enforces a specific format like parenthesis-area-code-parenthesis-space-prefix-dash-line will reject valid numbers from every country that does not use that format, which is every country except the United States.

The solution is to use Google's libphonenumber library or one of its ports to other languages. Libphonenumber contains validation rules for phone numbers in every country, including variable-length rules, valid area code ranges, and format specifications. It can parse phone numbers from any format, validate them against the rules for their country, and format them into the standard E.164 international format -- a plus sign followed by the country code and subscriber number with no spaces, parentheses, or dashes. The E.164 format is unambiguous, machine-readable, and universally valid.

For your AI product, store all phone numbers in E.164 format internally. Accept user input in any format -- with or without country codes, with or without dashes, with spaces or parentheses or dots. Use libphonenumber to parse the input, determine the country, validate the number, and convert it to E.164. Display the number back to the user in the format their locale expects. This approach handles every country, every format, and every edge case.

The broader principle applies to every form field discussed in this subchapter: never write your own validation rules for international data. The world has already standardized these rules in well-maintained libraries. Your job is to use them.

## Email Address Validation: Internationalized Domain Names and Beyond

Email validation is another field where naive regex fails internationally. The standard for internationalized email addresses allows Unicode characters in both the local part (before the at sign) and the domain part (after the at sign). An email address with Chinese characters in the local part and a Chinese domain name is a valid email address under current standards. An address with Arabic characters, Cyrillic characters, or Devanagari characters is equally valid.

Most email validation regexes reject these addresses because they only accept ASCII characters. Even the HTML5 input type for email validates against an ASCII-only pattern. If your audience includes users who use internationalized email addresses -- and the Universal Acceptance Steering Group has been working since the mid-2010s to drive adoption of these addresses across the internet -- your validation must handle them.

The practical reality as of 2026 is that internationalized email addresses remain relatively rare compared to ASCII addresses, but adoption is growing in markets where the local script is non-Latin. The safest approach is permissive validation: check for the presence of an at sign, check that there is text on both sides, and then attempt to deliver to the address. Over-validating email addresses is a solved problem -- the solution is not to over-validate.

## The Unifying Principle: Validate for Structure, Not for Culture

Across names, addresses, dates, numbers, phone numbers, and email addresses, one principle unites all the correct approaches: validate that the input has the right structure, not that it matches your cultural expectation of what the content should look like.

A name should be a string of Unicode characters of reasonable length. An address should contain the fields required by the country the user selected. A date should parse unambiguously into a calendar date. A number should parse into a numeric value according to the user's locale. A phone number should validate against the rules for its country. An email should have the structural components of an email address. None of these validations require you to know what the content "should" look like. They only require you to confirm that the content has the right shape.

The moment you move from structural validation to cultural validation -- this name should only contain these characters, this phone number should be exactly this many digits, this date should be in this format -- you are encoding your culture's assumptions into your software. And those assumptions will reject valid input from every culture that does not share them.

## Testing Locale Validation: The Name List and the Format Matrix

Testing form validation across locales requires deliberate effort because the failures are invisible to testers who share the developer's cultural context. An all-English QA team will never encounter the ASCII Name Gate because their names pass it.

Build a test name list that covers every script your product supports. Include names with accented Latin characters, names in Arabic script, Chinese characters, Cyrillic, Devanagari, Hangul, Thai, and Tamil. Include single-character names, hyphenated names, names with apostrophes, names with spaces in the middle, and names that exceed twenty characters. Run every name through your form's validation. Any rejection is a bug.

Build a format matrix for dates, numbers, and phone numbers that covers your target locales. For each locale, define the expected input format and the expected parsed result. Enter the locale-formatted value into your form and verify that the system parses it correctly. "03/04/2026" entered by a user in the en-GB locale must parse as April 3. "1.234,56" entered by a user in the de-DE locale must parse as one thousand two hundred thirty-four and fifty-six hundredths. Any misparsing is a data integrity bug that will propagate through your entire system.

Automate these tests. They are perfectly suited to automation because the inputs and expected outputs are deterministic. Run them on every code change that touches form validation, date parsing, number formatting, or phone number handling. Form validation regressions are easy to introduce -- a developer who doesn't know about locale-specific number formatting might "fix" a bug by enforcing US-style decimal separators, breaking the form for every European user.

## The AI-Specific Challenge: When the Model Is the Form

In traditional web applications, form validation is a frontend concern. The user fills in a form, the frontend validates the input, and the backend processes it. In AI products, the model itself is often the form. The user types their name, address, date, or phone number into a conversational interface, and the model extracts and processes the structured data.

This means your model must be at least as locale-aware as a well-designed form. If a user tells the chatbot "my appointment is on 03/04," the model must know the user's locale to parse the date correctly. If a user says "my number is 0171 234 5678," the model must recognize this as a German mobile number format, not an invalid US number. If a user spells their name in Arabic script within an otherwise English conversation, the model must capture the name exactly as written, including all diacritics and combining characters.

The system prompt should specify the user's locale when known, so the model can apply the correct parsing conventions. When the locale is unknown, the model should ask for clarification rather than guess -- "I want to confirm: is that date March 4 or April 3?" is a much better experience than silently parsing the date in the wrong format and scheduling the appointment for the wrong day.

Form validation across locales is where the rubber of internationalization meets the road of real user data. The next subchapter moves from structured input to unstructured input, tackling the problem of automatically detecting what language a user is communicating in -- and why that detection fails in ways that can derail an entire conversation.