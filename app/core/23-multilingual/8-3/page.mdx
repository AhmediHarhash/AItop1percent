# 8.3 â€” CJK Typography and Text Layout Constraints

Your interface was designed for a language where words are separated by spaces and text flows in one direction. Chinese, Japanese, and Korean break both of those assumptions -- and a dozen others you probably haven't considered. Spaces between words, the fundamental unit that your layout engine uses to decide where to wrap a line, where to highlight a search result, where to insert a hyphen, and where a user's double-click selection should start and end -- none of that works the same way in CJK text. And the typographic rules for these writing systems are not simplified versions of Latin rules. They are distinct, sophisticated systems with their own centuries of convention, their own edge cases, and their own expectations from readers who will immediately notice when something is wrong.

The combined audience is staggering. Chinese has over 1.1 billion speakers. Japanese has 125 million. Korean has 80 million. Together, roughly 1.3 billion people use writing systems that your English-optimized interface was not designed to handle. If you serve any market in East Asia -- and in 2026, most global AI products do or intend to -- CJK typography is not a special case. It is a primary requirement.

## No Word Spaces: The Foundational Difference

English text is a sequence of words separated by spaces. Chinese and Japanese text is a continuous stream of characters with no spaces between words. Korean uses spaces between some grammatical units (words and particles) but with different conventions than English, and many Korean compound expressions appear without spaces. This single difference -- the absence of word-delimiting spaces -- cascades through every text-handling feature in your interface.

**Line wrapping.** In English, the layout engine wraps text at space boundaries. In Chinese and Japanese, the engine can wrap between almost any two characters, because there are no spaces to guide the decision. But "almost any" is the operative phrase. CJK line-breaking is governed by a set of rules, called kinsoku shori in Japanese, that specify which characters can and cannot appear at the beginning or end of a line. An opening quotation mark cannot end a line. A closing quotation mark cannot begin a line. A comma, period, or other punctuation mark cannot begin a line. A small kana character (like the small "tsu" in Japanese) cannot begin a line. These rules prevent visually and semantically incorrect breaks, and violating them produces text that looks unprofessional to native readers.

If your layout engine does not implement CJK line-breaking rules, your text will break at points that look wrong. A closing parenthesis at the start of a line. A comma dangling at the beginning of a new line. A small kana character orphaned from the character it modifies. These breaks are the CJK equivalent of splitting the word "together" as "togeth-" and "er" in English -- technically the text is all there, but it looks broken. Native CJK readers notice immediately, and their assessment of your product's quality drops with every bad break.

**Text selection and highlighting.** When a user double-clicks a word in English, the browser selects the word by finding the space boundaries on either side. In Chinese and Japanese, there are no space boundaries. Double-click selection must use a word segmentation algorithm (similar to the algorithms used in search engines and input methods) to guess where word boundaries fall. If your interface uses standard browser behavior without additional configuration, double-click selection in Chinese and Japanese may select a single character, a random run of characters, or an entire line -- none of which matches the user's expectation of selecting a "word."

**Search highlighting.** When your search feature highlights matching terms in a document, the highlighting algorithm needs to find the match boundaries in continuous text. In English, matching "learning" in a document is straightforward because the word is space-delimited. In Chinese, the same concept might be two characters embedded in a longer string of characters with no boundaries. Your highlighting must correctly identify and highlight just the matching characters without extending the highlight to adjacent characters or splitting compound terms.

## Character Width: Full-Width Meets Half-Width

CJK characters are full-width: each character occupies a roughly square cell, twice the width of a Latin character. When CJK text appears alongside Latin text -- which happens constantly in AI products, where model output may mix Chinese explanation with English technical terms, product names, or numerical values -- the visual rhythm breaks.

A line of Chinese text has a consistent, even spacing because every character has the same width. When an English word appears mid-sentence, the half-width Latin characters create a visual gap that disrupts the rhythm. The line height might not accommodate the different vertical metrics of the Latin font. The baseline alignment between CJK and Latin characters might be off. The result is text that looks technically correct but visually inconsistent.

The solution is deliberate typographic design for mixed-script text. CJK typographic conventions call for a small space (roughly one-quarter of a full-width character) to be inserted between CJK characters and adjacent Latin characters or numbers. This space creates a visual separation that acknowledges the script switch rather than pretending the two scripts have compatible spacing. Modern CSS supports this through the text-autospace property, and several browser engines implement automatic CJK-Latin spacing. If your browser targets don't support text-autospace, your rendering pipeline should insert thin spaces at script-switch boundaries.

Full-width punctuation is another dimension. Chinese and Japanese traditionally use full-width punctuation marks: full-width periods, commas, quotation marks, and parentheses that match the width of CJK characters. Korean typically uses proportional (half-width) punctuation followed by a space, similar to Latin conventions. If your model generates Chinese text with half-width punctuation (which frontier models sometimes do, especially when the system prompt is in English), the punctuation looks cramped and out of place. Your post-processing pipeline should normalize punctuation to the correct width convention for the target language.

## Vertical Text: When Direction Isn't Just Left or Right

The previous subchapter covered right-to-left as a direction challenge. CJK introduces a third direction: top-to-bottom, with columns flowing from right to left. Traditional Japanese and Chinese text is written vertically. While most modern digital content in these languages uses horizontal layout, vertical text remains important in specific contexts: poetry, literary content, traditional-style documents, signage, book covers, and certain formal communications.

If your AI product generates content for any of these contexts -- a Japanese literary analysis tool, a Chinese calligraphy assistant, a design tool that creates signage or posters -- you need vertical text support. Even if your primary interface is horizontal, generated content may need to render vertically for cultural authenticity.

CSS supports vertical text through the writing-mode property. Setting writing-mode to vertical-rl produces top-to-bottom text with columns flowing right-to-left, which is the traditional CJK vertical layout. When writing mode changes to vertical, the entire spatial logic rotates: what was "left margin" becomes "top margin," what was "line height" becomes "column width," and what was "text-align left" becomes "text-align top."

The practical implication for most AI products is limited but worth knowing. If you serve Japanese or Chinese markets and your product involves any content display beyond chat responses -- document rendering, content generation, formatting tools -- vertical text is a capability you should be aware of. You may not need it on day one, but when a Japanese enterprise customer asks why your document rendering tool cannot display traditional-format text, you should know the answer and the path to supporting it.

## Ruby Text: Pronunciation Guides in Japanese

Japanese uses three scripts simultaneously: kanji (Chinese-derived characters with meaning), hiragana (a phonetic script), and katakana (another phonetic script, used primarily for foreign words). Many kanji characters have multiple readings, and even literate Japanese adults occasionally encounter unfamiliar kanji. The solution, used for centuries in Japanese publishing, is ruby text: small phonetic characters (called furigana) placed above or beside the kanji they annotate.

Ruby text is not decorative. It is a core reading aid in Japanese. Children's books use furigana extensively. Newspapers use it for unusual names and rare characters. Official documents use it to disambiguate readings of names and places. If your AI product generates Japanese text that includes uncommon kanji -- and model outputs frequently do, because models draw from training data that spans formal, literary, and technical registers -- users may need furigana to read the output correctly.

The rendering challenge is significant. Ruby text occupies space above the base text, which means the effective line height for text with furigana is roughly 1.5 times the line height of text without it. If your layout assumes a fixed line height, furigana will either overflow into the line above (producing overlapping text) or be clipped (producing invisible pronunciation guides). Your CSS must account for ruby text by using sufficient line-height values for Japanese content and ensuring that ruby annotations don't collide with adjacent lines.

HTML provides the ruby element specifically for this purpose, and CSS ruby layout controls the positioning and sizing of annotations. But many AI product interfaces render model output as plain text or basic Markdown, neither of which supports ruby markup. If your product needs furigana support, your rendering pipeline must either generate ruby-annotated HTML from the model output or provide a user-togglable furigana layer that adds pronunciation annotations on demand.

For most AI products serving Japanese users, ruby text support is a differentiator rather than a requirement. But it is the kind of differentiator that signals to Japanese users that the product was designed with genuine understanding of their writing system, not just translated from English.

## Font Requirements: When a Font Is Fifty Thousand Characters

A Latin font typically contains a few hundred glyphs. A complete CJK font contains anywhere from 20,000 to over 50,000 glyphs, approaching the limits of current font format specifications. This difference in glyph count has a direct and measurable impact on performance.

A Latin web font in WOFF2 format might be 20 to 50 kilobytes. A CJK web font in WOFF2 can be 2 to 8 megabytes -- or significantly more for comprehensive fonts that cover all CJK unified ideographs, regional variants, and supplementary characters. Loading an 8-megabyte font file on a mobile connection in rural Indonesia or inland China is a user experience disaster: the text either doesn't render until the font loads (producing a blank page or invisible text for seconds), or it renders in a fallback font that may not support all required characters (producing missing-glyph boxes where characters should be).

The standard solution is font subsetting: serving only the glyphs the page actually needs rather than the entire font. Google Fonts pioneered this approach for CJK by splitting Noto Sans CJK into over 100 subset files organized by Unicode range, serving only the subsets that contain characters present on the page. This reduces the initial download to a few hundred kilobytes in most cases, with additional subsets loading on demand as the user scrolls to content that requires them.

For AI products, where model output is dynamic and unpredictable, font subsetting is more complex than for static websites. You cannot predict which characters the model will use in its response. The most robust approach is to use a tiered font loading strategy. First, load a subset containing the 3,000 to 5,000 most common characters for the target language -- this covers roughly 99 percent of everyday text in Chinese and 97 percent in Japanese. Second, load additional subsets on demand when the rendered text contains characters outside the initial subset. Third, fall back to a system font for the rare characters that even the extended subsets don't cover.

Variable fonts offer another optimization path. The full set of static Source Han Sans fonts (the open-source CJK font family used as the basis for Google's Noto Sans CJK) exceeds 590 megabytes across all weights and regional variants. The equivalent variable font packaged as a single file is roughly 33 megabytes, and with subsetting, the initial download can be brought under one megabyte for common-character coverage. As of 2026, about 42 percent of variable font usage on the web comes from CJK families, reflecting the enormous performance benefit of variable fonts for large character sets.

**Regional font variants** add a final layer of complexity. The same Unicode character may have different standard visual forms in different CJK regions. The character for "bone" looks slightly different in simplified Chinese, traditional Chinese, Japanese, and Korean. Fonts like Noto Sans CJK and Source Han Sans include regional variants and use OpenType language tags to select the correct glyph for each locale. If your font is configured for Japanese but your content is simplified Chinese, some characters will display in their Japanese variant, which Chinese readers will perceive as incorrect. Make sure your font configuration matches the content locale, not just the interface locale.

## Text Expansion and Contraction: The Layout Surprise

Most teams know that German text is longer than English text. Fewer teams know that CJK text is often shorter -- sometimes dramatically so.

Chinese and Japanese pack more meaning into fewer characters than English. A sentence that takes 100 characters in English might take 40 to 60 characters in Chinese. This means layouts designed for English text length will have excessive whitespace when displaying CJK content. Cards that look balanced with English text will feel empty with Chinese text. Paragraph blocks that fill a section in English will leave awkward gaps in Japanese. The problem is the mirror image of the German text expansion problem, but it's less discussed and equally damaging to visual quality.

Korean behaves differently from Chinese and Japanese. Korean text length is often comparable to English, and in some cases longer, because Korean syllable blocks and grammatical particles add length that Chinese characters compress. A layout that assumes "CJK is always shorter" and reduces container sizes accordingly will find that Korean overflows.

The practical solution is the same one that solves text expansion for German and Finnish: never hardcode container dimensions for a specific language's text length. Use flexible layouts that adapt to content length. Set minimum and maximum widths rather than fixed widths. Allow text blocks to grow and shrink naturally. Test your layouts with real content in your target CJK languages, not with placeholder text, because the visual balance differences between English and CJK content are significant enough to affect the overall feel of the interface.

For AI products specifically, where model output length varies from response to response, this means your chat interface, response cards, summary panels, and content display areas must handle the full range: a long German response that is 35 percent longer than the English equivalent, and a Chinese response that is 40 percent shorter. If your layout looks good only with English-length text, it will look wrong in every other language in a different way.

## Putting CJK Support Into Practice

CJK typography support is not a single feature you implement once. It is a set of decisions woven through your design system, your rendering pipeline, your font loading strategy, and your testing process.

Start with font infrastructure. Choose a CJK font family that supports all your target regions, implement subsetting and tiered loading, configure regional variants correctly, and measure font loading performance on representative network connections in your target markets. A product that takes six seconds to render readable text on a mobile connection in Osaka has lost its user before the model even generates a response.

Then address line breaking. Ensure your layout engine implements CJK line-breaking rules. Most modern browsers handle this correctly with the CSS word-break and overflow-wrap properties, but custom text rendering components (canvas-based displays, virtual scrolling lists, PDF generation) may need explicit line-breaking logic.

Address mixed-script typography. When your model generates text that mixes CJK with Latin characters, numbers, or punctuation from other scripts, the rendering should handle script transitions gracefully: appropriate spacing between CJK and Latin, correct punctuation width, consistent baseline alignment.

Finally, test with native readers. The gap between "technically renders correctly" and "looks right to a native reader" is substantial in CJK typography. A Japanese user will notice incorrect furigana spacing, bad line breaks, and wrong punctuation width in the same way an English reader would notice text set in Comic Sans for a medical application. The technical failure may be minor. The trust impact is not.

The previous two subchapters covered the two major directional and typographic systems that diverge from the English assumptions built into most interfaces. The next subchapter turns to a different category of UX failure: form validation -- the point where your interface decides whether a user's name, address, date, and phone number are "valid," and where culturally narrow validation rules reject perfectly real people.