# 8.8 â€” Mixed-Script Interface Edge Cases

When your interface displays text in multiple scripts simultaneously -- Latin, Arabic, CJK, Devanagari -- layout rules conflict. Each script has its own baseline, character width, line height, and direction. A line of English text sits at one vertical position. A line of Japanese text sits at another. A line of Arabic text flows in the opposite direction. Put all three on the same screen -- in the same table row, the same notification, the same user list -- and you discover that the typographic assumptions baked into your design system were never assumptions at all. They were constraints tied to a single script, and they break the moment a second script appears.

This is not a theoretical concern for niche products. Any AI product that serves a global user base will encounter mixed-script interfaces. A customer relationship management system shows contact names in Arabic, Japanese, and English in the same list. An enterprise AI dashboard displays analysis results from documents in multiple languages. A multilingual chatbot shows conversation history where the user typed in Hindi and the AI responded in English. A team collaboration tool lists contributors whose names span four different scripts. The question is not whether your interface will display mixed scripts. The question is whether it will display them well or badly.

## Baseline Alignment: Why Mixed-Script Text Looks Jagged

Every writing system has an invisible reference line -- the **baseline** -- on which characters sit. In Latin text, the baseline is the line that the bottom of letters like "a," "b," and "x" rest on, with descenders like "g" and "p" dropping below it. Latin baselines are what most Western designers internalize without thinking about them.

CJK characters do not sit on the same baseline. Chinese, Japanese, and Korean ideographs are designed to fill a uniform square called the em box. The visual center of a CJK character is higher than the visual center of a Latin lowercase letter at the same font size. When Latin and CJK text appear on the same line -- a Japanese user's name followed by an English email address -- the CJK characters appear to float slightly above the Latin text. The baseline mismatch is subtle at larger sizes but becomes visibly jarring at the text sizes commonly used in tables, lists, and notification banners.

Arabic text has a different baseline problem. Arabic is a cursive script where letters connect, and the connecting strokes create a visual baseline that shifts depending on the letter combination. Arabic letters also have dots and diacritical marks above and below the baseline that require more vertical space than Latin text. When Arabic and Latin text appear on the same line, the Arabic text needs more vertical room, and the baselines of the two scripts do not naturally align.

Devanagari, used for Hindi, Sanskrit, and other South Asian languages, uses a characteristic horizontal line called the headline that runs along the top of the characters. The visual weight of Devanagari text sits higher than Latin text at the same size, creating a top-heavy appearance when the two scripts share a line.

The fix is not trivial but it is well-understood. CSS provides the vertical-align property and the more granular alignment-baseline and dominant-baseline properties for SVG and inline content. For mixed-script table cells and list items, setting the dominant baseline to "central" or "middle" rather than "alphabetic" produces more visually balanced alignment across scripts. Some design systems use per-script font size adjustments -- rendering CJK text at 95 percent of the Latin font size, or Latin text at 105 percent of the CJK font size -- to achieve optical parity. The specific ratios depend on your font choices, but the principle is universal: mixed-script text requires active baseline management. The browser's default alignment, which assumes a single script, will not produce acceptable results.

## Line Height: The Silent Layout Breaker

CJK characters are taller than Latin lowercase characters at the same font size. Arabic with full diacritical marks (tashkeel) requires more vertical space than unvoweled Arabic. Devanagari's headline and descenders demand generous line height. Thai, with its stacking vowels and tone marks, can require even more vertical space than Devanagari.

When your product sets a single line-height value across the interface -- 1.5, for example, which works well for Latin text -- that value may be insufficient for other scripts. CJK text at line-height 1.5 can appear cramped because the characters fill more of the vertical space. Arabic with diacritics at line-height 1.5 may clip the marks above and below the letters. Thai at line-height 1.5 will almost certainly have overlapping tone marks.

The problem compounds in mixed-script contexts. A chat message where the user wrote in Thai and the AI responded in English needs different line heights for each message -- or a single line height generous enough to accommodate the most demanding script. Setting the line height to 1.8 or 2.0 globally accommodates all scripts but creates excessive spacing in Latin-only text, making English content feel sparse and disconnected.

The practical solution is context-aware line height. If you can detect the script of each text block -- and in an AI product, you usually can because you know the language of the user's input and the AI's output -- you can apply script-specific line heights. A system that sets line-height to 1.5 for Latin text, 1.7 for CJK, 1.8 for Arabic with diacritics, and 2.0 for Thai produces visually appropriate spacing for each script without wasting vertical space in Latin contexts. The detection does not need to be perfect. A simple check for the Unicode range of the first few characters in each text block is sufficient to classify it and apply the correct line height.

## Font Fallback: No Single Font Covers Everything

No single font file contains glyphs for every writing system. A font designed for Latin text does not include CJK ideographs. A font designed for Japanese does not include Arabic letter forms. A font designed for Arabic does not include Devanagari characters. When the browser encounters a character that the current font cannot render, it falls back to the next font in the font stack. If no font in the stack covers the character, the browser displays a replacement glyph -- the infamous empty rectangle, often called "tofu," that signals a missing character.

In a mixed-script interface, font fallback is not optional. It is the mechanism that makes mixed-script display possible. Your font stack must include fonts that cover every script your product might display. A typical stack for a globally-facing AI product might list a Latin font first, followed by a CJK font for Chinese, Japanese, and Korean, followed by an Arabic font, followed by a Devanagari font, followed by a system fallback.

The challenge is visual consistency. Each font in the stack was designed independently, with different stroke weights, different proportions, different aesthetic sensibilities. A Japanese name rendered in Noto Sans JP next to an English label rendered in Inter next to an Arabic description rendered in IBM Plex Arabic creates a visually heterogeneous line. The three fonts may have different x-heights, different stroke thicknesses, and different character proportions. The text is readable, but it does not look like it belongs together.

The Noto font family from Google was designed specifically to solve this problem. Noto provides harmonized fonts for over 150 scripts, all designed to work together with consistent stroke weight, proportions, and baseline alignment. Using Noto as your font stack's foundation does not guarantee perfect visual harmony -- the task of making Latin, Arabic, and CJK text look like a unified design is inherently challenging -- but it eliminates the worst inconsistencies. For products where visual polish matters, Noto is the starting point, supplemented with script-specific fonts where Noto's aesthetic does not match your brand.

Font loading performance is the secondary concern. Each font file adds to page load time. A CJK font file can be 5 to 20 megabytes because of the sheer number of glyphs. Arabic and Devanagari fonts are smaller but still add latency. The solution is unicode-range subsetting in your font-face declarations, which tells the browser to download a font file only when characters in that Unicode range actually appear on the page. If a page contains no CJK characters, the CJK font never loads. This approach keeps page weight proportional to the actual script diversity on each page.

## Text Direction: Bidirectional Layout Complexity

Subchapter 8.2 covered right-to-left layout in depth. Mixed-script interfaces encounter a compounded version of that challenge: **bidirectional text** (bidi text) where multiple text directions appear on the same line.

Consider a notification: "Meeting with Ahmed scheduled for Tuesday." If "Ahmed" is an Arabic name rendered in Arabic script, the line contains a left-to-right segment ("Meeting with"), a right-to-left segment (the Arabic name), and another left-to-right segment ("scheduled for Tuesday"). The Unicode Bidirectional Algorithm (UBA) handles this reordering automatically in most rendering engines, but the results are not always what you expect.

Punctuation creates the most common bidi failures. A period, comma, or parenthesis at the boundary between RTL and LTR text can end up on the wrong side. An opening parenthesis before an Arabic word may render after the word because the bidi algorithm reordered the directional segments. Quotation marks around an RTL phrase may appear inverted. These failures are individually small but collectively create an interface that feels broken to bilingual users who are sensitive to these details.

The fix is explicit direction markup. HTML provides the dir attribute and the bdi element (bidirectional isolation) to wrap text segments that have a known direction. When you insert a user's name into a template, wrap it in a bdi element so the browser isolates its directionality from the surrounding text. When you display a list that mixes RTL and LTR names, set the dir attribute on each list item based on the script of the name. These are small additions to your rendering logic, but they prevent the bidi algorithm from making incorrect assumptions about text direction.

## Sorting and Collation: Whose Alphabet Comes First

When a mixed-script interface displays a sortable list -- a contact directory, a document list, a user roster -- the sorting order must be defined. Do Arabic names come before or after Latin names? Where do CJK names appear? What about names in Cyrillic or Devanagari?

The Unicode Collation Algorithm (UCA) provides a standardized answer: it defines a default sort order for all Unicode characters across all scripts. In the default UCA order, Latin characters are grouped together, followed by Greek, Cyrillic, Armenian, and so on, with CJK ideographs appearing later in the sequence. This default order is consistent and predictable, but it may not match user expectations.

A Japanese user viewing a contact list expects Japanese names to be sorted by their reading (phonetic pronunciation in kana), not by the Unicode codepoint of the kanji characters. But the UCA does not know the reading of a kanji character without additional data. The character for "Tanaka" and the character for "Yamamoto" might sort differently based on their Unicode codepoints than they would based on their phonetic readings. Japanese sorting requires a reading annotation (furigana or yomigana) for each name, which is an additional data field that your product must collect and store.

Chinese sorting has the same complexity. Characters can be sorted by stroke count, by radical (the component that categorizes the character), or by pinyin pronunciation. Different users expect different orders, and the "correct" order depends on context and regional convention.

The practical approach for mixed-script lists is to provide a locale-aware default sort with the option for users to customize. The default sort for a Japanese user groups Japanese names first (sorted by reading), followed by other scripts in UCA order. The default sort for a German user groups Latin names first (sorted by German collation rules, where umlauts sort with their base letters), followed by other scripts. The user can switch to a universal sort that applies UCA order uniformly, or to a script-grouped sort that visually separates names by script.

Implementing locale-aware sorting requires the Intl.Collator API (in JavaScript environments) or the ICU library (in server-side languages). The key is to never sort Unicode strings using raw codepoint comparison. Raw codepoint sorting puts uppercase before lowercase, accented characters after all unaccented characters, and produces results that no user in any language would recognize as a natural sort order.

## Search and Highlighting in Mixed-Script Content

When a user searches for text in a mixed-script interface, the search must work across scripts and the highlighting must render correctly regardless of the script of the matched text.

**Cross-script search matching.** A user searches for "Tanaka" using Latin characters. The system should match the kanji form of the name if a romanization mapping exists. Conversely, a user searching in kanji should match results that are stored with Latin transliterations. This cross-script matching requires either indexed transliterations (storing both the original script and a romanized version) or a transliteration layer in the search pipeline that normalizes all text to a common representation before comparison.

**Highlighting in bidirectional text.** When the search term spans or sits adjacent to a direction boundary, the highlight styling must not break the bidirectional layout. A highlighted Arabic word within an English sentence should maintain its RTL direction inside the highlight span. The highlight's background color or border should visually mark the matched text without disrupting the text flow. This means the highlight element must use the bdi isolation approach to prevent the highlight span from interfering with the surrounding bidi context.

**Diacritic-insensitive matching.** A search for "resume" should match "resume" and also "r\u00e9sum\u00e9." A search for "uber" should match "\u00fcber." A search for an Arabic word without diacritical vowels should match the same word with full tashkeel. The Intl.Collator API supports sensitivity options that control whether diacritics, case, and other variations affect matching. Set the sensitivity to "base" for the most forgiving search behavior, which treats accented and unaccented characters as equivalent.

**CJK tokenization in search.** CJK text does not use spaces between words. A Chinese sentence is a continuous string of characters, and "words" are identified by context and convention, not by whitespace. Searching for a two-character Chinese term within a longer string requires character-level matching, not word-level matching. Japanese adds complexity because a single word might be written in kanji, hiragana, or katakana, and all three forms should match the same search query. Your search index must support CJK tokenization -- either through a CJK-aware analyzer or through n-gram indexing that captures character sequences.

## Testing Mixed-Script Interfaces

Testing mixed-script display requires a deliberate strategy because the failures are visual, not logical. Your automated tests will pass -- the data is correct, the API returns the right response, the string is present in the DOM -- but the text renders illegibly on screen.

**Visual regression testing across script combinations.** Render each interface component with test data that includes names and text in Latin, Arabic, CJK, and Devanagari. Capture screenshots and compare them against baseline images. Any pixel difference flags a potential rendering issue. Run these tests in your CI pipeline on every change to layout code, font configuration, or resource files.

**Manual inspection with native readers.** Automated visual regression catches layout breaks but cannot judge readability. Have native readers of each script inspect the interface and report whether the text is readable, naturally laid out, and visually coherent alongside other scripts. A CJK reader can tell you whether the Japanese text in a mixed-script table feels cramped, oversized, or misaligned in ways that a pixel-level comparison might miss.

**Edge case data sets.** Build a test data set that includes the hardest mixed-script cases: very long German compound words next to single-character Chinese names. Arabic names with full diacritics next to Thai text with stacking tone marks. Japanese text mixing kanji, hiragana, katakana, and embedded English abbreviations. Korean names alongside Devanagari. The more scripts you combine in a single view, the more layout assumptions break. Your test data should stress every combination your product could encounter in production.

**Performance testing with font loading.** Measure page load time when mixed-script content triggers downloads of multiple font files. A page that loads in 1.2 seconds with Latin-only content but takes 4.5 seconds when CJK fonts are needed has a performance problem that will disproportionately affect users in Asia. Unicode-range subsetting, font preloading for likely scripts based on the user's locale, and progressive font loading strategies can reduce this gap.

## The Compounding Cost of Ignoring Mixed Scripts

Mixed-script display issues rarely cause immediate abandonment the way a fully broken RTL layout does. Instead, they create a persistent undercurrent of visual friction. The jagged baselines, the inconsistent font weights, the cramped line heights, the oddly sorted lists -- each one is minor. Together, they create an interface that feels unpolished, unprofessional, and unreliable to multilingual users. These users are often your most sophisticated and most valuable customers, precisely because they operate across language boundaries.

An enterprise team evaluating your AI product for global deployment will test it with their real data -- which includes names, documents, and content in multiple scripts. If the interface handles this data awkwardly, they will not file a bug report. They will move to a competitor whose product looks like it was built for their reality.

Getting mixed-script display right is not about perfection. It is about demonstrating that your product was designed with awareness that the world writes in more than one script. Baseline alignment, line height management, font fallback, bidi handling, locale-aware sorting, and cross-script search are not luxury features. They are the baseline expectation of any product that claims to serve a global audience.

Mixed-script interfaces address what the user sees. But the challenge of multilingual interaction begins even earlier -- at the point of input. Different writing systems require radically different approaches to typing, composing, and entering text. The next subchapter covers input methods, virtual keyboards, and the composition-based text entry that Chinese, Japanese, and Korean users rely on, and what that means for AI products that offer real-time suggestions.