# 7.10 â€” Prompt Template Architecture for Multilingual Products

A single monolithic prompt that handles all languages is a maintenance nightmare. A per-language fork of every prompt is worse. The monolithic approach collapses under the weight of conflicting instructions: the formality directive that works for Japanese contradicts the one that works for Brazilian Portuguese, the few-shot examples that demonstrate the right tone in German are meaningless in Arabic, and the safety constraints that need reinforcement in Thai are redundant in English. The per-language fork approach solves the conflict problem but creates a new one: N complete copies of every prompt, each drifting independently, each accumulating inconsistencies, each requiring separate maintenance. Change one instruction in the English prompt and you must propagate that change to eleven other copies -- manually, because each copy has been customized in ways that make automated propagation unreliable.

The answer is neither. It is a template architecture with language-specific slots: a shared skeleton that defines the universal structure and intent of the prompt, combined with parameterized sections that are filled with language-appropriate content at runtime. This architecture gives you the consistency of a single prompt design with the flexibility of per-language customization, and it makes the maintenance burden proportional to the actual differences between languages rather than proportional to the total number of languages.

## The Template Concept

A prompt template separates what is universal from what is language-specific. The universal parts are the instructions that apply regardless of language: the task definition, the output structure requirements, the safety constraints that are the same everywhere, the behavioral rules that define the product's personality. The language-specific parts are the sections that must change to produce culturally and linguistically appropriate output: the formality directives, the persona description, the few-shot examples, the language-specific safety reinforcements, and the output format examples.

Think of it as a document with blanks. The document says: "You are a helpful assistant for a financial product. You help users understand their account balances, transactions, and financial terms. [PERSONA_SECTION]. When responding, always [FORMAT_SECTION]. For safety, [SAFETY_SECTION]. Here are examples of ideal responses: [EXAMPLES_SECTION]." The bracketed sections are filled at runtime based on the detected language. An English user gets the English persona, English format examples, and English safety constraints. A Japanese user gets the Japanese persona (with keigo directives), Japanese format examples (with full-width punctuation handling), and Japanese safety constraints (with reinforced refusal instructions for low-compliance categories).

The template is not a string with literal placeholders. In practice, it is a configuration object: a base prompt definition with named sections, where each section has a default value (usually English) and optional per-language overrides. The prompt assembly pipeline reads the template, identifies the user's language, selects the appropriate value for each section (the per-language override if one exists, the default otherwise), and compiles the final prompt string.

## The Five Sections That Need Localization

Not every part of a prompt needs language-specific variants. Through the lessons of the preceding subchapters, a clear pattern has emerged: five sections consistently require per-language adaptation, and the rest can stay universal.

**Section one: persona and tone.** This is the most language-sensitive section, as subchapter 7.6 documented in detail. The persona description must encode the formality level, the social register, and the cultural voice appropriate for each language. Japanese needs keigo directives. Korean needs a specified speech level. German needs a Sie or du decision. Arabic needs a Modern Standard Arabic instruction with appropriate rhetorical conventions. Spanish needs a regional variant specification. The persona section is where the greatest per-language divergence exists, and it is the section most likely to need a unique variant for every supported language.

**Section two: formality and register instructions.** Closely related to persona but distinct in implementation. While persona describes who the AI is, formality instructions describe how the AI speaks. These include explicit directives about verb forms ("use desu/masu as the baseline"), address conventions ("always use Sie"), elaboration level ("provide thorough explanations with contextual detail rather than terse responses"), and sentence structure preferences ("use indirect constructions for instructions rather than imperative forms"). Some languages need no formality instructions beyond the persona description. Others need detailed linguistic directives to achieve consistent output.

**Section three: few-shot examples.** As subchapter 7.4 explained, few-shot examples that are effective in English can be counterproductive in other languages. The examples in each language-specific slot should be written natively in the target language (not translated from English), should demonstrate the correct formality level and register for that language, and should use culturally relevant content. A few-shot example for a customer support prompt in English might show a response about shipping times and refund policies using American idioms. The Japanese version should show the same type of response but with appropriate keigo, culturally natural phrasing, and the level of detail that Japanese users expect. The examples anchor the model's output style more effectively than abstract instructions, making them one of the highest-impact sections to localize.

**Section four: output format examples.** When the prompt requires structured output, the format examples should demonstrate the exact format using the target language's text. As subchapter 7.5 documented, format compliance drops significantly when the model must infer how to combine structural elements (field names, delimiters, labels) with non-Latin text. A format example that shows the exact structure with a real target-language value eliminates much of this inference. The examples should use English field names (the universal standard recommended in 7.5) but target-language values, showing the model exactly how to combine the two.

**Section five: safety constraint reinforcement.** The universal safety section covers the safety rules that apply in all languages. The language-specific safety section reinforces those rules for languages where safety compliance is weaker, as subchapter 7.7 documented. For high-resource European languages, the language-specific safety section may be empty -- the universal constraints are sufficient. For languages where refusal rates drop below acceptable thresholds, the language-specific section adds explicit refusal examples in the target language, reinforced instructions, and any language-specific safety categories (content that is acceptable in one culture but not in another).

These five sections account for the vast majority of per-language adaptation. The remaining sections -- task definition, behavioral rules, output structure requirements, context injection points -- stay universal. This asymmetry is the key insight of the template architecture: most of the prompt is the same across languages, and the parts that differ are well-defined and bounded.

## Base Template Plus Overrides

The override model is simple and powerful. Define a base template with default values for all five localizable sections. The defaults are typically the English versions. For each supported language, define overrides only for the sections that need to differ.

If French needs a different persona (vous-form, moderate formality, naturally elaborated sentences) but can use the English format examples and does not need safety reinforcement, the French override contains only the persona and formality sections. The other three sections use the English defaults. If Japanese needs all five sections customized, the Japanese override contains all five. If Spanish needs two variants (one for Spain and one for Latin America), create two override sets keyed to the language-region code.

The override model minimizes duplication. A prompt template with twelve supported languages and five localizable sections has a maximum of 60 language-specific sections. In practice, most languages need only two or three overrides, so the actual count is 25 to 35 language-specific sections plus the base template. Compare this to the fork-everything approach, which creates twelve complete copies of the entire prompt -- 12 times the full prompt length -- all of which must be maintained in sync.

When you change a universal instruction (adding a new feature, updating a behavioral rule, modifying the output structure), you change it once in the base template, and all twelve languages inherit the change. When you change a language-specific section (adjusting the Japanese formality level based on user feedback), you change only the Japanese override, and no other language is affected. Changes are isolated to the scope of their impact.

## Template Storage and Management

Prompt templates should live in a configuration system, not in application code. Hardcoding prompt templates in source code means every prompt change requires a code deployment. Configuration-based storage means prompt changes can be rolled out independently of code changes, with their own review and approval process.

The configuration system should support versioning. Every change to a template or an override creates a new version. The production system runs the current version. A staging environment runs the candidate version. The verification pipeline (described in subchapter 7.9) runs against the candidate version before it is promoted to production. If the candidate version causes a regression in any language, it is rolled back to the previous version without a code deployment.

Access control matters. The base template should be controlled by engineering, because changes to universal instructions affect all languages and all users. Language-specific overrides should be editable by language administrators -- native speakers or localization specialists who understand the target language and can adjust formality directives, update few-shot examples, and refine tone instructions without engineering involvement. This division of ownership scales: as you add languages, you add language administrators, not engineering headcount.

The configuration system should enforce schema validation. Every override must conform to the template schema: the right section names, the right field types, no missing required fields. Schema validation catches the class of errors where a language administrator accidentally deletes a required section or misnames a field, which would produce a malformed prompt at runtime.

Store per-language overrides alongside the base template in the same system, not in separate files, databases, or services. Co-location makes it easy to see the full picture for a language: what the base template provides, what the override changes, and what the final compiled prompt looks like. A developer debugging a Japanese prompt issue should be able to see the compiled Japanese prompt in one place, not assemble it mentally from scattered sources.

## Compiling the Final Prompt

At runtime, the prompt assembly pipeline compiles the template into a final prompt string. The compilation steps are straightforward.

First, identify the user's language (from the language routing system described in subchapter 7.8 or from a user preference setting). Second, load the base template. Third, load the language-specific overrides for the detected language. Fourth, for each localizable section, use the override value if one exists, or the base default if no override exists. Fifth, assemble the sections into the final prompt string in the correct order. Sixth, inject any dynamic context (user name, session state, retrieved documents) into the appropriate positions.

The compilation should be deterministic: given the same language and the same template version, the output is always the same prompt string. This determinism is critical for debugging. When a user reports a problem, you can reconstruct exactly the prompt they received by knowing the language and the template version, without needing to inspect runtime state.

Cache the compiled prompts. If you support twelve languages and the template changes infrequently, compile and cache all twelve variants when a new template version is deployed, rather than compiling on every request. The compilation is fast (milliseconds), but caching eliminates even that overhead and ensures that every request for a given language gets an identical prompt, eliminating any potential for race conditions during template updates.

## Scaling to Many Languages

At five languages, the template architecture is convenient. At twenty languages, it is essential. At fifty languages, it is the only approach that does not collapse under its own weight.

The scaling properties of the template architecture become clear when you calculate the maintenance burden. With the fork-everything approach, adding a new language requires creating a complete copy of the prompt and maintaining it forever. At fifty languages, a single prompt change requires fifty edits (or one edit propagated and fifty verifications). With the template approach, adding a new language requires creating only the language-specific overrides, and a universal change requires one edit plus automated regression testing. The marginal cost of each additional language is bounded by the number of sections that need overrides, not by the total size of the prompt.

The template architecture also enables progressive language support. You do not need overrides for all five sections from day one. Launch a new language with no overrides (using the English defaults) and monitor quality. When testing reveals that the persona is culturally inappropriate, add a persona override. When format compliance drops below threshold, add format examples. Each override is added when the data shows it is needed, not preemptively. This progressive approach lets you support a new language in days (with some quality degradation you can measure) rather than months (waiting for full localization before launch).

At scale, the template architecture also supports A/B testing of per-language variants. Want to test whether a more formal Japanese persona improves user satisfaction? Create a variant override, route 10 percent of Japanese traffic to the variant, and measure the difference. The template system makes this possible because the Japanese persona is a single swappable section, not a parameter embedded in a monolithic prompt.

## The Anti-Pattern: The Forked Prompt Repository

The opposite of the template architecture is **The Forked Prompt Repository** -- an anti-pattern so common it deserves a name. The pattern works like this. The team starts with one English prompt. When they expand to French, they copy the prompt and modify it for French. When they add Japanese, they copy the English prompt again and modify it for Japanese. Within three months, they have twelve prompt files, each modified independently. Within six months, the files have diverged: the English prompt was updated four times but only two of the updates were propagated to French, one to Japanese, and zero to Arabic.

The Forked Prompt Repository creates three compounding problems. First, **inconsistency**: different languages receive different instructions, not because of intentional localization but because of maintenance drift. The English prompt says "always cite your source," but the Arabic prompt still says "provide references when possible" because the stronger instruction was never propagated. Second, **hidden regressions**: a change to the French prompt that was intended to fix a French-specific issue accidentally changes a universal instruction, and the change is invisible because nobody is comparing the French prompt to the English prompt line by line. Third, **unscalable maintenance**: every prompt change must be manually applied to every language file, and the manual process is error-prone, time-consuming, and increasingly neglected as the number of languages grows.

Teams that recognize the Forked Prompt Repository anti-pattern in their own systems should migrate to a template architecture. The migration path is: identify which sections differ between language variants (these become your override sections), extract the common sections into a base template, verify that the compiled output from the template matches the existing per-language prompts, and then deprecate the per-language files. The migration takes a few days of engineering time and pays for itself within a month through reduced maintenance burden.

## Template Architecture and the Verification Pipeline

The template architecture integrates naturally with the prompt translation verification process from subchapter 7.9. When the base template changes, the verification pipeline tests every language because a universal change affects all languages. When a language-specific override changes, the pipeline tests only the affected language because the change is scoped to that language. This scoped testing is only possible because the template architecture makes the scope of each change explicit.

The certification system (also from 7.9) maps directly onto the template structure. Each language has a certification status for each localizable section: "persona: certified," "format examples: using default (not certified for this language)," "safety reinforcement: certified." This per-section certification tells you exactly what has been verified and what is running on defaults. A language with all five sections certified has been fully verified. A language with only the persona certified is running on English defaults for the other four sections, and you know exactly what has and has not been validated.

The template also simplifies rollback. If a new persona override for Korean degrades quality, you roll back only the Korean persona section to its previous version. The rest of the Korean prompt (and every other language) is unaffected. In the Forked Prompt Repository, rolling back any change means rolling back the entire Korean prompt file, which may also revert other changes that were working well.

## The Living Document

A prompt template is not a static artifact. It is a living document that evolves with the product, the model, and the user base.

Plan for template evolution from the start. Design the section boundaries so that new sections can be added without restructuring existing ones. Use clear naming conventions for sections and overrides. Document the purpose of each section (what it controls, why it is localizable, what the default does). Maintain a changelog that records every change, the reason for the change, and the verification results.

As the product matures, the template will accumulate complexity. Languages with five overrides where you started with one. New sections added for new product features. Deprecated sections that no one removes. Schedule periodic template reviews -- quarterly is reasonable -- where the team examines the template structure, removes unused sections, consolidates redundant overrides, and verifies that the template still reflects the product's actual behavior.

The goal is not a perfect template. It is a maintainable one. A template that the team understands, that new engineers can learn quickly, that language administrators can update confidently, and that the verification pipeline can test reliably. The teams that invest in this architecture from the start scale their multilingual support smoothly. The teams that start with ad hoc prompt management and try to impose structure later spend weeks untangling the spaghetti that accumulated while nobody was watching.

This subchapter closes Chapter 7 on multilingual prompt engineering and system design. The next chapter shifts from the model layer to the product layer, exploring the multilingual UX and interaction design decisions -- right-to-left rendering, CJK typography, form validation, language switching interfaces, and mixed-script edge cases -- that determine whether your linguistically excellent model output actually reaches the user in a form they can use.