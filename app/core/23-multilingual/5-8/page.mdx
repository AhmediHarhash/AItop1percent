# 5.8 â€” Locale-Specific Content: Dates, Currencies, Units, Names, and Addresses

Every locale has its own rules for formatting dates, currencies, numbers, names, and addresses. Getting these wrong signals to users that your product was not built for them -- more loudly than any grammatical error in a translated sentence. A user can forgive an awkward phrase. They cannot forgive a product that shows them a price as "$1,234.56" when their currency uses a comma for decimals and a period for thousands. They cannot ignore a date that reads "03/04/2026" without knowing whether the product means March 4th or April 3rd. These are not edge cases. These are the basic formatting conventions that every human in a given locale learns as a child, and violating them marks your product as foreign in a way that no amount of fluent translation can repair.

Locale formatting is the layer beneath translation. Translation converts language. Locale formatting converts everything else -- the conventions, the structures, the presentation patterns that a culture shares. A product can have perfect translations in twenty languages and still feel broken in eighteen of them because it formats dates the American way, addresses the American way, and names the American way. The user does not think "this product has a localization deficiency." They think "this product was not made for me."

## The Date Problem

Date formatting is the most dangerous locale failure because it causes silent data errors, not just visual confusion. When a user sees "03/04/2026" on your product, they interpret it according to their locale. An American reads March 4th. A German reads April 3rd. A Japanese user expects to see 2026/04/03 or 2026 year 4 month 3 day. Nobody is wrong. Everyone is interpreting the same string differently, and nine months of the year, the ambiguity produces a different date.

The three major date ordering conventions divide the world roughly into thirds. Month-Day-Year is used primarily in the United States. Day-Month-Year is the standard across most of Europe, Latin America, Africa, and much of Asia. Year-Month-Day follows the ISO 8601 standard and is the default in East Asia -- China, Japan, Korea -- as well as in technical and scientific contexts globally. Within each convention, the separators vary: slashes, periods, hyphens, and spaces all appear as standard date separators depending on the locale.

The stakes become concrete when dates drive business logic. A scheduling product that displays "05/06/2026" and means May 6th to its American developers will be interpreted as June 5th by its British users. If the user books a meeting for that date, they have booked the wrong day. A healthcare platform that shows a medication expiration date in American format to European pharmacists risks dispensing expired medication or discarding valid medication. A financial product that shows a payment due date ambiguously risks late fees for users who read the date differently than the system intended.

The fix is not complex, but it requires discipline. Store all dates internally in ISO 8601 format -- YYYY-MM-DD -- which is unambiguous regardless of locale. Display dates by formatting them according to the user's locale at render time. Never store dates as pre-formatted strings. Never pass formatted date strings between systems. Never assume that a date string is unambiguous without knowing the locale it was formatted for. Every date the user sees should pass through a locale-aware formatter that converts the internal representation to the local convention.

For AI-generated content, the same rule applies with an additional complication: the model must be told which date format to use. An LLM generating a response in French will not automatically use the French date format. It might produce "March 5, 2026" in French words but with the English ordering convention, or it might use the ISO format, or it might use the American month-first ordering. The translation prompt or system prompt must explicitly specify the date format for the target locale. "Format all dates as day-month-year using periods as separators" for a German audience. "Format all dates as year-month-day" for a Japanese audience. Without this instruction, the model defaults to whatever pattern appeared most often in its training data for that language -- which is not always the correct local convention.

## The Currency Problem

Currency formatting is deceptively complex because it involves four independent variables: the symbol, the symbol position, the decimal separator, and the thousands grouping separator. Getting any one of these wrong marks the product as foreign.

In the United States, the dollar sign precedes the amount, a period separates cents, and commas group thousands: $1,234.56. In Germany, the euro sign follows the amount, a comma separates cents, and periods group thousands: 1.234,56 EUR. In France, the euro sign follows the amount, a comma separates cents, and spaces group thousands: 1 234,56 EUR. In Switzerland, the franc abbreviation follows the amount, a period separates cents, and an apostrophe groups thousands: 1'234.56 CHF. In India, the rupee symbol precedes the amount, but the grouping uses the Indian numbering system -- the first three digits are grouped, then every two digits after that: 1,23,456.78 INR. In Japan, the yen has no decimal component and uses no symbol prefix in most contexts: 123,456 yen.

The decimal separator distinction between periods and commas is the most dangerous because it changes the value, not just the appearance. A price displayed as "1.234" means one-point-two-three-four (roughly $1.23) to an American user but one thousand two hundred thirty-four (roughly $1,234) to a German user. Misinterpreting the decimal separator by a factor of a thousand is not a formatting annoyance. It is a data integrity failure that can trigger incorrect purchases, wrong financial calculations, and regulatory violations.

Currency conversion adds another layer. Showing USD prices to Japanese users is not localization -- it is laziness. Users expect to see prices in their local currency, formatted according to their local conventions. This means your product needs both the converted value and the locale-appropriate formatting. The conversion must use current exchange rates and handle rounding rules that differ by currency -- the Japanese yen has no fractional unit, so you round to the nearest yen, while the Kuwaiti dinar has three decimal places, not two.

For AI systems that generate text mentioning prices, costs, or financial values, the model must receive explicit formatting instructions per locale. A financial advisor chatbot serving customers in Brazil must express values in Brazilian reais with the Brazilian formatting convention: R$ 1.234,56, with the R$ symbol, period for thousands, and comma for decimals. If the model outputs "R$1,234.56" -- using the American formatting with the Brazilian symbol -- the user sees a hybrid that feels wrong even if the number is technically correct.

## The Units Problem

Unit systems divide the world into two camps with a clear boundary: the United States, Myanmar, and Liberia use imperial units, and essentially everyone else uses metric. But the practical impact on AI products extends far beyond the conversion between miles and kilometers.

Temperature is the highest-stakes unit conversion for AI systems that generate health, weather, or safety content. A health chatbot that tells a German user their child has a fever at "101 degrees" without specifying Fahrenheit is giving dangerous advice -- 101 degrees Celsius would indicate that the thermometer is broken or the child is on fire. A recipe assistant that tells a Japanese user to set the oven to "350 degrees" is giving a Fahrenheit instruction to a user whose oven is marked in Celsius. These are not hypothetical failures. They are the natural result of AI systems trained primarily on English-language data generating numeric advice for non-American users.

Weight, distance, and volume follow similar patterns. A fitness app that tells a French user they should aim for "10,000 steps, roughly 5 miles" is using the wrong unit and losing the user's trust even though the advice is sound. A cooking assistant that specifies "cups" for ingredient quantities is useless in countries that measure by weight in grams. A delivery tracking system that shows distances in miles to a Brazilian user reads as clearly unlocalized.

The fix requires the AI system to know the user's locale and to generate all numeric values with the appropriate unit system. This is not a post-processing step that can convert units after generation. The model must generate with the correct units from the start, because unit references are woven into the surrounding prose in ways that make post-conversion brittle. "Preheat your oven to 175 degrees Celsius" is not the same sentence as "preheat your oven to 350 degrees Fahrenheit" with the number swapped. The entire phrasing, the reference points, and the practical advice differ. The system prompt should specify the unit system for each locale, and the evaluation suite should include test cases that verify correct unit usage across all supported locales.

## The Name Problem

Personal name formatting is one of the most culturally sensitive areas of locale adaptation, and most products handle it badly because they assume the Western naming convention is universal.

The Western convention -- given name followed by family name, with an optional middle name -- represents a minority of the world's naming systems. In East Asia, the convention is reversed: family name first, given name second. A Japanese user named Tanaka Yuki enters their name as Tanaka Yuki, with Tanaka as the family name. If your product displays this as "Yuki Tanaka" because it assumes given-name-first ordering, it has reversed the user's name. This is not a minor formatting issue. In many East Asian cultures, putting the family name first is a mark of identity and respect, and reversing it feels as wrong to the user as someone calling you by your last name as though it were your first.

Russian and other Slavic naming systems include patronymics -- a middle name derived from the father's first name. Ivan Petrovich Sidorov has the given name Ivan, the patronymic Petrovich (son of Pyotr), and the family name Sidorov. Formal address in Russian uses the given name plus patronymic: "Ivan Petrovich." Your product's form fields for "first name" and "last name" cannot capture this structure, and your "Dear First Name" email template produces the overly casual "Dear Ivan" instead of the appropriate "Dear Ivan Petrovich."

Icelandic names use patronymics (or matronymics) instead of family names. A person named Bjork Gudmundsdottir is Bjork, daughter of Gudmundur. "Gudmundsdottir" is not a family name that she shares with her father -- her father's name is Gudmundur Gunnarsson. Sorting Icelandic users by "last name" produces nonsensical results because their last names are not family identifiers.

Indonesian names frequently consist of a single name with no family name component. A user named Suharto is just Suharto. Your product's mandatory "last name" field forces this user to either duplicate their name, enter a placeholder, or abandon the form. Spanish-speaking users typically have two family names -- the father's family name followed by the mother's family name. Maria Garcia Lopez has the paternal name Garcia and the maternal name Lopez. Systems that capture only one "last name" force the user to choose which half of their identity to discard.

The practical requirements for AI systems are threefold. First, never assume a two-part given-family name structure in your data model. Use a flexible name field that accommodates single names, multi-part names, patronymics, and ordering variations. Second, when AI generates content that addresses the user by name, the system must know the locale-appropriate form of address. "Dear Tanaka-sama" for a formal Japanese context, not "Dear Yuki." "Dear Ivan Petrovich" for a formal Russian context, not "Dear Ivan." Third, never sort or display user lists by "last name" without understanding the naming convention. Alphabetical ordering by family name works for Western names, fails for Icelandic patronymics, and produces confusing results for single-name Indonesian users.

## The Address Problem

Address formatting varies so dramatically across locales that any attempt to capture it in a single form structure is guaranteed to fail for some portion of the world's population.

The American address format -- street number, street name, city, state abbreviation, ZIP code -- is the template that most products use. It works for the United States. It fails almost everywhere else. In Japan, addresses are structured from largest to smallest: postal code, prefecture, city, district, block number, building number, apartment number. There is no street name in most Japanese addresses because the addressing system is based on blocks and districts, not streets. A form that requires a "street address" forces Japanese users into a structure that does not exist in their addressing system.

German addresses put the house number after the street name: Friedrichstrasse 43, not 43 Friedrichstrasse. British addresses include a postcode that combines letters and numbers in a specific pattern: SW1A 1AA. Brazilian addresses include neighborhood names as a standard component. Chinese addresses, like Japanese ones, run from large to small: province, city, district, street, building, unit. Indian addresses may include landmark references: "Near Gandhi Circle, opposite State Bank."

For AI systems, the address problem surfaces in two ways. First, when the system generates content that includes addresses -- shipping confirmations, location recommendations, generated letters -- the output must use the locale-appropriate format. An AI assistant that formats a Japanese address in American order has produced an address that a Japanese postal worker cannot efficiently process. Second, when the system parses or validates user-provided addresses, it must accept the locale-appropriate structure. A form validation rule that rejects addresses without a "state" field blocks every user outside the countries that have states or provinces. A regex that validates ZIP codes against the five-digit American pattern rejects every international postal code.

The solution is to use address libraries built on the CLDR -- the Common Locale Data Repository maintained by the Unicode Consortium. CLDR provides address formatting patterns for every locale, including field ordering, required versus optional fields, and display formatting. Google's open-source libaddressinput library implements CLDR address formats and provides both validation and formatting. Building address handling from scratch -- hard-coding field orders, writing custom validation regexes per country -- is reinventing a wheel that has been standardized, tested, and maintained by the Unicode community for over a decade.

## Phone Numbers and Communication Formats

Phone number formatting is another area where locale conventions create both display problems and functional problems. The same phone number can be written at least four ways depending on context and locale. An American number might appear as (555) 123-4567, 555-123-4567, 5551234567, or +1 555 123 4567. A German number might appear as 030 12345678, +49 30 12345678, or 0049 30 12345678. A Japanese number might appear as 03-1234-5678, +81 3 1234 5678, or 0312345678.

The critical rule for phone number handling is: store internationally, display locally. Every phone number in your system should be stored in E.164 format -- the international standard that begins with a plus sign, followed by the country code, followed by the subscriber number with no formatting: +15551234567. When displaying the number to a user, format it according to their locale's conventions using a library like Google's libphonenumber, which handles formatting rules for every country. When accepting input from a user, accept their local format and convert to E.164 for storage.

For AI systems that generate or reference phone numbers, the model must produce phone numbers in the locale-appropriate format. A customer support chatbot serving French users that displays a phone number as "(01) 234-5678" -- using American formatting with parentheses -- looks wrong to a French user who expects 01 23 45 67 89 with spaces and no parentheses. The formatting instruction must be part of the translation brief or system prompt.

## How This Affects AI-Generated Content

AI systems trained primarily on English-language data carry English-centric formatting biases into every language they generate. A model asked to generate a product description in German will often produce prices with dollar signs, dates in month-first order, and temperatures in Fahrenheit -- not because it cannot produce German formatting, but because those formats dominated its training data and the prompt did not specify otherwise.

The fix is systematic, not ad hoc. Your system prompt or translation brief must include explicit formatting rules for each locale. Date format, currency format and symbol, unit system, number formatting convention, and address structure. These rules are not optional extras that you add after the translation pipeline is working. They are foundational requirements that must be present from the first multilingual output your system produces.

Automated validation catches formatting errors that human reviewers miss through familiarity. A regex-based check can verify that dates in French output use the day-month-year pattern, that currency amounts in German output use comma decimals, and that temperatures in metric-locale output use Celsius. These checks run on every piece of AI-generated content, flagging formatting violations before they reach users. The checks are cheap to build, fast to run, and catch the class of errors that most damage user trust.

## Use Libraries, Not Custom Code

The single most important implementation principle for locale-specific formatting is: use established libraries, never hand-code formatting rules. The International Components for Unicode -- ICU -- library provides locale-aware formatting for dates, times, numbers, currencies, and more, backed by the CLDR locale data that covers every significant locale on earth. ICU implementations exist for C, C++, Java, Python, JavaScript, and most other major languages. The JavaScript Intl object, available in every modern browser and Node.js runtime, provides ICU-based formatting with no external dependencies.

Hand-coded formatting rules fail in three predictable ways. First, they miss edge cases because the developer tested against the locales they know and assumed the pattern generalizes. Second, they become maintenance burdens because locale conventions occasionally change -- currency transitions, postal code format updates, new country codes -- and custom code requires manual updates while ICU libraries receive automatic updates from the CLDR. Third, they produce inconsistencies because different parts of the product implement the same formatting logic slightly differently, producing the same kind of drift that terminology management is designed to prevent.

The CLDR dataset, maintained by the Unicode Consortium with contributions from hundreds of language experts worldwide, is updated twice per year and covers over 700 locales. It contains not just formatting patterns but also culturally appropriate defaults -- the first day of the week (Monday in most of Europe, Sunday in the United States, Saturday in parts of the Middle East), the standard calendar system (Gregorian in most of the world, with alternatives for Thai, Japanese, and Islamic contexts), and the measurement system. Building on CLDR means your product inherits decades of locale expertise that no single development team could replicate.

The next subchapter addresses translation memory -- the system that ensures your product uses the same translation for the same text every time, across every surface, preventing the consistency failures that make multilingual products feel fragmented.