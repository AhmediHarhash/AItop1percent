# 15.9 — Cost Caps and Circuit Breakers for Voice

Your voice AI system launches with a pricing model that assumes average conversations run three dollars. A week later, a customer support agent discovers that holding down the push-to-talk button while watching YouTube creates an endless stream of transcription costs. One user racks up four hundred and twelve dollars in a single shift. Another user, running an integration test with a loop, generates six thousand dollars in API calls before anyone notices. Your voice system has no cost limits. Every conversation runs until the user hangs up, regardless of what it costs. By the time you detect the problem, you have burned through your entire monthly margin and are now subsidizing usage at a loss.

Unlimited spending is not a strategy. It is a business failure waiting to happen. Voice AI burns money faster than text-based systems because every second of audio translates to continuous compute, continuous transcription, and continuous model inference. Without cost caps and circuit breakers, a single runaway conversation can destroy your unit economics. A single malicious actor can bankrupt a feature. A single integration bug can turn profitable users into loss leaders overnight. Cost caps are not optional guardrails for cautious teams. They are fundamental infrastructure for any voice product that intends to survive contact with real users.

## The Mechanism of Runaway Voice Costs

Voice systems accumulate costs continuously, not discretely. In a text-based chatbot, each message is a discrete event with a bounded cost. You can predict the cost of a conversation by multiplying average messages per conversation by cost per message. Voice does not work this way. Voice conversations accumulate costs per second. A user who stays on a call for ten minutes generates twenty times the cost of a user who stays for thirty seconds. A user who triggers high-quality synthesis on every response burns through tokens faster than a user who receives short confirmations. The cost variance between the cheapest and most expensive conversation is not two times or five times. It is fifty times. One hundred times. Sometimes more.

This variance creates catastrophic exposure without caps. If your average conversation costs three dollars and your pricing model assumes that average, a single conversation that costs three hundred dollars destroys the margin from ninety-nine normal users. A user who stays on the line for an hour while troubleshooting a technical issue costs more than your entire customer acquisition budget for that user. A test script that calls your API in a loop and never disconnects accumulates thousands of dollars in costs before your monitoring system even triggers an alert. The absence of cost caps means the absence of cost predictability. Your financial planning becomes a guess, not a projection.

The second-order effect is worse. Without caps, you cannot price your product. If you charge a flat monthly fee for unlimited usage, a single heavy user subsidized by light users will destroy your margins. If you charge per conversation, users optimize for longer conversations to extract more value, which increases your costs without increasing your revenue. If you charge per minute, you introduce a perverse incentive to keep users on the line longer, but you still have no protection against runaway costs from bugs, abuse, or integration errors. Cost caps allow you to build a business model. Without them, you are guessing and hoping.

## Per-Conversation Cost Caps

The most fundamental circuit breaker is a cost cap per conversation. You define a maximum allowable cost for a single conversation and terminate the conversation when that limit is reached. This cap is not a target. It is a hard ceiling designed to prevent catastrophic loss. A typical per-conversation cap might be set at three to five times your expected average cost. If your average conversation costs three dollars, your cap might be twelve dollars. This allows for natural variance while protecting against runaway scenarios.

The implementation requires real-time cost tracking. You cannot cap costs after the fact. Your system must accumulate costs as the conversation progresses, tracking transcription tokens, model inference tokens, synthesis characters, and any external API calls or tool use. Every turn in the conversation increments the cost counter. When the counter exceeds the cap, the system triggers a termination sequence. This termination must be graceful. You do not simply disconnect the user. You inform them that the conversation has reached its cost limit, offer an alternative path if available, and then end the session cleanly.

The challenge is setting the cap correctly. Set it too low, and you terminate legitimate high-value conversations that users expect to complete. A technical support session that involves troubleshooting a complex issue might legitimately require twenty turns and cost fifteen dollars. If your cap is ten dollars, you cut off the conversation before resolution, which destroys the user experience and wastes the first ten dollars you already spent. Set the cap too high, and it provides no protection. A cap of one thousand dollars per conversation prevents only the most egregious abuse. Everything below that threshold still burns your margin.

The correct approach is to set caps by use case and user type. A customer support conversation gets a higher cap than a simple FAQ bot. A premium enterprise user gets a higher cap than a free-tier user. A known good user with a payment method on file gets a higher cap than a new anonymous user. You are not setting one cap for the entire system. You are setting contextual caps that reflect the expected value and risk profile of each interaction. This requires infrastructure that can apply different caps dynamically based on user context, conversation type, and historical behavior.

## Per-User and Per-Tenant Cost Caps

Conversation caps protect against single runaway sessions. User caps protect against cumulative abuse. A malicious actor or a buggy integration might stay within per-conversation caps by starting many conversations rather than one long one. Without per-user caps, they can still generate unlimited costs by initiating conversation after conversation until they hit a threshold you never defined. Per-user caps set a ceiling on total spending per user per day or per month. Once a user reaches their cap, all new conversations are blocked or downgraded to a cheaper fallback mode until the cap resets.

The same logic applies at the tenant level for multi-tenant systems. In a B2B voice product, your customer is an enterprise with hundreds or thousands of end users. The enterprise expects unlimited usage within reason, but "within reason" needs a definition. A per-tenant cap sets a monthly spending limit for the entire organization. If the organization exceeds that limit, you notify their admin, potentially throttle usage, or trigger a conversation about upgrading their plan. This cap prevents a single enterprise customer from generating costs that exceed their entire contract value, which would make them unprofitable.

The implementation requires cost aggregation across time windows. You track total spend per user per day and per month. You track total spend per tenant per day and per month. When a new conversation request arrives, you check whether the user or tenant has remaining budget. If they do, you allow the conversation and decrement the budget. If they do not, you block the request and return a budget-exceeded error. This check happens before any expensive operations run. You do not start transcription, load the model, or synthesize audio until you have confirmed that the user has budget remaining.

The user experience challenge is how to handle budget exhaustion gracefully. If a user reaches their cap mid-conversation, do you terminate immediately or allow them to finish? If a user reaches their daily cap at nine in the morning, do you lock them out for the rest of the day or offer an upgrade path? If an enterprise tenant reaches their monthly cap on the twenty-fifth of the month, do you shut down their entire team or continue service and invoice the overage? These are business decisions as much as technical ones. The technical infrastructure must support whichever policy you choose, which means you need configuration per user type, per plan tier, and per contract.

## Daily and Monthly Spend Limits

Cost caps operate at multiple time horizons. Daily caps prevent a single bad day from destroying your margin. Monthly caps prevent cumulative abuse over time. The distinction matters because attack patterns and failure modes operate at different time scales. A bot running a test script generates costs within hours. A poorly optimized integration that calls your API more often than necessary accumulates costs over weeks. A legitimate power user who uses the system heavily but within normal bounds generates high costs over months. You need caps at each level to protect against each failure mode.

Daily caps are your first line of defense against acute cost spikes. If a user or tenant generates costs that exceed their daily limit, you block further usage until the next day. This limits the damage from runaway scripts, integration bugs, or sudden abuse. The daily cap is typically set low enough that even if every user hits it, your total daily spend remains within budget. If you have ten thousand users and your daily cap per user is ten dollars, your worst-case daily spend is one hundred thousand dollars. If that number is acceptable, your daily cap is correct. If it is not, you lower the cap.

Monthly caps protect your long-term margin. A user who stays just under the daily cap every single day can still generate costs that exceed their value to your business. Monthly caps set an absolute ceiling on total spending per user or per tenant per billing cycle. Once a user hits their monthly cap, they are locked out or throttled until the next month begins. This prevents users from gaming daily caps by spreading usage across many days. It also protects you from users whose legitimate usage is so high that they become unprofitable despite paying for the service.

The interaction between daily and monthly caps requires careful design. If your daily cap is ten dollars and your monthly cap is fifty dollars, a user can hit their monthly cap in five days and then be locked out for the remaining twenty-five days of the month. This might be correct if your pricing model assumes low usage. It might be terrible if your users expect continuous access. You need to align your caps with user expectations and contract terms. If users pay for unlimited usage, your caps should be high enough that normal usage never hits them. If users pay for metered usage, your caps should be set to prevent abuse while allowing legitimate high usage that you can invoice.

## Circuit Breaker Implementation for Cost

A circuit breaker is a pattern from distributed systems where you automatically stop calling a failing service to prevent cascading failures. The same pattern applies to cost management. When costs spike beyond acceptable thresholds, you automatically stop or throttle the behavior causing the spike. This is not a manual intervention. It is automatic, real-time protection that does not require a human to notice and respond.

The implementation requires real-time cost monitoring with threshold detection. Your system tracks cost per conversation, cost per user, cost per tenant, and aggregate cost across the entire system. When any of these metrics crosses a predefined threshold, the circuit breaker trips. What happens when it trips depends on your policy. You might terminate active conversations. You might block new conversations. You might downgrade to a cheaper model. You might disable expensive features like high-quality synthesis or tool use. The specific action is configurable, but the trigger is automatic.

The classic three-state circuit breaker pattern applies here. The breaker starts in the closed state, meaning traffic flows normally. When cost thresholds are exceeded, the breaker trips to the open state, meaning traffic is blocked or degraded. After a cooldown period, the breaker moves to the half-open state, where limited traffic is allowed to test whether costs have returned to normal. If costs remain acceptable, the breaker closes and normal operation resumes. If costs spike again, the breaker re-opens. This pattern prevents flapping while providing automatic recovery.

The challenge is setting thresholds that distinguish legitimate high usage from runaway costs. If you set the threshold too low, normal usage spikes during peak hours trip the breaker and degrade service for legitimate users. If you set it too high, the breaker only trips after you have already burned significant money. The correct approach is to set thresholds based on historical usage patterns with headroom for variance. If your normal peak usage is one thousand dollars per hour, you might set your circuit breaker threshold at two thousand dollars per hour. This allows for traffic growth and usage spikes while protecting against true runaway scenarios.

## The User Experience of Hitting Cost Limits

Cost caps protect your business, but they degrade the user experience. A user who hits a cost cap mid-conversation is interrupted. A user who hits a daily cap at noon is locked out for the rest of the day. A user who hits a monthly cap on the fifteenth is blocked for two weeks. These are all negative experiences. The question is not whether to have caps — you must have caps to survive — but how to make the experience of hitting caps as graceful as possible.

The first principle is transparency. When a user hits a cost cap, tell them exactly what happened and why. Do not return a generic error or silently fail. Inform the user that their conversation has reached its cost limit, that they have exceeded their daily usage allowance, or that their organization has hit its monthly budget. Give them context. If they are locked out until tomorrow, tell them that. If they can upgrade to continue, tell them that. If they can contact support to request an exception, tell them that. Users tolerate limits better when they understand them.

The second principle is offering alternatives. If a user hits a per-conversation cap, offer to schedule a follow-up or transfer them to a human agent. If a user hits a daily cap, offer to notify them when their cap resets. If an enterprise tenant hits a monthly cap, offer to upgrade their plan or invoice the overage. Do not simply say no. Provide a path forward, even if that path involves manual intervention or additional payment. Users who see a way to continue are less frustrated than users who hit a wall.

The third principle is preventing surprise. Users should not discover caps by hitting them. If your system has a per-conversation cost cap of twelve dollars, warn the user when they reach nine dollars. If your system has a daily cap of fifty dollars, notify the user when they reach forty dollars. If your system has a monthly cap, send usage reports showing how much budget remains. Proactive warnings allow users to manage their usage before hitting hard limits. Hitting a limit is frustrating. Being warned before you hit the limit feels like the system is helping you stay in control.

The final principle is learning from cap hits. Every time a user hits a cost cap, that event is data. It tells you that your cap might be too low, that the user's usage pattern is unusual, or that the user is extracting more value than your pricing model anticipated. Log every cap hit with context. Who hit it? What were they trying to do? Did they upgrade afterward, or did they churn? Analyze cap hit patterns over time. If many users hit caps doing the same thing, your pricing model does not match user behavior. Adjust your caps, adjust your pricing, or adjust your product to align with how users actually use your system.

## Monitoring Cost Caps and Adjusting Over Time

Cost caps are not set once and forgotten. Usage patterns change. User expectations evolve. Model costs decrease. Your business model matures. Caps that were correct at launch become too restrictive or too permissive six months later. You must monitor cap hit rates and adjust caps over time to balance cost protection with user experience.

The key metric is cap hit rate by user segment. What percentage of free users hit their daily cap? What percentage of paid users hit their monthly cap? What percentage of conversations hit the per-conversation cap? If fewer than one percent of users hit caps, your caps are probably too high and not providing meaningful cost protection. If more than ten percent of users hit caps, your caps are probably too low and frustrating legitimate users. The target range depends on your business model, but generally you want cap hit rates between one and five percent. Enough to catch abuse and runaway costs, rare enough that normal users almost never experience them.

The second metric is cost per cap hit. When a user hits a cap, how much did they spend before hitting it? If your per-conversation cap is twelve dollars but most cap hits occur at twelve dollars exactly, users are using the full budget you gave them. That might mean they are extracting value, or it might mean they are testing the limits. If most cap hits occur at three dollars, your cap is too low and terminating conversations that have barely started. If most cap hits occur at fifty dollars, your cap is not functioning — something bypassed it or users found a way to generate costs faster than your cap logic can track.

The third metric is user behavior after hitting a cap. Do users upgrade? Do they wait for the cap to reset and return? Do they churn immediately? If users who hit caps convert to higher-tier plans at a high rate, your caps are working as intended — they identified high-value users and created upgrade prompts. If users who hit caps churn at a high rate, your caps are too aggressive and driving users away before they see enough value to justify staying. If users who hit caps simply wait and return, your caps are protecting costs without damaging retention, which is the ideal outcome.

Adjusting caps requires A/B testing or gradual rollout. Do not change caps for all users at once. Test higher caps on a small cohort and measure the impact on costs and user satisfaction. If higher caps increase costs but also increase retention and conversion, the trade-off might be worth it. If higher caps increase costs without improving user metrics, revert. If lower caps reduce costs without increasing churn, roll them out broadly. Treat cap tuning as an ongoing optimization problem, not a one-time configuration decision. Your caps at month one should not be your caps at month twelve. The business evolves. The caps must evolve with it.

Cost caps and circuit breakers are the foundation of sustainable voice AI products. They protect your margin, prevent catastrophic loss, and create predictable financial outcomes. But caps alone are not enough. You also need to manage how long conversations run, because the length of a conversation determines its total cost. The next question is when to end expensive calls before they consume budget that exceeds their value.
