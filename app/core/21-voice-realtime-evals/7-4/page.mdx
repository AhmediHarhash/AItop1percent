# 7.4 — Full vs Partial Interruption Handling

Not all interruptions are the same. A user who says "stop" while the system is reading a long list wants the system to stop talking and return to a ready state. A user who says "no, Thursday, not Tuesday" while the system is confirming an appointment wants the system to stop, process the correction, and continue with the corrected information. A user who says "also, can you check if..." while the system is summarizing results wants the system to stop, acknowledge the new request, and add it to the conversation. The interruption type determines the system's response. A one-size-fits-all barge-in handler that always stops and waits for a full new turn will mishandle corrections, additions, and clarifications. The system will lose context. The user will have to repeat information. The conversation will become inefficient and frustrating.

## The Three Interruption Types

A **full interruption** is when the user takes over the conversation entirely. The system is speaking. The user decides the system's response is not useful or is too long or is answering the wrong question. They interrupt to issue a new command or ask a new question. The system should stop speaking, discard the current response, and treat the user's utterance as the start of a new turn. The context of what the system was saying is not relevant. The user has moved on.

Full interruptions are signaled by language that resets the conversation. "Stop." "Never mind." "Actually, can you..." "Forget that, I need..." "Wait, I meant..." These are explicit signals that the user is abandoning the current turn and starting fresh. The system should recognize these phrases and enter a new turn state. The previous response is discarded. The dialogue history is updated to show that the system's last turn was interrupted and incomplete. The user's new utterance is processed as a standalone request.

A **corrective interruption** is when the user interrupts to fix a misunderstanding or to provide missing information while the system is using incorrect data. The system is confirming an appointment for Tuesday. The user says "no, Thursday." The system is reading back a phone number. The user says "wait, the area code is 415, not 425." The system is listing available flights. The user says "not those dates, the following week." These are not new requests. They are corrections to the current request. The system should stop speaking, process the correction, update the relevant context, and resume the conversation with the corrected information.

Corrective interruptions are signaled by negation or replacement language. "No." "Not that." "Actually." "I meant..." "The other one." "Change that to..." The user is not starting a new conversation. They are editing the current one. The system must identify what is being corrected — a date, a name, a number, a preference — and update the corresponding slot in the dialogue state. If the system was in the middle of confirming information, it should re-confirm with the corrected data. If it was executing a task, it should re-execute with the new parameters.

An **additive interruption** is when the user interrupts to add information, to ask a follow-up, or to expand the scope of the current request. The system is summarizing search results. The user says "also, can you filter by price?" The system is reading an address. The user says "and send a copy to my email." The system is confirming a reservation. The user says "can you also check availability for the day after?" These are not corrections. The original information is still valid. The user is augmenting it.

Additive interruptions are signaled by conjunctions and expansion language. "Also." "And." "Can you also..." "In addition." "One more thing." "While you're at it." The system should stop speaking, process the addition, integrate it into the current task, and continue. If the system was listing results, it should apply the new filter and re-list. If it was confirming information, it should confirm the original information plus the addition. If it was executing a task, it should extend the task to include the new request.

## Why Most Systems Only Handle Full Interruptions

Most voice systems treat all interruptions as full interruptions because it is the simplest model. The user speaks, the system stops, the system processes the user's utterance as a new turn. This works for cancellations and for new requests. It fails for corrections and additions. The user says "no, Thursday" and the system hears "Thursday" as a standalone utterance with no context. The system responds with "I didn't understand. Can you say that again?" or "What would you like to do with Thursday?" The user must now re-state the entire correction in a full sentence: "Change the appointment to Thursday instead of Tuesday." The conversation becomes verbose and repetitive.

The reason most systems fail to handle corrective and additive interruptions is that doing so requires maintaining context across the interruption. The system must remember what it was saying, what information was being confirmed, and what task was being executed. It must parse the user's interruption in the context of the interrupted turn, not as a standalone utterance. This requires dialogue state management that can correlate the interruption with the interrupted content. If the system was confirming a date and the user says "Thursday," the system must infer that "Thursday" is a replacement for the previously mentioned date. If the system was listing options and the user says "the second one," the system must track which options were mentioned and map "the second one" to the correct item.

This context-aware parsing is difficult. It requires entity tracking, coreference resolution, and intent classification that considers not just the user's current utterance but also the system's previous utterance. Most off-the-shelf ASR and NLU systems do not provide this out of the box. They process each user utterance independently. To handle corrective and additive interruptions, you must build custom logic that maintains a structured representation of the system's current output, tracks which entities were mentioned, and resolves the user's interruption against that representation. This is achievable but requires careful engineering and thorough testing.

## Detecting Interruption Type from Language and Context

You detect interruption type using a combination of language signals and dialogue context. If the user's utterance starts with negation words — "no," "not," "nope," "incorrect," "wrong" — it is likely a corrective interruption. If it starts with conjunctions or additive words — "also," "and," "plus," "additionally," "can you also" — it is likely an additive interruption. If it starts with commands or new requests — "stop," "cancel," "never mind," "actually I need," "change of plans" — it is likely a full interruption.

But language signals alone are not enough. Context matters. If the system just asked a yes-or-no question and the user says "no," that is a direct answer, not a corrective interruption. If the system is in the middle of reading a list and the user says "no, not that one," that is a correction. If the system is confirming information and the user says "no, the other date," that is also a correction. The same word — "no" — has different meanings depending on where the system is in the conversation.

Dialogue context is tracked through the conversation state. The state includes the current dialogue act — whether the system is asking a question, confirming information, listing options, executing a task, or delivering results. It also includes the entities that were mentioned in the system's last utterance. If the system said "I've scheduled your appointment for Tuesday at 3pm," the state includes the entities "Tuesday" and "3pm" tagged as the appointment date and time. If the user interrupts with "no, Thursday," the system matches "Thursday" to the date slot and interprets the interruption as a correction.

Some systems use a two-stage classifier. The first stage classifies the utterance as full, corrective, or additive based on language signals. The second stage validates the classification using dialogue context. If the first stage says "corrective" but the dialogue context does not include any entities that could be corrected, the classification is overridden to "full." This prevents misclassification in ambiguous cases where the language signal is weak or misleading.

## Responding to Corrective Interruptions

When the system detects a corrective interruption, it must identify what is being corrected and update the dialogue state accordingly. If the system was confirming a date and the user says "Thursday," the system updates the date slot to "Thursday." If the system was reading a phone number and the user says "the area code is 415," the system updates the phone number's area code component. If the system was listing flight options and the user says "not those dates, the following week," the system updates the search parameters and re-runs the search.

After updating the state, the system must acknowledge the correction and continue the conversation with the corrected information. The acknowledgment can be explicit — "Got it, Thursday instead of Tuesday. I've updated your appointment." — or implicit — "Okay, I've scheduled your appointment for Thursday at 3pm." The choice depends on the conversation style. Explicit acknowledgments are safer in high-stakes domains like healthcare or finance where users need confirmation that their correction was understood. Implicit acknowledgments are faster and feel more natural in low-stakes domains where users trust the system to handle corrections correctly.

The system must also decide whether to repeat information that was already confirmed before the correction. If the system was confirming an appointment for Tuesday at 3pm and the user corrects the date to Thursday, does the system re-confirm the time? If the time was already confirmed and the user did not question it, re-confirming is redundant. But if the correction might affect other parameters — Thursday at 3pm might not be available even if Tuesday at 3pm was — the system must re-validate and potentially ask for new input. This depends on the domain logic. The conversation manager must understand the dependencies between entities and re-validate when necessary.

## Responding to Additive Interruptions

When the system detects an additive interruption, it must incorporate the new information into the current task without discarding the original request. If the system is summarizing search results and the user says "also filter by price," the system applies the price filter and re-summarizes. If the system is confirming a reservation and the user says "can you also check the day after?" the system adds a second availability check to the task queue and processes both.

The challenge with additive interruptions is that they often expand the scope of the task in ways the system was not prepared for. The system was designed to handle one request at a time. The user is now asking for two things. The system must decide whether to handle them sequentially or in parallel. Sequential handling is simpler. The system finishes the first task, then starts the second. But this can be slow if the first task has many steps. Parallel handling is faster but requires task coordination. The system must track two tasks simultaneously, manage dependencies, and present results in a coherent order.

Another challenge is disambiguation. If the user says "also, can you check availability?" the system must infer what kind of availability, for what date, and for what service. The context from the current conversation provides clues. If the system was checking hotel availability for a specific date, "also, can you check availability?" likely means availability for a different date or a different hotel. The system must prompt for the missing details: "Sure, which date would you like me to check?" If the context is insufficient to disambiguate, the system must ask. This adds conversational turns, but it is better than guessing and getting it wrong.

## The Cost of Misclassifying Interruption Type

Misclassifying a corrective interruption as a full interruption causes the system to lose context. The user says "no, Thursday" and the system hears it as a standalone utterance, not as a correction. The system responds with confusion: "I'm sorry, I didn't understand. What about Thursday?" The user must now repeat the entire correction in a full sentence: "I want to change the appointment from Tuesday to Thursday." The conversation becomes inefficient. What should have been resolved in one turn takes three.

Misclassifying a full interruption as a corrective interruption causes the system to mis-apply the user's input. The user says "actually, can you check flights to Seattle instead?" The system hears "Seattle" and tries to apply it as a correction to the current flight search, updating the destination but keeping the original dates and passenger count. The system confirms the wrong request. The user must issue another correction. The conversation spirals into a series of corrections and re-corrections as the user tries to reset the system's understanding.

Misclassifying an additive interruption as a full interruption causes the system to discard the original task. The user says "also, can you send a copy to my email?" The system hears it as a new request and responds "Sure, what would you like me to send?" The user must re-explain the original task and the addition. The conversation repeats information that was already established. The user experiences frustration. The system feels like it has poor memory.

The cost of misclassification is conversational inefficiency, user frustration, and abandonment. Users who experience repeated misclassifications stop trusting the system's ability to handle interruptions. They adjust their behavior. They wait for the system to finish before speaking. They issue full, explicit commands instead of corrections or additions. The conversation becomes rigid and formal. The natural fluidity of human conversation is lost.

## Evaluating Interruption Handling Accuracy

You evaluate interruption handling by running test conversations that include all three interruption types and measuring whether the system responds correctly to each. A test case includes a system utterance, an interruption at a specific point in the utterance, and the expected system response. For a corrective interruption, the expected response is that the system updates the relevant entity and continues with the corrected information. For an additive interruption, the expected response is that the system adds the new request and handles both. For a full interruption, the expected response is that the system discards the current turn and starts fresh.

Measure classification accuracy — the percentage of interruptions that are classified correctly as full, corrective, or additive. Also measure response accuracy — the percentage of correctly classified interruptions that are also handled correctly. A system might classify an interruption as corrective but then fail to identify what is being corrected, or fail to update the dialogue state, or fail to acknowledge the correction. Classification accuracy without response accuracy is not enough. Both must be high for the system to handle interruptions reliably.

Also measure user recovery effort. When the system misclassifies or mishandles an interruption, how many additional turns does the user need to correct the misunderstanding? A single extra turn — the user repeats their correction more explicitly — is acceptable. Three or more turns — the user must explain what they meant, correct the system's misunderstanding, and re-confirm — is too many. High recovery effort indicates that the system's interruption handling is not just inaccurate but also fragile. Small errors cascade into large conversational failures.

## The Design Decision: Simple or Context-Aware

You must decide whether your system will handle only full interruptions or whether it will also handle corrective and additive interruptions. Simple systems that treat all interruptions as full turns are easier to build, easier to test, and have fewer failure modes. They work well for task-oriented bots with simple, linear conversations. A user schedules an appointment. The system confirms. The user corrects if needed by issuing a full new request. The extra verbosity is tolerable if the conversation is short and the task is simple.

Context-aware systems that handle all three interruption types are harder to build, harder to test, and have more failure modes. But they enable more natural conversations. The user can interrupt to correct mid-confirmation, to add a request mid-task, or to take over entirely. The conversation feels fluid. The user does not have to wait or to repeat themselves. The trade-off is engineering complexity and the risk of misclassification. You must maintain dialogue state, track entities, resolve coreferences, and classify interruptions in context. You must test all three interruption types across diverse conversations and acoustic conditions. The payoff is a voice UX that feels responsive and human.

The choice depends on your domain and your quality bar. If your voice system is a simple command interface with short, transactional conversations, full-interruption-only handling is sufficient. If your voice system handles complex, multi-turn conversations with high user expectations for fluidity, you need context-aware interruption handling. The users will interrupt. They will correct. They will add requests. If your system cannot handle these smoothly, they will abandon it for a more capable interface.

The next subchapter covers turn-taking ambiguity — when it is unclear whether the user has finished speaking or is pausing mid-sentence.
