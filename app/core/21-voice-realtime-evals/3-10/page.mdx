# 3.10 — Filler Audio and Conversational Placeholders

Silence is toxic in voice interfaces. A user asks a question. The system goes silent for 1.2 seconds while the LLM generates a response. The user does not know if the system is thinking, if the connection dropped, or if the system did not hear the question. Uncertainty breeds frustration. But if the system says "Let me check on that for you..." in the first 300 milliseconds, the user knows the system is working. The same 1.2 seconds of LLM latency feels purposeful instead of broken. Filler audio transforms dead air into productive waiting.

Conversational placeholders are phrases that buy time without committing to an answer. "One moment..." "Let me look that up..." "I am checking now..." These phrases serve two functions: they acknowledge the user's input, and they set an expectation that a response is coming. Used correctly, they make high-latency systems feel responsive. Used incorrectly, they make the system feel evasive, repetitive, or artificially slow.

This subchapter explains when filler audio improves perceived responsiveness, when it degrades user experience, how to implement it without making the system sound robotic, and how to measure whether placeholders are helping or hurting.

## Why Silence Feels Longer Than It Is

Human perception of time is non-linear in conversation. A 600-millisecond pause after a question feels like two seconds. A 600-millisecond pause while someone says "Let me think about that..." feels like half a second. The difference is certainty. When the user hears activity — speech, acknowledgment, ambient sound — they perceive forward progress. When they hear silence, they perceive stalled progress or failure.

In face-to-face conversation, silence is accompanied by visual cues. The person you are speaking to nods, makes eye contact, or gestures to indicate they are listening and formulating a response. In voice-only interfaces, those cues do not exist. A two-second pause in a phone call is awkward. A two-second pause in a voice assistant interaction is perceived as a system failure. The user may repeat the question, assume the system crashed, or hang up.

Filler audio provides the missing cue. It signals "I heard you, I am processing your request, a response is coming." This acknowledgment resets the user's patience timer. Instead of tolerating 800 milliseconds of total latency before frustration, the user tolerates 300 milliseconds of silence before the filler phrase, then another 1.5 seconds while the system completes processing. The total latency is higher, but the perceived latency is lower because the user was never uncertain.

## Types of Filler Phrases and When to Use Each

Acknowledgment fillers signal that the system received the input. "Got it." "Okay." "Let me check." These are short — 200 to 400 milliseconds of audio — and they should play within 300 milliseconds of the user finishing their utterance. The goal is to confirm the system is alive and working before the user experiences doubt.

Task-specific fillers set expectations about what the system is doing. "Let me look up your account details..." "Searching our knowledge base..." "Checking the schedule..." These phrases tell the user what to expect and how long it might take. If the user asks "What is the status of my order?" and the system responds "Let me pull up your order details," the user understands the system is performing a lookup operation that might take a moment. The latency feels justified.

Processing fillers acknowledge complexity without committing to a timeline. "Let me think about that..." "That is a good question..." "I am working on that..." These are more generic and should be used sparingly, because they do not convey specific progress. They work well when the LLM is generating a complex or long-form response where the user expects the system to take time. They work poorly for simple questions where the user expects an instant answer.

Apology fillers acknowledge that the wait is longer than expected. "This is taking a bit longer than usual..." "Still working on it..." "Just a moment more..." These are last-resort phrases for when latency exceeds acceptable thresholds. They prevent the user from assuming the system is broken, but they also signal that something is wrong. If you find yourself using apology fillers frequently, the root problem is latency, not the absence of filler audio.

## The Filler Paradox: Adding Latency to Reduce Perceived Latency

Filler audio increases total latency. Generating and playing "Let me check on that for you" takes 600 milliseconds. The LLM response takes 1.2 seconds. Total latency is 1.8 seconds instead of 1.2 seconds. But the user perceives the interaction as faster because they heard a response in 300 milliseconds and then waited purposefully for 1.5 seconds, rather than waiting in uncertain silence for 1.2 seconds.

This paradox is central to voice UX design. Objective latency and subjective latency are not the same. The system that completes in 1.2 seconds of silence often feels slower than the system that completes in 1.8 seconds with filler audio. Optimizing for perceived responsiveness sometimes means adding latency strategically.

But this only works if the filler phrase feels purposeful. If the system says "Let me check..." and then responds 400 milliseconds later, the filler was unnecessary. The user would have tolerated 400 milliseconds of silence without frustration. The filler added latency without reducing perceived latency. The rule: use filler audio only when the subsequent wait is long enough to trigger user uncertainty. For most users in most contexts, that threshold is around 800 milliseconds to 1.2 seconds. Below 800 milliseconds, filler audio adds more latency cost than perceptual benefit. Above 1.2 seconds, filler audio is essential.

## Avoiding Robotic and Repetitive Filler Phrases

If the system says "Let me check on that for you" for every query, the user notices the repetition within three interactions. The phrase stops feeling like a natural conversational acknowledgment and starts feeling like a programmed delay tactic. The system sounds robotic, and the user loses trust.

Variation is critical. Instead of one filler phrase, maintain a pool of 8-12 phrases that serve the same function. "Let me look that up." "Give me a moment." "I am checking now." "Let me find that for you." "One moment, please." "Looking into that." The system selects randomly from the pool, ensuring the user rarely hears the same phrase twice in a row. This small change makes the interaction feel significantly more human.

Contextual variation is better than random variation. If the user asks about account details, the system says "Let me pull up your account." If the user asks a knowledge question, the system says "Let me search for that." If the user asks for a recommendation, the system says "Let me think about that." The filler phrase reflects the type of task, reinforcing that the system understands what the user asked and is performing the appropriate action.

Avoid filler phrases that over-promise. "Let me find the perfect answer for you..." sets an expectation that the system might not meet. If the LLM produces a mediocre response, the user feels misled. Prefer neutral phrasing: "Let me check on that" or "Looking into that now." These acknowledge the request without creating performance expectations.

## When Filler Audio Backfires

Filler audio backfires when it is used to mask consistently high latency. If every query takes 2.5 seconds and the system says "Let me check..." for every query, the user learns that "Let me check" means "this system is slow." The filler becomes a signal of poor performance rather than a conversational courtesy. At that point, the filler is not masking latency — it is highlighting it.

Filler audio also backfires when it delays the user's ability to interrupt. If the user asks a question, the system starts playing a filler phrase, and the user realizes mid-phrase that they misspoke and want to interrupt, the filler has introduced 500 milliseconds of latency before the interrupt is possible. In systems where interruptions are common — conversational agents where users refine queries iteratively — filler audio can make the interaction feel sluggish even if it technically reduces perceived latency for completed queries.

Overuse of filler phrases makes the system sound hesitant or uncertain. If the system says "Let me think..." "Hmm..." "That is an interesting question..." before every response, the user perceives the system as unsure of itself. Confidence is a UX attribute. A system that jumps directly to the answer feels more competent than a system that hedges and delays. Use filler audio to manage long waits, not to add personality.

## Implementing Filler Audio Without Breaking Streaming Pipelines

Filler audio must play before the LLM completes generation. This requires predicting whether latency will exceed the filler threshold before latency actually occurs. One approach: monitor LLM latency for the first few tokens. If the first token takes longer than 400 milliseconds, the system assumes the full response will take more than 1 second and triggers a filler phrase. If the first token arrives in under 200 milliseconds, the system skips the filler and waits for the full response.

Another approach: estimate query complexity upfront. If the user's question is long, open-ended, or semantically complex, assume the LLM will take longer to respond and play a filler phrase preemptively. If the query is short and factual, skip the filler. This requires lightweight query classification — a small model that predicts response latency based on query length, keyword presence, or sentence structure. The classifier runs in parallel with ASR and completes before LLM inference starts, allowing the system to decide whether to play filler audio before latency becomes perceptible.

Filler audio must not block the main response pipeline. The system plays the filler phrase while the LLM continues generating. The filler and the LLM response are independent audio streams. When the LLM completes, the system fades out the filler if it is still playing and transitions to the response. This requires an audio mixer that can blend and crossfade streams in real-time.

Some systems implement filler audio as a pre-generated library of short clips. The clips are stored locally or in a CDN, so playback starts instantly without waiting for TTS. This eliminates the TTS latency that would otherwise compound filler latency. The tradeoff is that pre-generated clips lack variability in prosody and cannot adapt to context dynamically.

## Measuring Filler Audio Impact on User Experience

You cannot know whether filler audio is helping without measuring user behavior and satisfaction. Run A/B tests where half of users experience filler phrases and half experience silence. Measure task completion rate, session length, and repeat usage. If users in the filler group complete more tasks and return more often, the filler is improving perceived responsiveness. If completion rates are identical or lower, the filler is adding latency cost without perceptual benefit.

Measure user interruptions. If users frequently interrupt the filler phrase to restate their query or ask a different question, the filler is not buying useful time — it is creating friction. If users wait through the filler phrase and engage with the response, the filler is successfully managing expectations.

Track sentiment and satisfaction scores by session. After each interaction, ask users to rate the experience. Compare satisfaction scores for sessions with filler audio versus sessions without filler audio. If satisfaction is higher in the filler group for queries with latency above 1 second but identical or lower for queries with latency below 800 milliseconds, you have identified the filler threshold: use filler for long-latency queries, skip it for short-latency queries.

Measure perceived latency directly. After a session, ask users "How responsive did the system feel?" on a 1-5 scale. Compare perceived responsiveness across groups with identical objective latency but different filler strategies. If perceived responsiveness is higher in the filler group despite identical or longer total latency, filler audio is working as intended.

## Balancing Filler Audio with Latency Reduction

Filler audio is not a substitute for latency reduction. It is a UX tool that makes high latency more tolerable. The best voice systems combine aggressive latency optimization with strategic filler audio. Reduce LLM latency, reduce network latency, reduce ASR and TTS latency — then use filler audio to manage the remaining latency that you cannot eliminate.

If your P95 latency is 2.5 seconds and filler audio makes it tolerable, you have a functioning system. But if a competitor reduces P95 latency to 900 milliseconds without filler audio, their system will feel faster than yours even though your users do not complain. Filler audio buys time to optimize, but it does not eliminate the need to optimize.

Some teams over-index on filler audio because it is easier to implement than reducing LLM latency. Adding a "Let me check..." phrase takes one engineer one day. Reducing LLM latency from 1.8 seconds to 900 milliseconds might require model selection changes, prompt optimization, infrastructure upgrades, and weeks of work. But the latency reduction delivers permanent benefit. The filler audio delivers temporary tolerance. Both are valuable. Neither is sufficient alone.

The next subchapter explores latency regression detection: how to build production monitoring systems that catch latency degradation before users start abandoning calls or leaving negative reviews.
