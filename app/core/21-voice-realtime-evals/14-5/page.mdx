# 14.5 — Mid-Call State Reconciliation Strategies

The healthcare appointment system maintained perfect state through seventeen conversation turns. The user had scheduled a cardiology appointment for March 14 at 2 PM, changed the time to 3 PM, then added a lab test before the appointment. The state object tracked all of it. Then on turn eighteen, the user said "actually, can we move my heart doctor appointment to the morning?" The system, still locked onto the 3 PM slot in state, responded "your appointment is currently at 3 PM, would you like to change it?" The user, frustrated, said "that's what I just said." The system had detected the intent to change the time but failed to reconcile the contradiction between current state and requested state. The conversation derailed for four turns before the user gave up and called the office directly. State drift had occurred, and the system had no reconciliation strategy beyond repeating what it already knew.

State reconciliation is the process of bringing conversation state back into alignment with reality when drift is detected. Drift happens constantly in voice conversations. Users change their minds. They correct previous statements. They provide information that contradicts earlier turns. They say yes when they meant no. Without reconciliation mechanisms, state becomes increasingly divorced from what the user actually wants, and every subsequent turn operates on false assumptions.

## The Nature of Mid-Call State Drift

State drift is not a rare edge case. In production voice systems handling appointment scheduling, support requests, or multi-step transactions, state drift occurs in 12 to 18 percent of conversations lasting more than ten turns. The drift is rarely catastrophic in a single moment. It accumulates. A user says "Tuesday" and means next Tuesday, but the system encodes this Tuesday. A user says "the blue one" referring to an item discussed six turns ago, but the system has lost that context and guesses wrong. A user says "no, the other address" and the system updates to the wrong address because it misunderstood which address was "other."

State drift has three primary causes. The first is user correction. The user realizes they gave wrong information or changed their mind and issues a correction. The system must detect that the new information supersedes the old, not supplements it. The second is ambiguous reference resolution. The user refers to "it" or "that one" or "the first option" and the system resolves the reference incorrectly, storing the wrong value in state. The third is implicit contradictions. The user says something that logically contradicts earlier state but does not explicitly frame it as a correction. "I need it delivered by Friday" contradicts the Thursday delivery date stored in state, but the user did not say "change the delivery to Friday." They stated a requirement that happens to conflict.

The cost of undetected state drift compounds over time. If the system stores an incorrect appointment time in turn eight and the user does not notice, every subsequent turn operates on that false premise. By turn fifteen, the system might be confirming insurance details, location, and pre-appointment instructions for an appointment the user does not want. When the final confirmation exposes the drift, the user must either accept the wrong state or restart the entire conversation. Most users hang up.

## Detecting State Drift in Real Time

You cannot reconcile drift you do not detect. Detection requires continuous validation of incoming information against existing state. The simplest detection mechanism is explicit contradiction detection. When the user provides a value for a state field that already has a value, the system must decide: is this a correction, a clarification, or a mistake? If the user says "my email is john at example dot com" in turn three and "my email is john dot smith at example dot com" in turn nine, the system must detect that both statements target the same state field with different values.

The detection logic runs on every turn. Before committing new information to state, the system checks whether any existing state field would be overwritten. If yes, the system must determine intent. Did the user mean to change the value, or are they repeating information they think the system missed? The distinction matters. A change requires reconciliation. A repetition requires acknowledgment without state modification.

Implicit contradiction detection is harder. The user does not explicitly name the field they are changing. They state a requirement or preference that contradicts stored state. "I need to be there before noon" contradicts a 2 PM appointment time. "I can't do Wednesdays" contradicts a Wednesday appointment date. "I don't have a car" contradicts a stored preference for in-person appointments at a location with no public transit. Detecting these requires semantic understanding of the relationship between the new statement and existing state.

The detection system maintains a contradiction log. Every time a potential contradiction is detected, the log records the turn number, the conflicting state field, the old value, the new value, and the confidence score for the contradiction. Low-confidence contradictions are queued for confirmation. High-confidence contradictions trigger immediate reconciliation. Medium-confidence contradictions depend on the stakes. If the state field is low-stakes, the system updates silently. If high-stakes, the system confirms before committing.

User corrections are often signaled linguistically. "Actually," "I mean," "no, I said," "wait," "let me change that" — these are explicit correction markers. When detected, the system should assume the next phrase contains information that supersedes previous state. But not all corrections use markers. Users often issue corrections as simple restatements: "Tuesday the 14th" after previously saying "Tuesday the 7th." The system must compare the new date against stored state and recognize the conflict.

## Reconciliation Triggers and Timing

Reconciliation can be triggered by the system or requested by the user. System-triggered reconciliation happens when drift is detected automatically. User-requested reconciliation happens when the user explicitly asks to change something. The timing of reconciliation affects conversation flow. Immediate reconciliation interrupts the user mid-turn. Deferred reconciliation waits until the user finishes speaking. End-of-turn reconciliation happens after the user's complete statement is processed.

Immediate reconciliation is necessary when the drift affects understanding of the current turn. If the user says "no, I meant the morning appointment" while the system is confirming afternoon details, the system must stop and reconcile before continuing. Interrupting is better than proceeding on false assumptions. The reconciliation happens inline: "Got it, switching to the morning appointment. What time works for you?"

Deferred reconciliation is appropriate when the drift does not block understanding of the current turn. The user says "actually, send it to my work email instead" while discussing delivery timing. The system can process the full turn, then reconcile email address state at the end. This feels more natural than interrupting mid-sentence.

End-of-turn reconciliation batches all detected conflicts and resolves them after the user stops speaking. If the turn contains three pieces of information and two of them conflict with existing state, the system waits until the turn ends, then addresses both conflicts in a single response. "I've updated your email and changed the delivery date to Friday. Does that sound right?" This reduces conversational fragmentation but delays confirmation.

The reconciliation trigger threshold determines how much evidence is required before reconciliation fires. A low threshold means the system reconciles on weak signals, leading to frequent confirmation requests. A high threshold means the system only reconciles on strong signals, risking silent state corruption. The threshold is tuned based on conversation type. High-stakes conversations like medical appointment scheduling use low thresholds. Low-stakes conversations like preference collection use high thresholds.

## Reconciliation Patterns: Confirm and Correct

The confirm-and-correct pattern is the safest reconciliation strategy. When drift is detected, the system explicitly states the old value, the new value, and asks for confirmation. "You previously said 2 PM, now you're saying 3 PM — should I update the appointment to 3 PM?" The user says yes, and state is updated. The user says no, and state remains unchanged. The user clarifies, and the system updates based on the clarification.

This pattern prioritizes accuracy over speed. It adds one or two conversational turns to every reconciliation event. In a twenty-turn conversation with three reconciliation events, this adds six turns. The conversation takes longer, but the final state is correct. The trade-off is worthwhile when the cost of incorrect state is high. Scheduling the wrong medical appointment, sending a prescription to the wrong pharmacy, or booking a flight to the wrong city justifies the extra turns.

The phrasing of the confirmation matters. "You said X, now you're saying Y — which one is correct?" forces the user to choose. "I heard X earlier, should I change that to Y?" implies the system believes Y is the new intent but gives the user veto power. "Just to confirm, you want to change X to Y, right?" assumes the change and asks for rubber-stamp approval. The first is safest for ambiguous situations. The second is best for likely corrections. The third is fastest when confidence is high.

Confirmation phrasing must be concise. Voice conversations do not tolerate long explanations. "You previously mentioned that your preferred contact method is email, but just now you indicated that you would like to receive a phone call — shall I update your contact preference to phone?" is technically accurate but conversationally dead. "Switch from email to phone?" conveys the same information in five syllables. Users confirm or correct immediately.

The confirm-and-correct pattern fails when users are not paying attention. The system asks "change the time to 3 PM?" and the user, distracted, says "yes" without processing the question. State updates incorrectly, and the error is not discovered until final confirmation. This failure mode is common in hands-free scenarios where the user is driving, cooking, or multitasking. Mitigation requires designing confirmations that force attention: "I need to confirm — the new time is 3 PM, not 2 PM. Is that correct?"

## Silent Update and Explicit Acknowledgment

The silent update pattern skips confirmation and updates state immediately when drift is detected. The system detects that the user said "my email is john dot smith at example dot com" in turn nine, overwriting the turn three email "john at example dot com." The system updates state and continues without comment. The next system response proceeds as if the new email was always the correct one.

Silent updates feel natural when the correction is obvious and low-stakes. If the user is spelling their email and self-corrects a typo, the system should not interrupt to confirm. The user knows what they said. Confirmation adds friction without adding safety. Silent updates also work well for preference drift. The user says they prefer morning appointments in turn two, then says they prefer afternoons in turn eight. The system silently updates the preference and offers afternoon slots. No confirmation needed.

The risk of silent updates is invisible errors. If the system misdetects a correction, it updates state incorrectly, and the user has no signal that the update occurred. The user said "john at example dot com" in turn three and "john at sample dot com" in turn nine, intending to provide a second email address, not replace the first. The system silently overwrites the first email. The user does not realize the error until they check confirmation and see only the second email listed. By then, the context of the error is lost.

Explicit acknowledgment pairs silent updates with verbal confirmation that the update happened. The system updates state immediately but tells the user what changed. "Got it, updated your email to john dot smith at example dot com." The user hears the change and can correct if it is wrong. This is faster than confirm-and-correct because it does not wait for user approval, but safer than pure silent update because it surfaces the change.

The acknowledgment must be brief and embedded naturally in the next system response. "Updated your email — now, what time works for you?" ties the acknowledgment to forward progress. "I have updated your email address to john dot smith at example dot com and will use this for all future correspondence" is verbose and breaks flow. Acknowledgment is a single phrase, not a full sentence.

Explicit acknowledgment works best when the update is medium-stakes. Too low-stakes, and acknowledgment feels robotic. Too high-stakes, and acknowledgment without confirmation feels risky. Updating a preferred name is low-stakes — silent update is fine. Updating a delivery address is high-stakes — confirm-and-correct is necessary. Updating a dietary preference for a meal delivery service is medium-stakes — explicit acknowledgment is the right balance.

## The Reconciliation Cost: Time and User Patience

Every reconciliation event costs time. Confirm-and-correct adds one to two turns. Explicit acknowledgment adds three to five seconds of speech. Even silent updates add processing latency if the reconciliation logic is complex. In a fifteen-turn conversation with four reconciliation events, the time cost is fifteen to thirty seconds for explicit acknowledgment, or two to four additional turns for confirm-and-correct. That is a 20 to 40 percent increase in conversation length.

Users tolerate reconciliation cost when they perceive it as necessary. If the user explicitly corrected information, they expect the system to acknowledge the correction. The cost feels justified. But if the system is reconciling state the user did not knowingly change, the cost feels like a penalty for the system's confusion. "Wait, why are you asking me about the time again? I already told you 3 PM." The user does not realize the system detected a contradiction between turns seven and twelve. They just know the conversation is taking longer than it should.

The reconciliation budget is the total amount of conversational time users will tolerate for state management overhead. In high-stakes conversations, the budget is high. Users scheduling surgery or filing insurance claims will tolerate extensive confirmation and reconciliation because accuracy matters more than speed. In low-stakes conversations, the budget is low. Users asking for weather information or setting a timer will abandon the conversation if it takes more than three turns.

The budget is dynamic. Early in the conversation, users are more tolerant of reconciliation because they expect the system to gather information carefully. Late in the conversation, tolerance drops. If the system is still asking confirmation questions on turn eighteen, the user perceives the system as incompetent. The expectation is that the system should have resolved all ambiguity by turn ten.

Measuring reconciliation cost requires tracking both time and turn count. A conversation that takes thirty turns and four minutes with three reconciliation events is compared against a baseline conversation of twenty-five turns and three minutes with zero reconciliation events. The reconciliation cost is five turns and one minute. If the error rate without reconciliation is 8 percent and the error rate with reconciliation is 0.5 percent, the cost is justified. If the error rate without reconciliation is already 1 percent, the cost may not be worth it.

## Choosing the Right Reconciliation Strategy

Not all state drift requires the same reconciliation approach. High-stakes fields require confirm-and-correct. Medium-stakes fields use explicit acknowledgment. Low-stakes fields use silent updates. The system maintains a field-level reconciliation policy that maps each state field to a reconciliation strategy.

Appointment time is high-stakes. A wrong time means a missed appointment. Reconciliation policy: confirm-and-correct. Preferred contact method is medium-stakes. A wrong method means the user might miss a message, but the consequence is not immediate harm. Reconciliation policy: explicit acknowledgment. Preferred name pronunciation is low-stakes. A wrong pronunciation is annoying but not harmful. Reconciliation policy: silent update.

The policy is not static. Stakes change based on context. Delivery address is normally high-stakes, but if the user is browsing a catalog and has not yet committed to purchase, delivery address is low-stakes. The reconciliation policy adapts. Early in the conversation, address updates use silent updates. After the user confirms intent to purchase, address updates switch to confirm-and-correct.

User behavior also influences strategy choice. If the user has issued three corrections in the last five turns, they are actively refining state. Reconciliation should be fast and non-intrusive — explicit acknowledgment or silent updates. If the user has not issued any corrections and the system detects a contradiction, the user may not be aware of the conflict. Reconciliation should be cautious — confirm-and-correct.

The system logs reconciliation events and outcomes. For each event, log the field name, the old value, the new value, the reconciliation strategy used, whether the user confirmed or corrected, and the final state. Over time, this log reveals which fields generate the most drift, which strategies have the highest confirmation-to-correction ratio, and which user populations require more or less reconciliation. A high confirmation-to-correction ratio means the system is detecting real drift accurately. A low ratio means the system is over-reconciling on false positives.

## Reconciliation Failure Modes

Reconciliation fails when the user and the system have different understandings of what state is being reconciled. The system asks "should I change the time to 3 PM?" The user says "yes," thinking the system is confirming the original request. The system updates state, thinking the user approved a correction. The user later discovers the time was changed when they did not intend to change it. This is a confirmation misunderstanding failure.

Another failure mode is reconciliation fatigue. The system detects drift on five fields in a ten-turn conversation and issues five confirm-and-correct requests. The user, exhausted by the back-and-forth, starts saying "yes" to everything without listening. State updates incorrectly because the user stopped engaging with reconciliation prompts. The system prioritized accuracy but destroyed trust by being too cautious.

A third failure mode is silent corruption during reconciliation. The system detects drift on field A, reconciles successfully, but in the process of updating field A, it inadvertently corrupts field B due to cascading state dependencies. The user confirms the new appointment time, and the system updates the time but also changes the appointment type because the new time slot is only available for a different type. The user did not consent to changing the appointment type. The reconciliation introduced new drift.

The fix for confirmation misunderstanding is explicit state labeling. Instead of "should I change the time to 3 PM?" say "your current appointment is 2 PM — should I change it to 3 PM?" The user now knows what the old state is and what the new state will be. Misunderstanding risk drops.

The fix for reconciliation fatigue is batching and prioritization. Do not reconcile every field independently. Batch related fields and reconcile in a single confirmation. "I heard a few changes — switching to 3 PM, changing to the downtown location, and using your mobile number. Does that all sound right?" The user confirms once instead of three times. If batching is not possible, prioritize. Reconcile high-stakes fields with confirm-and-correct and let medium-stakes fields use explicit acknowledgment.

The fix for silent corruption during reconciliation is transactional state updates. When reconciling field A, the system calculates all dependent field updates before committing any changes. If reconciling the appointment time also requires changing the appointment type, the system includes that in the confirmation: "switching to 3 PM means changing from consultation to follow-up — is that okay?" The user sees the full impact of the reconciliation and can reject it if the side effects are unacceptable.

Mid-call state reconciliation is not a backup plan for bad state management. It is a core capability for any voice system handling multi-turn conversations. Drift is inevitable. The system that reconciles well maintains user trust. The system that reconciles poorly or not at all loses users to frustration and errors. The next subchapter covers memory drift — what happens when the system loses context across turns.
