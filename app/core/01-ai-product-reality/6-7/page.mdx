# Chapter 6.7 — Build for the Model Generation After This One

The model you're building on today will be obsolete within 18 months. Not deprecated — obsolete. A better model will exist, with different capabilities, different cost characteristics, and different failure modes. The products that thrive are the ones architected to absorb model changes without rebuilding.

---

### What Changes Between Model Generations

**Capabilities expand.** Each generation can do things the previous one couldn't. GPT-3 couldn't reliably follow complex instructions. GPT-4 could. Claude 2 struggled with long-context tasks. Claude 3 handled 200K tokens. The next generation will have capabilities we can't predict. If your product architecture assumes a fixed set of model capabilities, you'll need to re-architect to take advantage of new ones.

**Costs drop.** Model inference costs have fallen roughly 10x every 18 months since 2022. Tasks that are economically unviable today will be cheap tomorrow. Agent workflows that cost $2 per task today might cost $0.20 in 18 months. This changes your unit economics, your pricing, and potentially your entire product strategy.

**Failure modes shift.** Every model has its own failure patterns. A prompt that works perfectly on one model may fail on its successor. Guardrails tuned to one model's behavior may not transfer. The specific edge cases you've solved may no longer exist — but new ones will appear.

**Competition resets.** When a new model generation launches, every product built on the old generation is momentarily behind every product that quickly adopts the new one. The teams that can evaluate, adapt, and deploy on a new model within weeks have a persistent competitive advantage.

---

### Architecture Principles for Model Resilience

**Separate model logic from product logic.** Your product logic (workflows, UI, business rules, data pipelines) should be independent from your model logic (prompts, model selection, output parsing). When you swap models, you should be changing a configuration layer, not rewriting your application.

**Version everything.** Prompts, model configurations, system instructions, evaluation datasets — all versioned, all reproducible. When you migrate to a new model, you need to compare "old model + old prompts" vs "new model + adapted prompts" vs "new model + old prompts." Without versioning, this comparison is impossible.

**Build comprehensive evals.** Your evaluation suite is your migration tool. When a new model launches, run your full eval suite on it. Within hours, you know: where it's better, where it's worse, and what needs to change. Teams without evals spend weeks manually testing. Teams with evals know in a day.

**Design prompts for portability.** Avoid model-specific tricks and undocumented behaviors. Write clear, explicit instructions that any capable model should understand. The more your prompts depend on quirks of a specific model, the more work you'll do during migration.

**Abstract the model interface.** Use an abstraction layer (even a simple one) that lets you swap models by changing a configuration value. Support multiple models simultaneously so you can A/B test a new model against the current one on live traffic before fully migrating.

---

### The Upgrade Playbook

When a new model generation launches, here's the process:

1. **Day 1-3:** Run your full eval suite on the new model with existing prompts. Identify wins and regressions.
2. **Day 4-7:** Adapt prompts for the new model where needed. Re-run evals.
3. **Week 2:** Deploy the new model to a shadow pipeline (processes real traffic but doesn't serve results to users). Compare outputs.
4. **Week 3:** Canary deploy — route 5-10% of live traffic to the new model. Monitor quality, latency, and cost.
5. **Week 4:** Full rollout if metrics are healthy. Keep the old model as a fallback.

Teams that can execute this playbook in under a month have a structural advantage. The architecture decisions you make today determine whether this takes four weeks or four months.

---

*Next: real-world examples of products that survived — and didn't survive — model transitions.*
