# 2.6 Fork Choice and Chain Selection
Scope: Web3

## Why Forks Happen Without Being a Full Failure
Forks occur when more than one valid continuation exists.

Mechanism. Different proposals can arrive in the same interval and nodes must choose one canonical path.

Example. Two blocks can be valid against the same parent state.

Detection. Track fork rate, depth, and tie-break behavior under load.

Mitigation. Design confirmation and action triggers around fork resolution behavior.

Failure consequence. Ignoring fork mechanics turns normal behavior into production confusion.

## Branch Selection Rules
Each protocol uses a specific rule for canonical choice.

Mechanism. Some rules favor cumulative effort, others weighted validator support.

Example. In one model, accumulated resource commitment determines canonicality; in another, attestation support does.

Detection. Analyze how quickly branches converge after contention.

Mitigation. Select target chains based on your flow sensitivity to temporary divergence.

Failure consequence. Wrong chain choice assumptions make settlement timing unpredictable.

## Reorganizations as a Controlled Event
Reorgs are the operational output of fork choice, not always catastrophic failures.

Mechanism. Short reorgs are usually absorbed if your app uses staged commitments.

Example. A user-facing action may need to wait one more confirmation tier.

Detection. Measure frequency of deep reorgs and time to stabilization.

Mitigation. Use staged state transitions for all critical paths.

Failure consequence. Single-stage actions can break irreversibly during brief reorgs.

## MEV and Ordering Bias
Ordering influence can move value even without overt attacks.

Mechanism. Transaction sequencing is part of miner and validator incentives.

Example. Priority auctions and fee markets can affect execution order outcomes.

Detection. Monitor order drift, delayed inclusion, and outlier inclusion patterns.

Mitigation. Add slippage controls and transparent policy where fairness matters.

Failure consequence. Perceived unfairness damages confidence even when network is healthy.

## Proposer and Builder Separation Patterns
Some ecosystems separate who builds blocks from who proposes them.

Mechanism. Separation can reduce information leakage but changes monitoring scope.

Example. The proposer trust boundary can move toward a smaller service set.

Detection. Audit proposal and builder role concentration.

Mitigation. Require diversity and clear accountability in separation infrastructure.

Failure consequence. New trust points emerge where you expected less.

## Soft Fork, Hard Fork, and Your Product
Rule changes alter the acceptance set and can surprise downstream clients.

Mechanism. Some changes preserve compatibility for older behavior, others do not.

Example. A soft change tightens valid behavior, while a hard change can split state interpretation.

Detection. Test wallet and indexer behavior during protocol version transitions.

Mitigation. Include migration and compatibility plans for every upgrade.

Failure consequence. Update gaps become a higher cost incident than the upgrade itself.

## Cross-Chain Selection for Bridges
Bridge logic should not assume both chains choose branches equally.

Mechanism. Each chain has its own fork recovery timeline and finalization assumptions.

Example. A fast source chain may still need stronger exit assumptions on destination.

Detection. Run bridge chaos tests on branch conflict events.

Mitigation. Add conservative checkpoints and fallback challenge windows.

Failure consequence. Bridges magnify branch mismatch assumptions quickly.

## What to Carry Forward
Fork choice decisions should define your feature timing assumptions.

Mechanism. Your architecture inherits these assumptions whether you choose to or not.

Example. Some flows can stay optimistic, others need strict finality first.

Detection. Audit timing promises for each flow against fork behavior.

Mitigation. Tie flow-level SLAs to fork and reorg characteristics.

Failure consequence. Your most critical flow will always fail first.

## Next Section
Next you move from branch logic to attacker logic, including what a realistic attack set can and cannot do.
