Scope: Web3

# 3.6 â€” The Bridge Problem: Trust Between Chains

In March 2022, hackers compromised the Ronin Bridge â€” the primary connection between the Ethereum mainnet and the Ronin sidechain that powered Axie Infinity, the most popular blockchain game in the world. The attackers used social engineering, sending a fake job offer through LinkedIn to a senior engineer at Sky Mavis, the company behind Axie Infinity. The engineer downloaded a PDF that contained spyware. Through that single compromised machine, the attackers eventually gained control of five of the nine validator keys that secured the bridge. They drained 173,600 ETH and 25.5 million USDC â€” approximately 625 million dollars. Nobody noticed for six days. The bridge continued operating as if nothing had happened. Users deposited funds into a bridge whose reserves had already been emptied. When the theft was finally discovered, it was only because a user tried to withdraw 5,000 ETH and the transaction failed. The funds were simply gone.

Five weeks earlier, in February 2022, the Wormhole bridge connecting Ethereum and Solana was exploited for approximately 320 million dollars. The attacker found a vulnerability in the bridge's signature verification â€” a flaw that allowed them to mint 120,000 wrapped ETH on Solana without depositing any actual ETH on Ethereum. Jump Crypto, a major investor in Wormhole, replaced the stolen funds from their own reserves to prevent a cascading liquidity crisis across Solana DeFi. Not every bridge hack has a billionaire backstop willing to absorb the loss.

Five months after that, in August 2022, the Nomad bridge was exploited for approximately 190 million dollars. But this hack was different. A routine upgrade introduced a bug in the message verification logic that allowed anyone to copy a valid transaction, replace the recipient address with their own, and replay it. Once the first attacker demonstrated that this worked, hundreds of others piled in. Over 40 distinct addresses drained the bridge in a chaotic free-for-all that lasted hours. Some of the copycats later returned the funds, claiming they had taken them only to prevent others from stealing them first. Most did not.

These three incidents â€” Ronin, Wormhole, Nomad â€” happened within six months of each other in 2022 and together accounted for over 1.1 billion dollars in losses. They were not outliers. Bridge exploits have consistently been the most expensive category of attack in crypto. By the end of 2024, total losses from cross-chain bridge exploits exceeded 2.8 billion dollars. No other category of smart contract vulnerability â€” not reentrancy, not oracle manipulation, not governance attacks â€” comes close.

Bridges are where the most money is lost because bridges are where the trust model is weakest.

## Why Bridges Exist and Why They Are Hard

Each blockchain is a self-contained trust domain. Ethereum has its own validator set, its own consensus mechanism, its own state, its own finality rules. Solana has a different validator set, different consensus, different state, different finality. These chains do not share validators, do not share state, and cannot natively verify each other's transactions. They are, from a trust perspective, as separate as two banks in two different countries with no correspondent banking relationship.

But users want to move assets between chains. A trader wants to take their ETH on Ethereum and use it in a DeFi protocol on Solana. A gamer wants to bring their tokens from Avalanche to Polygon. A developer wants their stablecoin to be usable on ten different chains. This demand for cross-chain asset movement is enormous and growing. The problem is that there is no native mechanism for doing it.

You cannot literally move a token from one blockchain to another. Tokens on Ethereum are entries in Ethereum's state â€” they exist because an Ethereum smart contract says they exist. Solana has no ability to read Ethereum's state, and Ethereum has no ability to read Solana's state. The chains are cryptographically isolated. Moving an asset "across" chains is fundamentally an illusion maintained by an intermediary. That intermediary is the bridge.

The bridge's job is to create a credible illusion of cross-chain transfer. It locks your real asset on the source chain â€” putting it in a smart contract where it cannot move â€” and mints a synthetic representation of that asset on the destination chain. When you want to go back, it burns the synthetic and unlocks the original. The synthetic asset on the destination chain is only as valuable as the guarantee that the original asset on the source chain is actually locked, actually safe, and actually redeemable. If that guarantee fails â€” if the locked assets are stolen, if the bridge mints synthetics without corresponding deposits, if the verification mechanism is compromised â€” every synthetic token on the destination chain becomes worthless instantly.

This is the core of the bridge problem. Every bridge is a promise that assets on one chain correspond to assets on another. The entire question is: who makes that promise, and why should you believe them?

## Multi-Signature Bridges: Trust a Committee

The simplest and historically most common bridge design is the **multi-signature bridge**. A group of validators â€” sometimes called guardians, signers, or relayers â€” monitors events on the source chain and authorizes corresponding actions on the destination chain. When you deposit ETH into the bridge contract on Ethereum, the guardians observe the deposit, reach agreement that it is valid, and collectively sign a transaction on the destination chain that mints the equivalent wrapped asset.

The security of a multi-sig bridge depends entirely on the honesty and operational security of the guardians. If a sufficient number of guardians are compromised â€” through hacking, bribery, coercion, or collusion â€” the attacker can authorize fraudulent mints, drain locked funds, or both.

The Ronin Bridge was a multi-sig bridge with nine guardians, requiring five signatures to authorize a transaction. The attackers compromised five keys and drained the entire bridge. The design was straightforward and the failure mode was predictable: five of nine keys is a 56 percent threshold, and once the attacker had those five keys, no technical mechanism could stop the theft. The bridge contract executed the withdrawal exactly as designed. The signatures were valid. The only thing that was wrong was that the humans holding the keys had been compromised.

Wormhole was also a multi-sig design, using a set of 19 guardians called the Guardian Network. The attack did not compromise the guardians directly â€” it exploited a vulnerability in the signature verification code that allowed the attacker to bypass guardian approval entirely. But the underlying architecture was the same: a committee of trusted parties whose approval was required to authorize cross-chain transactions.

Multi-sig bridges are easy to build, fast to operate, and simple to understand. They are also the least secure bridge design in production, because they reduce cross-chain security to a key management problem. If you can steal or compromise enough keys, you own the bridge. The attack surface is not the blockchain. It is the humans and machines that hold the keys.

## Light Client Bridges: Trust the Math

A more sophisticated approach is the **light client bridge**. Instead of trusting a committee to attest that something happened on the source chain, a light client bridge runs a simplified verification node on the destination chain that can independently verify the source chain's consensus.

The idea is conceptually elegant. Ethereum's consensus produces signed attestations from validators. If you can verify those attestations on another chain â€” check the validator signatures, confirm the block is finalized, verify the transaction was included â€” then you do not need to trust any intermediary. The destination chain can verify the source chain's state directly, using cryptography rather than committee attestation.

In practice, light client bridges face significant engineering challenges. Verifying Ethereum's consensus on-chain requires checking hundreds of validator signatures per block, which is computationally expensive. The gas cost of running this verification on a destination chain like Solana or Polygon would make every bridge transaction prohibitively expensive. Chains have different signature schemes, different finality rules, and different state representations, so building a light client for each source-destination pair is a substantial engineering effort.

Despite these challenges, light client bridges represent a meaningful security improvement over multi-sig designs. The trust assumption shifts from "these specific guardians are honest" to "the source chain's consensus is working correctly" â€” a much stronger guarantee, since the source chain's consensus is already secured by its entire validator set and economic security budget.

## ZK Bridges: Trust Nothing But Proofs

The most promising bridge architecture in 2026 is the **ZK bridge** â€” a design that uses zero-knowledge proofs to verify cross-chain state without trusting any intermediary at all.

A ZK bridge works by generating a cryptographic proof that a specific event occurred on the source chain â€” that a deposit was made, that a block was finalized, that a validator set attested to a particular state. This proof is compact enough to verify on the destination chain at reasonable gas cost, even though the underlying computation being proved (verifying hundreds of validator signatures, checking block headers, confirming finality) is enormously expensive.

The zkBridge protocol, developed by researchers at UC Berkeley, demonstrated that it is practical to generate a zero-knowledge proof of Ethereum's consensus in under 20 seconds, with on-chain verification costing less than 230,000 gas. This makes it feasible to verify Ethereum block headers on other chains at a cost of a few dollars per verification â€” expensive for individual transactions, but amortizable across many transfers.

Hyperbridge, which launched in 2025, takes this approach further by using ZK light clients to verify cross-chain messages without trusted intermediaries. The light client checks block headers and validator signatures cryptographically, ensuring every message is finalized on the source chain before being accepted on the destination chain. In 2026, Hyperbridge is extending this model to the Tendermint ecosystem, covering Cosmos-based chains and others.

ZK bridges are not yet the standard. They are computationally intensive, require specialized cryptographic engineering, and are slower than multi-sig bridges because proof generation takes time. But they represent the theoretical ideal: a bridge where you do not need to trust any human, any committee, or any external validator set. You only need to trust the mathematics of zero-knowledge proofs and the security of the source chain's consensus.

## Why the Trust Model Degrades at the Bridge

The fundamental problem with all bridges is that they connect two independent trust domains. Each chain has its own security model â€” its own validators, its own economic security, its own finality rules. Within a single chain, your transactions are secured by the full weight of that chain's consensus. When you send ETH on Ethereum, your transaction is secured by over 35 million staked ETH and more than a million active validators. The cost to attack that transaction is measured in tens of billions of dollars.

But when you send ETH across a bridge to another chain, your transaction's security is no longer determined by Ethereum's consensus. It is determined by the bridge's security â€” which, in the case of a multi-sig bridge, might be determined by the operational security practices of five to twenty individuals. The security does not add. It does not average. It degrades to the weakest link.

This is the **Interchain Security Problem**: when assets cross a bridge, they are only as secure as the bridge itself, regardless of how secure the source and destination chains are. You could have two chains, each with ten billion dollars in economic security, connected by a bridge secured by a nine-of-fifteen multi-sig. The effective security of a cross-chain transaction is not ten billion dollars. It is whatever it costs to compromise eight of those fifteen signers. That cost might be measured in hundreds of thousands of dollars â€” not billions.

The degradation is not linear. It is cliff-like. Within each chain, you have the full economic security of the consensus mechanism. The moment you cross the bridge, you drop to the security of the bridge mechanism. There is no middle ground. You are either on-chain, fully secured, or in-bridge, secured by whatever the bridge design provides.

## The Bridge Trilemma

Bridge designers face a trilemma similar to the classic blockchain trilemma. You can optimize for any two of three properties, but achieving all three simultaneously is extraordinarily difficult.

**Security** is the confidence that the bridge will not lose user funds â€” that locked assets will remain locked, that synthetic assets will always be redeemable, and that no unauthorized minting or unlocking can occur.

**Speed** is the time between initiating a cross-chain transfer and having the assets available on the destination chain. Multi-sig bridges can be fast â€” minutes or even seconds â€” because the guardians can attest quickly. ZK bridges are slower because proof generation takes time. Light client bridges fall somewhere in between, depending on the finality time of the source chain.

**Cost** is the expense of using the bridge â€” the gas fees, relayer fees, and liquidity provider fees that the user pays. Simple designs are cheap to operate. Cryptographically sophisticated designs require more computation and therefore cost more.

Multi-sig bridges optimize for speed and cost at the expense of security. ZK bridges optimize for security at the expense of speed and cost. Light client bridges occupy a middle ground but still require tradeoffs. No production bridge in 2026 has achieved all three at the level that would make cross-chain transfers as safe as on-chain transfers.

## What Builders Should Know

If your application requires cross-chain functionality â€” and increasingly, applications do â€” you are making a trust decision every time you choose a bridge. That decision should be explicit, documented, and proportional to the value at risk.

For low-value, high-frequency transfers â€” moving small amounts of stablecoins between L2s for day-to-day use â€” a fast multi-sig bridge with a reasonable guardian set may be acceptable. The speed and cost advantages outweigh the security risk for small amounts.

For high-value transfers â€” moving millions of dollars in protocol treasury funds, or bridging assets that back lending positions â€” the security requirements are radically different. You want the strongest verification possible. A multi-sig bridge with a 5-of-9 threshold is not appropriate for securing 50 million dollars in protocol assets. At that value, you should be using a bridge with light client or ZK verification, accepting the slower speed and higher cost as the price of not becoming the next headline.

For protocol design, minimize bridge dependencies wherever possible. Every cross-chain dependency in your architecture is a potential point of catastrophic failure. If your protocol's solvency depends on assets that are bridged from another chain, you are inheriting the bridge's security model as a hard dependency. If that bridge is compromised, your protocol is compromised â€” even if your own smart contracts are flawless.

The safest approach is to treat bridged assets as inherently riskier than native assets and architect accordingly. Set lower collateral ratios for bridged tokens. Cap the total exposure to any single bridge. Monitor bridge health â€” validator activity, reserve balances, upgrade history â€” the same way you would monitor any critical dependency. The bridge is not a pipe that assets flow through. It is a trust assumption your entire application rests on.

Cross-chain security is the trust problem that arises when two independent chains need to communicate. But there is another trust problem hiding in plain sight â€” not between chains, but within a single chain. Most Layer 2 rollups that promise Ethereum-level security route every transaction through a single company's server. That is the sequencer problem, and it is the subject of the next subchapter.
