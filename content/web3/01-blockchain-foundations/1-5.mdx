Scope: Web3

# 1.5 â€” Nodes: Who Runs the Machine

Who is actually running this global computer? When you submit a transaction on Ethereum or Solana, who receives it? When a block gets proposed, who validates it? When someone says a blockchain is "decentralized," what does that concretely mean â€” and who are the specific participants making that claim true or false?

The answer is **nodes**. A node is a computer running blockchain software that stores some or all of the network's state, validates transactions, and communicates with other nodes to maintain a shared view of reality. Nodes are the workforce of the state machine. Without them, the blockchain is an idea. With them, it is a running system.

The number of nodes, their geographic distribution, their hardware diversity, and their independence from each other determine whether a blockchain's decentralization claims are substance or marketing. This is not philosophy. It is engineering. And the numbers tell a very specific story.

## Full Nodes: The Backbone of Verification

A **full node** is a computer that stores the current state of the blockchain and independently validates every transaction and every block. When a new block arrives, the full node does not take anyone's word that the block is valid. It checks every transaction's signature, confirms every state transition follows the protocol's rules, verifies the block header references the correct previous block, and only then accepts the block into its local copy of the chain.

This independent verification is the entire point. If you run a full node, you do not need to trust any other participant in the network. You are not relying on a validator's honesty. You are not trusting a company's API to tell you the correct balance. You are computing the truth yourself, from raw data, using the same rules every other full node follows.

If a validator proposes a block containing an invalid transaction â€” say, a transfer that spends coins the sender does not have â€” your full node will detect the violation and reject the block, even if every other node in the world accepts it. Your node answers to the protocol rules, not to popularity.

Full nodes typically store the current state of all accounts and contracts but do not store every historical state. They can verify the present but cannot answer questions like "what was this contract's storage value at block 14,000,000?" For that, you need a specialized type of node.

Running a full node requires moderate hardware. On Ethereum, you need roughly 2 terabytes of fast SSD storage, 16 gigabytes of RAM, and a stable internet connection with reasonable bandwidth. This is achievable on consumer-grade hardware â€” a desktop computer or a dedicated mini-PC costing a few hundred dollars â€” which is a deliberate design choice.

The easier it is to run a full node, the more people will run one, and the more decentralized the network becomes. Ethereum's core developers have consistently resisted changes that would increase node requirements, even at the cost of lower throughput, because they understand that node accessibility is the foundation of decentralization.

## Light Nodes: Verification on a Budget

Not everyone can or wants to run a full node. A **light node** stores only the block headers â€” compact summaries of each block â€” rather than the full block data and state. Light nodes cannot independently validate every transaction. Instead, they verify specific pieces of information by requesting proofs from full nodes.

If you want to confirm that a particular transaction was included in a particular block, a light node can verify this using a Merkle proof â€” a compact mathematical proof that demonstrates inclusion without requiring the full block data.

Light nodes are the accessibility layer. They let mobile wallets, browser extensions, and resource-constrained devices participate in verification without storing hundreds of gigabytes of data. A light node cannot catch every invalid block the way a full node can, but it can verify the specific claims that matter to its user. For many applications, this is sufficient.

The tradeoff is trust. A light node trusts that the full nodes it queries are honest about the data they provide. Cryptographic proofs constrain this trust â€” a full node cannot fabricate a Merkle proof for a transaction that does not exist â€” but a light node is still more dependent on the network's honesty than a full node.

This is why the blockchain community constantly encourages people to run full nodes. Every full node strengthens the network's ability to detect and reject invalid blocks. Every light node that replaces a full node weakens that ability slightly.

## Archive Nodes: The Complete Historical Record

An **archive node** stores not just the current state but every historical state the blockchain has ever had. For every block that was ever produced, an archive node can tell you exactly what every account balance was, what every contract's storage contained, and what the result of any function call would have been at that point in time.

Archive nodes are essential for blockchain analytics, forensic investigations, historical DeFi research, and any application that needs to query past states. Block explorers like Etherscan run archive nodes. Analytics platforms that track historical protocol metrics run archive nodes. Auditors investigating a hack from six months ago rely on archive nodes to reconstruct the exact sequence of state changes that led to the exploit.

The cost is enormous. An Ethereum archive node requires roughly 14 to 18 terabytes of storage as of early 2026, and that number grows continuously as new blocks are added. The hardware requirements push archive nodes into the domain of well-resourced operators â€” companies, research institutions, and infrastructure providers.

Very few individuals run archive nodes. This creates a practical dependency: most people who need historical data rely on third-party archive node operators, which introduces a centralization pressure even on a network with thousands of full nodes. The current state is decentralized. The historical record, in practice, is not.

## Validator Nodes: The Decision Makers

On proof-of-stake networks, **validator nodes** are the participants who actively contribute to consensus. They propose new blocks, attest to the validity of blocks proposed by others, and collectively determine which blocks become part of the canonical chain.

Validators have economic skin in the game: they must lock up a stake â€” 32 ETH on Ethereum, varying amounts on other chains â€” as collateral that can be partially destroyed, a process called slashing, if they behave dishonestly.

Not every node is a validator. You can run a full node that validates every block independently without ever participating in consensus. But validator nodes are the ones that drive the chain forward. Without validators, no new blocks get proposed, no transactions get confirmed, and the state machine stops updating.

On Ethereum, there are over 1,000,000 active validators as of early 2026, but this number is somewhat misleading because a single operator can run thousands of validators. The number of unique entities running validators is far lower.

Lido, a liquid staking protocol, controls roughly 28 to 29 percent of all staked ETH, distributed across dozens of professional node operators. Coinbase, Binance, and other centralized exchanges collectively control another significant share. The network's validator count is high, but the concentration of staking power among a relatively small number of entities is a genuine centralization concern that the Ethereum community actively debates and works to mitigate.

## Solana's Validator Landscape

Solana's validator story looks dramatically different from Ethereum's â€” and the trajectory is surprising.

After a structured pruning program that the Solana Foundation began in April 2025, the network's active validator count dropped significantly. At the peak in early 2023, Solana had roughly 2,500 validators. By the end of 2025, the count had fallen below 1,000. More than 600 validators were systematically offboarded between April and December 2025, most of them deemed underperforming or non-contributing.

The Foundation framed this not as a retreat from decentralization but as a maturation of it â€” removing validators that were only participating because of Foundation delegation subsidies and strengthening the remaining set of independently viable operators. Whether you find this argument convincing depends heavily on your definition of decentralization.

The hardware requirements tell part of the story. Solana validators need high-performance CPUs, 512 gigabytes or more of RAM, and fast NVMe storage with enterprise-grade bandwidth. Running a Solana validator is not a hobby project. It is an infrastructure operation. This inherently limits the pool of potential operators to professional data center operators and well-funded enthusiasts.

## Why Node Count Is the Number That Matters

The number of independent nodes running a blockchain determines the system's resilience to censorship, corruption, and failure. This is not an abstract principle. It is an engineering constraint with direct consequences.

If a blockchain has only ten nodes, a government that wants to censor specific transactions needs to pressure only ten operators. If it has 10,000 nodes spread across 70 countries, censorship becomes a coordination problem that scales with political and jurisdictional complexity.

If a blockchain has nodes primarily in one country, a single regulatory action could shut down a majority of the network. If its nodes are spread globally, no single jurisdiction has that power.

Bitcoin is the most decentralized blockchain by node count, with over 25,000 reachable nodes as of February 2026 according to Bitnodes. These nodes are spread across dozens of countries, with significant concentrations in the United States, Germany, France, Finland, and Canada. Bitcoin's relatively low hardware requirements â€” a few hundred gigabytes of storage, modest CPU, moderate bandwidth â€” make it accessible to hobbyists, privacy advocates, and anyone with a spare computer and a reason to verify the chain independently.

Ethereum maintains roughly 11,000 active nodes, according to Etherscan's node tracker. This is a healthy count by any standard, though lower than Bitcoin's. The hardware requirements are higher than Bitcoin's, particularly the storage demands, which filter out some potential operators.

The Ethereum community is acutely aware of this and has invested significantly in light client research, statelessness proposals, and state expiry mechanisms designed to keep full node requirements manageable as the chain grows. The fear is not that node count will drop tomorrow â€” it is that growing state size will gradually price out smaller operators over the next decade.

Solana's node count is lower still. The network's hardware requirements are substantially higher than Ethereum's or Bitcoin's. A chain that produces a block every 400 milliseconds and processes thousands of transactions per second generates far more data for nodes to handle than a chain that produces a block every twelve seconds. The hardware barrier means Solana validators are almost exclusively professional operators running in data centers, not hobbyists in their living rooms.

## The Hardware Tradeoff

This tradeoff is fundamental and inescapable.

Lower hardware requirements equal more nodes equal more decentralization, but also lower throughput. Higher hardware requirements equal fewer nodes equal less decentralization, but also higher throughput. There is no free lunch.

Every blockchain navigates this tradeoff, and the choice it makes defines its character, its security model, and the types of applications it can credibly support. Bitcoin chose maximum decentralization. Solana chose maximum throughput. Ethereum chose a middle path and is scaling through Layer 2 solutions built on top of its relatively accessible base layer.

None of these choices are wrong. They serve different use cases. But they are real choices with real consequences, and understanding them is essential before you pick a chain to build on.

## What Happens When Nodes Disagree

Nodes communicate constantly, sharing new transactions, propagating proposed blocks, and synchronizing their view of the chain. Most of the time, this works smoothly. But sometimes nodes receive conflicting information.

Two validators might propose valid blocks at the same height. Network partitions might cause some nodes to see one version of reality and others to see a different version. Software bugs might cause a subset of nodes to accept blocks that others reject.

When nodes disagree about which blocks are canonical, the result is a **fork** â€” a split in the chain where two or more competing versions of history exist simultaneously. Forks are not catastrophic. The consensus protocol includes a **fork-choice rule** â€” an algorithm that tells nodes which fork to follow when they encounter a conflict. On Bitcoin, the rule is simple: follow the chain with the most accumulated proof of work. On Ethereum, the rule is more complex, involving the weight of validator attestations.

Most forks are temporary. Two competing blocks get proposed, nodes briefly disagree, and within one or two block times the fork resolves as one chain accumulates more support. The losing fork's transactions return to the mempool to be included in a future block on the winning chain. No funds are lost, though users might experience brief confusion if they were watching the losing fork.

Deliberate forks are a different matter. When the Ethereum community decided to reverse the 2016 DAO hack by rolling back the state, a meaningful minority of participants refused to accept the rollback and continued the original chain as Ethereum Classic. This was a social fork â€” a fundamental disagreement about governance philosophy that resulted in two permanently separate networks. Social forks are rare but consequential, and they illustrate that blockchain governance is ultimately a human problem, not a technical one. We will explore consensus mechanics and fork dynamics in detail in Chapter 2.

## Running Your Own Node vs. Trusting a Provider

Here is a question that separates people who understand decentralization from people who repeat slogans about it: when you use a blockchain application â€” swap tokens on Uniswap, check your balance, send a payment â€” how does your device actually communicate with the blockchain?

The answer, for the vast majority of users, is through an **RPC provider** â€” a company that runs nodes and exposes an API that your wallet, your application, or your browser extension calls to read state and submit transactions.

The two dominant RPC providers are Infura and Alchemy. When you open MetaMask and see your ETH balance, in most cases you are not querying the Ethereum network directly. You are making an API call to Infura. When you submit a swap on Uniswap, your transaction flows through Infura's nodes before being broadcast to the wider network.

This is a centralization problem that most users do not think about.

## The Infura Outage and What It Revealed

If Infura goes down, a huge fraction of Ethereum-connected applications stop working â€” not because Ethereum itself is down, but because the interface layer between users and the network is concentrated in a handful of providers.

This has happened. In November 2020, Infura experienced an outage that disrupted MetaMask and numerous DeFi applications for hours. Ethereum kept producing blocks. Validators kept validating. But users could not reach the network because their entry point was a single company's infrastructure.

The incident revealed a structural irony. A network designed to eliminate single points of failure had developed a massive single point of failure in its access layer. The base layer was decentralized. The last mile was not.

Running your own node eliminates this dependency. Your application talks directly to your own node, which is connected to the peer-to-peer network. You do not depend on any company's uptime, any company's API rate limits, or any company's terms of service. You verify everything yourself.

For developers building serious applications, running your own node is not a luxury â€” it is a professional responsibility. For users, the calculus is different. Running a node requires technical knowledge, ongoing maintenance, and hardware. Most users will continue to rely on RPC providers, and that is a reasonable choice for individual use. But it is important to understand the trust assumption you are making when you do.

## The RPC Centralization Problem

The dependency on centralized RPC providers runs deeper than uptime risk.

An RPC provider can theoretically censor transactions â€” refusing to broadcast specific transactions to the network. They can track user activity â€” logging which addresses query which contracts, which creates a privacy risk even on pseudonymous networks. They can serve incorrect data â€” though cryptographic verification mechanisms like Merkle proofs can catch some forms of dishonesty, not all queries are easily verifiable.

The community is aware of this problem and is working on solutions. Decentralized RPC networks like Pocket Network and Lava Network route queries across a distributed set of node operators rather than through a single company. Light client research aims to let wallets verify state directly without full nodes, reducing the need for trusted intermediaries.

But as of early 2026, the reality is that a large majority of Ethereum traffic flows through a small number of centralized providers. This is one of the most important gaps between blockchain's decentralization promise and its operational reality. The chain itself is decentralized. The access layer is not.

Acknowledging this gap honestly is the first step toward closing it. Pretending it does not exist is the step that guarantees it persists.

## Nodes as the Immune System

Nodes are not just infrastructure. They are the blockchain's immune system.

Every full node independently enforces the protocol rules. If a validator produces an invalid block â€” one that violates a consensus rule, includes a forged transaction, or attempts to spend coins that do not exist â€” every full node will independently detect the violation and reject the block. The validator might control billions of dollars in stake. It does not matter. The protocol rules are not negotiable, and they are enforced not by any authority but by every node simultaneously.

This is why node diversity matters as much as node count. If 90 percent of nodes run the same client software â€” the same implementation of the protocol â€” then a bug in that software could cause 90 percent of the network to accept an invalid block.

Ethereum experienced a version of this risk when the Prysm consensus client held a supermajority share of validators. A bug in Prysm could have caused a chain split or, worse, could have finalized invalid state. The Ethereum community responded with a sustained campaign to diversify client usage, encouraging validators to switch to alternative clients like Lighthouse, Teku, Nimbus, and Lodestar. By early 2026, client diversity has improved significantly, though the effort remains ongoing.

The lesson extends beyond client software. Geographic diversity matters â€” nodes should not be concentrated in one country or one data center provider. Operator diversity matters â€” nodes should not be controlled by one company or one staking pool. Hardware diversity matters â€” if every node runs on the same cloud provider, that provider becomes a single point of failure.

Decentralization is not a single number. It is a multi-dimensional property that requires constant attention and active maintenance.

## The Node Operator's Decision

If you are building on a blockchain, at some point you will face the decision of whether to run your own node. The answer depends on what you are building and what trust assumptions you are comfortable with.

For a consumer wallet or a hobby project, using a managed RPC provider like Alchemy or Infura is reasonable. The convenience is worth the trust assumption for low-stakes applications.

For a DeFi protocol managing significant user funds, running your own nodes â€” ideally multiple nodes across different client implementations and geographic regions â€” is a matter of operational responsibility.

For a company whose business depends on blockchain data accuracy, node independence is an infrastructure requirement, not an optimization.

The cost of running your own node is modest. An Ethereum full node can run on hardware costing 500 to 1,000 dollars, with electricity and bandwidth adding perhaps 20 to 40 dollars per month in most regions. The barrier is not financial â€” it is operational. Keeping a node synchronized, handling software updates, monitoring for issues, and maintaining uptime requires ongoing attention.

For many teams, the right answer is a hybrid approach: run your own primary node for critical operations and use a managed provider as a fallback. This gives you independence for the operations that matter most while keeping a safety net for availability.

What matters is that you make this decision consciously, understanding the tradeoffs, rather than defaulting to a centralized provider because that is what the quickstart guide suggested. Every centralized dependency you accept is a place where the blockchain's decentralization guarantees stop applying to your specific use case. That might be acceptable. But you should know exactly where those boundaries are.

The machine runs because people choose to run it. Validators, full node operators, archive node providers, RPC services â€” they form a layered ecosystem of participation, each with different motivations, different costs, and different trust assumptions. Understanding this ecosystem is understanding what decentralization actually means in practice, not in theory. The next subchapter moves from who runs the machine to what makes it programmable â€” the concept that transformed blockchains from simple payment ledgers into general-purpose computing platforms.
