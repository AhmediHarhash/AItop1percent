# 1.1 Everything You Think You Know Is the Brochure
Scope: Web3

## The Opening Fracture
A chain is often sold as a trust machine before people ask the harder question, what breaks first.

Mechanism. Trust in Web3 comes from repeated agreement rules, not from good marketing copy. If those rules are weak, every layer above them, from wallet UX to treasury logic, becomes fragile.

Example. A platform can publish a bright user interface while still producing ambiguous state during peak stress.

Detection. If onboarding materials promise instant certainty but support sees repeated reversals, your first bug is a mismatch between narrative and protocol assumptions.

Mitigation. Define trust boundaries before any feature, including how long you wait before calling a state final.

Failure consequence. Products that overpromise trust fail when users meet the first network dispute.

## Why Open Systems Reject Central Scripts
Central systems can patch behavior through operator override. Open networks cannot patch that way without broader coordination.

Mechanism. You are designing for many independent participants, each with incentives and partial failure modes.

Example. A fee bump may solve a queue issue in one centralized setup, but not guarantee inclusion in a hostile order stream.

Detection. Track how frequently equivalent stress patterns produce inconsistent answers across services.

Mitigation. Build governance and operations as part of protocol assumptions.

Failure consequence. Assuming operator style control in open settings creates hidden single points and blind spots.

## The Shared History Assumption
Every participant must eventually accept a shared state history.

Mechanism. That shared history is the same for all honest nodes or you no longer have one system.

Example. If two users see different wallet balances for the same action at the same moment, your stack is no longer acting as a system.

Detection. Diff your balance service outputs and reconcile against canonical checkpoints.

Mitigation. Treat disagreement as a production condition and build recovery paths.

Failure consequence. Ambiguous histories break settlement and legal accountability.

## Why This Chapter Is Not Intro and Not Academic
You are not learning trivia. You are learning what to harden first.

Mechanism. Each concept in this chapter turns into one concrete design decision later.

Example. Understanding replicated state and node roles directly changes how you set up monitoring and incident budgets.

Detection. If operations depends on one person understanding the model, risk is already too high.

Mitigation. Write this chapter into your architecture notes as required logic.

Failure consequence. Teams that move without this model usually spend more on fixes than on design.

## The First Lesson About Scope
A product is not blockchain safe because it includes a chain. It is safe because chain behavior is mapped to business expectations.

Mechanism. Scope leaks where expectations are set, from user promises to settlement windows.

Example. A loyalty flow can tolerate different guarantees than a lending liquidation flow.

Detection. Compare user promises against chain behavior for every action class.

Mitigation. Add per-flow constraints with explicit uncertainty windows.

Failure consequence. Scope confusion produces feature-level outages and user loss.

## Your Mental Model Anchor
You will use three words repeatedly in this book: finality, fork, and assumption.

Mechanism. If you can explain those three accurately for your product, you can explain most failures before they happen.

Example. For a withdrawal flow, finality means you do not expose funds as irrevocably moved until thresholds are met.

Detection. Audit one real user journey for each flow and mark where each assumption is validated.

Mitigation. Turn this into pre-release checklists.

Failure consequence. Without this anchor, bugs are explained only after they are already live.

## Bridge to the Next Chapter
The next section breaks this model into a concrete machine pattern: replicated state, deterministic transitions, and why order is not a nice-to-have.
