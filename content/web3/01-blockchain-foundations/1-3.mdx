# 1.3 State, Transitions, and Finality
Scope: Web3

## Finality Is a State Quality Label
State alone is not enough. You need certainty labels for state.

Mechanism. Finality is the measure of how likely a state transition is to remain unchanged.

Example. A newly observed transfer can be valid now and still be invalid after a deeper reorganization later.

Detection. Track how often state assertions are revised within confidence windows.

Mitigation. Segment actions by confirmation depth and reversibility tolerance.

Failure consequence. Treating provisional state as final leads to irreversible product actions at the wrong time.

## What Changes State in Practice
Two systems apply change: consensus rules and application logic.

Mechanism. Consensus chooses which proposals advance, while logic validates each transition.

Example. A transaction can be valid by itself yet fail to become part of canonical history.

Detection. Monitor proposed state changes versus finalized ones.

Mitigation. Keep separate stores for pending and finalized updates.

Failure consequence. Mixing these streams confuses accounting and reward logic.

## The Transition Timing Problem
Users ask for instant confirmation, systems answer with a timeline.

Mechanism. Confirmation is a statistical and consensus-backed process.

Example. A payment shown on screen immediately may still carry short-term rollback risk.

Detection. Map expected state revision probability by confirmation depth.

Mitigation. Use staged user messaging and staged settlement actions.

Failure consequence. Early actions taken on low-confidence state create support incidents and loss.

## Why Finality Is Not Binary
Most production systems move through states, not switches.

Mechanism. Pending to confirmed to final is a risk ladder.

Example. A liquidation engine can use pending updates for internal calculation but wait for finality before fund movement.

Detection. Measure transition times and slippage between each state tier.

Mitigation. Define explicit policies for each tier.

Failure consequence. Binary assumptions cause overreaction on noise and underreaction on real risk.

## The Bridge to Cross-System Actions
Cross-system actions often rely on state from another chain.

Mechanism. A chain confirmation policy becomes the source constraint for bridge and oracle actions.

Example. A source chain reorg after confirmation can trigger invalid settlement downstream.

Detection. Test relay assumptions with forced confirmation stress.

Mitigation. Add delay buffers and rollback-aware design.

Failure consequence. Bridges often fail from overconfident state transfer assumptions.

## Practical Design Signal
Finality planning is a product requirement, not a chain afterthought.

Mechanism. You should choose action gates from day one and measure deviations.

Example. A single global setting for all flows rarely fits mixed risk needs.

Detection. Audit each flow for mismatch between stated guarantee and used threshold.

Mitigation. Build per-flow policies and enforce them in code.

Failure consequence. One wrong threshold propagates across high-value flows first.

## Bridge to the Next Section
Next, we focus on how transactions are packed into blocks and how those blocks lock in state progression.
