Scope: Web3

# 1.3 â€” State, Transitions, and Finality

Every behavior you will ever observe on a blockchain reduces to three concepts. State is what the machine knows right now. A transition is a valid change to that knowledge. Finality is the guarantee that a change cannot be undone. If you understand these three ideas with precision, you can diagnose any blockchain problem, evaluate any protocol, and predict the failure modes of any architecture before you write a single line of code.

These are not abstractions invented for textbooks. They are the operational vocabulary of every engineer who has ever debugged a stuck transaction, architected a payment settlement system, or investigated why a bridge got exploited. The teams that get these concepts right build systems that work under pressure. The teams that treat them as background theory build systems that break the moment real money is at stake.

## State: Everything the Machine Knows Right Now

State is the complete data snapshot of the system at a specific moment in time. Not a partial view. Not a summary. The entire thing â€” every account, every balance, every byte of contract storage, every configuration variable. If you took a photograph of the blockchain's memory at block number ten million, that photograph is the state at block ten million.

On Ethereum, state is organized into four layers. The first layer is account balances. Every address on the network â€” whether it belongs to a person with a private key or to a deployed smart contract â€” has an ETH balance. This balance can be zero, but the account still exists in the state tree once it has been touched. The second layer is contract code. When you deploy a smart contract, its compiled bytecode is written to the state and associated with the contract's address. That bytecode is immutable â€” it cannot be changed after deployment, which is why upgradeability patterns use proxy contracts that delegate execution to a separate implementation address. The third layer is contract storage. Each smart contract has its own persistent key-value store. A lending protocol stores outstanding loan balances. A decentralized exchange stores liquidity pool reserves. A governance contract stores vote tallies. This storage persists between transactions and between blocks â€” it is the contract's memory. The fourth layer is nonces. Every externally owned account has a nonce that increments with each transaction sent. This counter serves a critical security function: it prevents replay attacks, where someone rebroadcasts a previously valid transaction to execute it a second time.

The size of this state matters enormously. Ethereum's state has grown to over 383 million unique addresses per Etherscan data as of early 2026, and the raw state data requires over 50 gigabytes of storage. Every full node on the network must maintain this state to validate new transactions. As state grows, the hardware requirements for running a node increase, which affects decentralization â€” fewer people can afford to run nodes. This tension between state growth and node accessibility is one of the deepest unsolved challenges in blockchain engineering. The planned Verkle Trees upgrade in the Hegota hard fork, expected in late 2026, aims to compress state proofs dramatically and enable stateless clients that can validate blocks without storing the complete state.

Bitcoin's state model is structurally different. Bitcoin does not track accounts with balances. It tracks unspent transaction outputs, commonly called UTXOs. When you receive 0.5 BTC, that creates a UTXO â€” a discrete unit of value tied to your address. When you spend it, that UTXO is consumed and new UTXOs are created for the recipient and for your change. The state of Bitcoin at any moment is the complete set of all unspent outputs â€” every coin that exists and has not yet been spent. This model is simpler than Ethereum's, which is by design. Bitcoin's state machine is intentionally narrow: it moves value, and that is nearly all it does.

Solana takes yet another approach. Everything on Solana is an account â€” user wallets, deployed programs, program data, token balances. But unlike Ethereum, where contract storage is bundled inside the contract's state, Solana separates programs from their data. A program is stateless code. Data lives in separate accounts that are passed into the program as arguments when a transaction executes. This separation is what allows Solana's runtime to execute transactions in parallel: if two transactions touch different accounts, they can run simultaneously without conflict. The architectural choice at the state layer directly determines the performance characteristics of the entire system.

## Why State Is Not History

A subtle but critical distinction: state is not the same thing as history. History is the sequence of all transactions that have ever been executed. State is the result of applying all of those transactions, in order, starting from the initial genesis state.

This distinction matters for builders because it determines what you can and cannot query efficiently. If you want to know the current balance of an address, you query the state. Any node can answer this instantly â€” it is just a lookup in the state tree. If you want to know every transaction that address has ever sent or received, you need the history. Nodes store history, but querying it is much more expensive and many node operators prune old history to save storage.

This is why indexing services exist. The Graph, Dune Analytics, Helius, Flipside â€” these services reconstruct and index the full transaction history so that applications can query it efficiently. If your application needs historical data, you cannot just ask a node. You need an indexer. Confusing state with history is one of the most common architectural mistakes in Web3 development, and it leads to applications that are either painfully slow or prohibitively expensive to operate.

## Transitions: The Rules of Change

A **transition** is a valid operation that changes the state from one snapshot to the next. The word "valid" is doing heavy lifting in that sentence. Not every proposed change is accepted. The transition function â€” the set of rules embedded in the protocol and in smart contract code â€” determines which operations are allowed and which are rejected.

Consider a simple ETH transfer. You want to send two ETH to another address. The transition function checks several conditions. Does your account have at least two ETH plus enough to cover the gas fee? Is the transaction nonce exactly one more than the last nonce used by your account? Is the cryptographic signature valid â€” did the holder of the private key actually authorize this transaction? Is the gas price sufficient for the current network conditions?

If every condition passes, the transition executes: your balance decreases, the recipient's balance increases, your nonce increments, and the gas fee is distributed to the validator who included the transaction. If any condition fails, the transition is rejected. The state does not change. It is as if the transaction never existed.

Smart contract interactions follow the same pattern but with additional complexity. When you call a function on a smart contract, the Ethereum Virtual Machine loads the contract's bytecode and executes it. During execution, the contract can read its own storage, write to its own storage, check the caller's address, verify the amount of ETH sent with the call, call other contracts, emit events, and eventually return a result. If at any point during execution an invalid condition is encountered â€” insufficient funds in the contract, a failed requirement check, running out of gas â€” the entire transaction reverts. Every state change made during that execution is rolled back. The state returns to exactly what it was before the transaction began.

This all-or-nothing behavior is called **atomicity**, and it is one of the most powerful properties of blockchain state transitions. In traditional software, a function that fails halfway through might leave the system in an inconsistent state â€” money deducted from one account but not credited to another. On a blockchain, that cannot happen. Either the entire transition succeeds and all state changes are applied, or it fails and none of them are. There is no in-between. Builders who come from traditional backend engineering often underestimate how much this simplifies certain kinds of application logic, and how much it changes the way you think about error handling.

## The Transition Function: Determinism as Law

The transition function must be deterministic. Given the same starting state and the same transaction, every node in the network must compute exactly the same resulting state. If even one node computes a different result, the replicated state machine has diverged, and the network can no longer agree on what is true.

This requirement has profound consequences for what blockchain programs can and cannot do. A smart contract cannot generate a random number by asking the operating system for one, because different nodes would get different random numbers and compute different states. A smart contract cannot fetch the current price of ETH from an API, because different nodes might get different responses, or some might get no response at all. A smart contract cannot read the current wall-clock time with precision, because clocks drift differently on different machines.

These are not arbitrary limitations. They are physical consequences of replication. Any source of non-determinism â€” any input that could differ from one machine to another â€” is a threat to consensus. This is why oracles exist: they are mechanisms that bring external data on-chain in a deterministic way, by having a trusted party or a decentralized committee agree on a single value and post it to the state, where all nodes can read the same number.

It is also why on-chain randomness is genuinely difficult. Protocols like Chainlink VRF and Drand generate verifiable random numbers by combining cryptographic commitments from multiple parties, but the process is more complex and more expensive than simply calling a random function. Every apparent limitation of smart contract programming traces back to this single cause: the transition function must be deterministic, because determinism is the price of replication.

## Invalid Transitions and What Rejection Means

Not all transactions succeed. When the transition function determines that a proposed operation violates the rules, the transaction is rejected â€” but what "rejected" means depends on when the violation is caught.

Some violations are caught before the transaction enters a block. If you submit a transaction with an invalid signature, nodes will not even propagate it through the network. If your nonce is wrong â€” for example, you already sent a transaction with that nonce â€” nodes will drop it from their mempool. These transactions never reach the consensus layer and never cost you gas, because they are never executed.

Other violations are caught during execution. You submit a valid transaction that calls a smart contract, but the contract's logic reverts â€” maybe you tried to withdraw more tokens than you deposited, or you called a function that requires admin privileges you do not have. In this case, the transaction is included in a block and executed, but it reverts. On Ethereum, a reverted transaction still costs gas. You pay for the computation the network performed up to the point of failure. The state changes from the reverted transaction are rolled back, but the gas fee is still deducted from your account. This is intentional: without it, attackers could flood the network with complex transactions that always fail, consuming node resources for free.

This distinction matters for application design. If your application regularly submits transactions that revert, your users are paying gas for nothing. Simulating transactions before submission â€” using tools like Tenderly or Alchemy's simulation API â€” lets you catch reverts before they cost real money. Production-grade Web3 applications always simulate first, submit second.

## Finality: When Done Means Done

**Finality** is the guarantee that a state transition will not be reversed. It is the point after which you can treat the new state as permanent â€” the money has arrived, the vote has been recorded, the trade has settled.

This concept is simple to state and treacherous to implement. The treachery comes from the fact that different blockchains provide different types of finality, with different speeds, different guarantees, and different failure modes. If you do not understand your chain's finality model, you will either wait too long to act on confirmed transactions, losing time and user experience, or you will act too early on unconfirmed transactions, exposing yourself to reversals and financial loss.

There are two fundamental types. **Probabilistic finality** means that a transaction becomes increasingly unlikely to be reversed as more blocks are added on top of it, but there is never a moment where reversal becomes mathematically impossible. **Deterministic finality** means that once a transaction reaches a specific checkpoint, the protocol guarantees it will never be reversed, and any validator who tries to reverse it will lose their stake.

## Probabilistic Finality: Bitcoin's Model

Bitcoin uses probabilistic finality. When your transaction is included in a block, it has one confirmation. When the next block is added, it has two. Each additional block makes reversal exponentially more expensive, because an attacker would need to re-mine every subsequent block with more computing power than the rest of the network combined.

The industry convention is six confirmations â€” approximately sixty minutes â€” for a Bitcoin transaction to be considered final. This number comes from a calculation about the probability that an attacker with less than 50 percent of the hashrate could produce a longer competing chain. At six confirmations, that probability drops below one in a million for any attacker with less than 30 percent of the network's hashrate. In practice, many exchanges have recently reduced this to three confirmations due to the massive growth in Bitcoin's hashrate, which makes attacks proportionally more expensive. But the fundamental model has not changed: there is no moment of absolute finality. There is only an asymptotic approach toward certainty.

For builders, this means you must make a decision: how many confirmations does your application require? A coffee payment might accept one confirmation â€” the risk of reversal is low and the stakes are small. An exchange deposit should wait for three to six. A high-value settlement should wait for six or more. The choice depends on your risk tolerance and the value at stake. There is no universally correct answer.

## Deterministic Finality: Ethereum's Model

Ethereum, since the Merge in September 2022, provides deterministic finality through Casper FFG â€” Friendly Finality Gadget. The protocol works in epochs, each consisting of 32 slots of 12 seconds each. At the end of each epoch, validators vote on a checkpoint. When a checkpoint receives attestations from validators representing at least two-thirds of the total staked ETH, it becomes justified. When the next checkpoint after a justified checkpoint is also justified, the first checkpoint becomes finalized.

In practice, this means Ethereum transactions reach deterministic finality in approximately 12.8 minutes â€” two full epochs. Once a transaction is in a finalized block, reverting it would require at least one-third of all staked validators to collude, and they would lose their entire stake in the process. As of early 2026, over 34 million ETH is staked on Ethereum, making the economic cost of attacking finality astronomical.

This two-epoch finality window has real consequences for application design. If you are building a bridge that transfers assets between Ethereum and another chain, you should wait for finality before releasing assets on the other side. If you release early â€” after one or two confirmations instead of waiting for finality â€” and the source chain reorganizes, the bridge creates tokens that are not backed by anything. This is not hypothetical. Multiple bridge exploits in 2022 and 2023 were caused by insufficient finality checks. The Wormhole exploit, the Ronin bridge attack â€” the root causes varied, but insufficient respect for finality boundaries was a contributing factor in the design of bridge security assumptions.

Ethereum's research community has been working on Single Slot Finality, which would reduce finality time to a single slot â€” 12 seconds. This is still in the research phase as of early 2026, but it reflects the broader principle: faster finality with the same economic guarantees is one of the most valuable improvements a blockchain can make.

## Sub-Second Finality: Solana and the Frontier

Solana currently achieves confirmation in approximately 400 milliseconds, but full finality â€” the point where a transaction is guaranteed against reversal â€” takes longer, typically around 12.8 seconds under Solana's Tower BFT consensus.

The Alpenglow upgrade, targeted for the first half of 2026, aims to dramatically change this. Alpenglow introduces a new consensus mechanism built on two components: Votor and Rotor. Votor can finalize a block in a single round if 80 percent of stake votes in support, or in two rounds if 60 percent responds. Rotor optimizes block propagation, achieving distribution across the network in as little as 18 milliseconds under normal bandwidth conditions.

If Alpenglow delivers on its design goals, Solana will achieve finality in 100 to 150 milliseconds. That is faster than a human blink. It is faster than most API round trips. It would make Solana's finality comparable to the response time of a traditional database, while maintaining the security guarantees of a replicated state machine with hundreds of validators.

For builders, sub-second finality changes what is architecturally possible. Payment applications can confirm in real time. DeFi protocols can settle without multi-block waiting periods. Games can use on-chain state for real-time mechanics without noticeable lag. The finality speed of a blockchain directly determines the category of applications it can support, and the gap between Bitcoin's sixty-minute probabilistic finality and Solana's targeted 150-millisecond deterministic finality is not just a performance difference â€” it is a difference in kind.

## Why Finality Matters for Every Builder

If you are building anything that involves value â€” payments, trading, lending, bridges, real-world asset settlement â€” finality is the single most important property you need to understand about your chosen blockchain.

Acting before finality means accepting the risk of reversal. In the best case, a reversal is an inconvenience â€” a transaction that appeared to succeed but later disappeared, requiring your application to reconcile. In the worst case, a reversal is a double-spend attack. The attacker sends tokens to your exchange, trades them for a different asset, withdraws the new asset, and then the original deposit transaction is reversed by a chain reorganization. The attacker has the new asset. Your exchange has nothing. You lost real money because you acted on a state transition that was not yet final.

The cost of getting finality wrong is not theoretical. In 2024, a mid-sized exchange lost over two million dollars to a reorganization attack on a lower-hashrate EVM chain. They had set their confirmation requirement to two blocks for faster user experience. The attacker waited for a low-hashrate period, submitted a large deposit, received credit, withdrew to a different chain, and then reorganized the two blocks containing the deposit. The exchange learned the relationship between finality and financial risk in the most expensive way possible.

Finality also determines bridge security. A bridge that transfers assets between two blockchains must wait for finality on the source chain before releasing assets on the destination chain. If it does not wait, a reorganization on the source chain can erase the locked assets while the minted assets on the destination chain remain â€” creating unbacked tokens and an insolvent bridge. Every serious bridge architecture in 2026 waits for finality. The ones that did not are no longer operating.

Even within a single chain, finality affects application design. A lending protocol that allows borrowing against newly deposited collateral must decide how many confirmations to wait before recognizing the deposit. A prediction market that resolves based on on-chain events must wait for finality before distributing payouts. An NFT marketplace that shows a "sold" badge must decide whether to show it at first confirmation or at finality. Every one of these is a product decision that requires understanding the finality model of your chain.

## The Finality Spectrum

It is tempting to think of finality as binary â€” either a transaction is final or it is not. In practice, finality is a spectrum, and your application needs to decide where on that spectrum it is comfortable acting.

At one end of the spectrum is zero confirmations. The transaction has been broadcast to the network but has not been included in any block. It exists in the mempool â€” the waiting area where unconfirmed transactions sit. At this stage, the transaction can be replaced, dropped, or outbid. Acting on a zero-confirmation transaction is extremely risky for anything involving value. Some consumer payment applications accept this risk for small amounts, betting that the probability of fraud is low enough to absorb the occasional loss. This is a business decision, not a technical one.

At the middle of the spectrum is partial confirmation â€” the transaction has been included in one or more blocks but has not reached the chain's finality threshold. On Ethereum, a transaction with one confirmation is included in a block but has not been finalized by Casper FFG. It is extremely unlikely to be reversed â€” chain reorganizations on Ethereum are rare and typically only affect one or two blocks â€” but the protocol does not yet guarantee irreversibility. Most DeFi applications treat one or two confirmations as sufficient for on-chain interactions, because the economic cost of reorganizing Ethereum far exceeds the value of most individual transactions.

At the far end of the spectrum is full finality â€” the transaction has passed the chain's finality checkpoint and is guaranteed irreversible by the protocol's economic security model. On Ethereum, this takes approximately 12.8 minutes. On Bitcoin, the industry standard is sixty minutes. On Solana with Alpenglow, it will be 100 to 150 milliseconds.

Where your application sits on this spectrum determines its user experience, its security model, and its vulnerability to attack. There is no right answer for all cases. There is only the right answer for your specific combination of risk tolerance and value at stake.

## State Bloat: The Silent Scaling Problem

State growth is a challenge that every blockchain faces and no blockchain has fully solved. Every new account, every new contract deployment, every byte of data written to contract storage â€” all of it increases the total state that every full node must maintain.

On Ethereum, the state has grown steadily since genesis in 2015. The raw state data now exceeds 50 gigabytes, and the full archive â€” the complete historical state at every block â€” requires multiple terabytes. Running an Ethereum full node requires a fast SSD, significant RAM, and a modern multi-core processor. In 2020, a moderately capable desktop could run a full node. By 2026, the hardware requirements have crept up enough that casual participation is harder, which is why the Verkle Trees upgrade matters so much.

Verkle Trees, planned for the Hegota upgrade in late 2026, replace the current Merkle Patricia Trie state structure with a more efficient cryptographic commitment scheme. The key improvement is proof size. In the current Merkle tree, proving that a particular piece of state exists requires a proof that grows logarithmically with the size of the tree â€” and for Ethereum's tree, that means proofs of several kilobytes. Verkle Trees compress these proofs to approximately 200 bytes per account in the average case. This compression enables stateless clients â€” nodes that can validate blocks without storing the complete state, because the proofs included with each block are small enough to be practical.

If stateless clients become viable, the hardware requirements for participating in the network drop dramatically. You no longer need 50 gigabytes of fast storage to validate blocks. You need only the proofs included in each block, plus enough bandwidth to receive them. This is how Ethereum plans to maintain decentralization even as state grows: not by preventing state growth, which is impossible if the network is being used, but by making it unnecessary for every participant to store the complete state.

Solana faces the same challenge from a different angle. Solana's account model means that state growth is explicit â€” every new piece of data is a new account, and accounts cost rent to maintain. If an account's balance falls below the rent-exempt threshold, it can be garbage collected. This rent mechanism is Solana's answer to state bloat: if you want the network to store your data indefinitely, you must pay for it upfront. The mechanism is not perfect, but it creates an economic pressure against unbounded state growth that Ethereum's model lacks.

## Composability: Transitions That Trigger Transitions

One of the most powerful consequences of the state machine model is composability. A single user-initiated transition can trigger a cascade of further transitions within the same atomic execution.

When you swap tokens on a decentralized exchange like Uniswap, your single transaction triggers multiple state changes: your input tokens are transferred to the pool, the pool's reserves are updated according to the pricing formula, output tokens are transferred from the pool to your address, a fee is deducted and distributed to liquidity providers, and the pool's price is updated for the next trade. All of these changes happen within one atomic transition. If any step fails, every step reverts.

This composability extends across contracts. A single transaction can interact with a lending protocol, a decentralized exchange, and a yield aggregator in sequence â€” all atomically. This is what makes DeFi "money legos." Each protocol is a set of transition rules that other protocols can invoke. The state machine guarantees that the entire composed operation either succeeds completely or fails completely. No partial execution. No inconsistent intermediate states.

Composability is not a feature that was designed on purpose. It is an emergent property of the state machine architecture. Because all contracts share the same state and all transitions are atomic, any contract can call any other contract within the same transition. This has produced financial products and coordination mechanisms that have no analog in traditional finance â€” flash loans, for example, which borrow and repay within a single atomic transition, could not exist without the atomicity guarantee.

But composability also creates risk. If one contract in a composed call chain has a bug, it can affect every other contract in the chain. Reentrancy attacks â€” where a malicious contract calls back into the calling contract before the first call completes â€” exploit composability to drain funds. The same property that enables innovation also enables exploitation. Understanding this is essential for builders.

## The Three Concepts Together

State, transitions, and finality are not three separate topics. They are three facets of the same machine.

State tells you what the machine knows. Transitions tell you how that knowledge changes. Finality tells you when a change becomes permanent. Together, they define the complete behavior of any blockchain. When you encounter a new protocol, ask three questions. What is in the state? What transitions are allowed? When does finality occur? The answers give you everything you need to evaluate whether that protocol is suitable for your use case.

These three concepts also give you a diagnostic framework. When something goes wrong â€” and something always goes wrong â€” you can trace the problem to one of the three. A failed transaction is a rejected state transition. A stuck transaction is a transition that has not reached finality. A stale balance is a state query that is not reading the latest state. A double-spend exploit is a finality violation. A contract bug is a flawed transition function. Every blockchain failure mode maps to state, transitions, or finality.

Ethereum processed a record 2.88 million transactions â€” 2.88 million state transitions â€” in a single day in January 2026, per Etherscan data. Each of those transitions changed the state according to deterministic rules. Each one progressed through the Casper FFG finality pipeline until it became irreversible. The system handled nearly three million state changes in 24 hours while maintaining perfect consistency across thousands of nodes. That is the replicated state machine, operating at scale, doing exactly what it was designed to do.

The next subchapter examines the packaging layer that sits on top of the state machine: blocks, transactions, and the append-only log that gives "blockchain" its name.
