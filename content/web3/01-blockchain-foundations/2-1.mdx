# 2.1 The Agreement Problem
Scope: Web3

## Why Agreement Is the Core Constraint
You cannot build a dapp before the network can agree on one outcome.

Mechanism. A chain is a distributed system where each node validates inputs independently. Agreement means all honest nodes eventually converge on the same accepted order.

Example. If two nodes see different transaction orderings for the same block window, user balances diverge.

Detection. Compare state snapshots across independent nodes and alert when balances diverge from expected reconciliation.

Mitigation. Define explicit assumptions on finality, reconciliation windows, and acceptable discrepancy handling before shipping.

Failure consequence. Divergence appears as contradictory balances, disputed withdrawals, and lost trust in every layer above the protocol.

## Why Permissionless Systems Do Not Have a Central Corrector
In a centralized system, one operator can arbitrate disagreement. In a permissionless chain, that authority is replaced by protocol rules.

Mechanism. Consensus chooses which valid history becomes canonical by requiring participants to validate, vote, or produce proof.

Example. A chain cannot simply discard a block because one operator disagrees; it needs protocol-based resolution.

Detection. Track how often clients reject blocks that were previously accepted by peers.

Mitigation. Build fork handling and rollback-aware flows in your app from day one.

Failure consequence. If your app expects a human to correct conflicts, you will be late during the first real event.

## The Three Tradeoff Axes
Safety, liveness, and fairness can be balanced, but never perfect at once in every condition.

Mechanism. Safety means no two final histories, liveness means progress continues, fairness means no one participant permanently controls outcomes.

Example. Fast block times may improve liveness but can increase short-lived temporary uncertainty.

Detection. Monitor reorg depth, proposal delays, and concentration signals together.

Mitigation. Choose your chain and product settings based on which axis is critical for your business.

Failure consequence. Overemphasizing one axis produces blind spots in the others.

## Why Network Reliability Changes the Math
The classic impossibility results are not theoretical trivia.

Mechanism. Under unstable messaging, deterministic guarantees cannot always be perfect. Real systems accept bounded uncertainty.

Example. Temporary partitions produce delayed certainty while nodes reconcile.

Detection. Simulate partition and peer latency scenarios and watch convergence time.

Mitigation. Keep safety windows and escalation thresholds explicit in operations.

Failure consequence. Ignoring network reality creates production incidents during high load or regional failure.

## CAP and Your Product Promise
Every chain choice makes a tradeoff with consistency, availability, and partition tolerance.

Mechanism. You can push one side, but the others move as a consequence.

Example. Systems that prioritize constant availability often accept broader uncertainty windows.

Detection. Measure the time to settle under planned stress before launch.

Mitigation. Communicate the tradeoff in your user-facing promises and backend policy.

Failure consequence. Users see mixed guarantees and begin to distrust your service.

## The Cost of Disagreement
There is no free synchronization.

Mechanism. Reconciliation needs computation, messaging, and sometimes financial penalties.

Example. Reorg recovery consumes attention, confidence, and sometimes capital if actions were premature.

Detection. Track rollback ratio and average recovery duration.

Mitigation. Delay irreversible actions until your chosen confidence threshold is met.

Failure consequence. Premature settlement creates direct financial leakage.

## Practical Rule for Builders
Agreement is a product requirement, not an infrastructure footnote.

Mechanism. The architecture for wallets, treasury movement, and risk logic must reflect the chain's agreement model.

Example. If your risk team approves instant claims, your chain must support that latency and certainty.

Detection. Audit each feature against its required consistency and latency assumptions.

Mitigation. Use a requirement matrix linking action type to confidence tier.

Failure consequence. The first assumption breach is where user trust starts to erode.

## What Comes Next
Once you accept agreement as your baseline constraint, the next question is how specific mechanisms pay for that agreement.
