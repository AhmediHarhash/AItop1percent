Scope: Web3

# 1.2 â€” The Replicated State Machine

A blockchain is a computer that thousands of people run at the same time, and every one of them gets the same answer.

That sentence contains the entire idea. Everything else in this book â€” consensus algorithms, gas fees, smart contracts, Layer 2 rollups, MEV, bridge security â€” is a consequence of that sentence. If you understand it fully, you can reason about any blockchain that exists today or will exist in the future. If you do not understand it, you will memorize features without understanding why they exist, and your intuition will fail you the moment you encounter something new.

So let us take it apart, piece by piece.

## What a State Machine Is

You already use state machines every day. You just do not call them that.

A vending machine is a state machine. It has a state â€” the current amount of money inserted, the inventory of products, whether the door is locked. It has transitions â€” inserting a coin changes the money total, pressing a button dispenses a product, the door unlocks when a valid selection is made. And it has rules â€” you cannot dispense a product that costs two dollars when only one dollar has been inserted. That rule is enforced by the machine itself. You do not need to trust the vending machine operator. The mechanism prevents the invalid operation.

A state machine, in precise terms, is a system defined by three things. First, a set of possible states â€” every valid configuration the system can be in. Second, a set of valid transitions â€” operations that move the system from one state to another. Third, a transition function â€” the rules that determine, given the current state and a proposed operation, what the next state will be, or whether the operation is rejected as invalid.

Your bank account is a state machine. The state is your balance. A deposit is a transition that increases it. A withdrawal is a transition that decreases it. The rule "balance cannot go below zero" is the transition function rejecting an invalid operation. The bank's software enforces these rules. You trust the bank to run the state machine correctly.

A blockchain removes that trust requirement. It does not remove the state machine. It replicates it.

## What "Replicated" Means

Here is where the idea gets powerful and where most explanations get lazy.

"Replicated" does not just mean "copied." A replicated state machine is not a backup system. It is not a mirror. It is thousands of independent participants, each running their own copy of the same state machine, each independently validating every transition, and all of them arriving at the same result â€” not because they trust each other, but because they are all running the same deterministic rules against the same ordered sequence of inputs.

Consider a thought experiment. You and ninety-nine strangers are in separate rooms. Each of you has an identical calculator and an identical starting number: zero. An announcer reads instructions over a loudspeaker: "Add seven. Multiply by three. Subtract two." If every person follows the instructions correctly, every person ends up with the same number. Nobody needs to trust anyone else. Nobody needs to check anyone else's work. The determinism of the math and the shared ordering of the instructions guarantee agreement.

A blockchain works the same way, except the "calculator" is a virtual machine capable of executing complex programs, the "starting number" is the complete state of every account and contract on the network, and the "instructions" are transactions submitted by users around the world. The consensus protocol is the mechanism that determines the order of instructions â€” because if two people hear "add seven" and "multiply by three" in different orders, they will get different results. Ordering is everything.

This is why "replicated" is the hard part. Maintaining one state machine is trivial. Maintaining thousands of identical copies, operated by untrusted parties across unreliable networks with variable latency, all arriving at the same state â€” that is the engineering challenge that every blockchain protocol is fundamentally solving.

## State: The Complete Snapshot

When engineers say "state," they mean everything the system knows right now. Not what it knew yesterday. Not the history of how it got here. The current snapshot.

On Ethereum, state includes four categories of data. First, account balances â€” every externally owned account and every contract account has an ETH balance. Second, contract code â€” the compiled bytecode of every smart contract ever deployed, unless it has been intentionally destroyed. Third, contract storage â€” the persistent data that contracts maintain between calls. A lending protocol stores who borrowed what. A token contract stores who holds how many tokens. An NFT contract stores who owns which asset. Fourth, nonces â€” a counter for each account that tracks how many transactions it has sent, preventing replay attacks.

As of early 2026, Ethereum's state encompasses over 383 million unique addresses according to Etherscan. Each address is an entry in a massive data structure â€” currently a Modified Merkle Patricia Trie, with Verkle Trees planned for the Hegota upgrade later in 2026 â€” that allows any node to efficiently prove what the state is at any moment.

On Bitcoin, the state is simpler. It is the set of unspent transaction outputs â€” every coin that has been received but not yet spent. Bitcoin does not have contract storage or general-purpose computation. Its state machine is deliberately narrow: move value from one owner to another, according to simple scripting rules.

On Solana, the state lives in accounts â€” but Solana's account model is different from Ethereum's. Every piece of data on Solana is an account: user wallets, program code, program data, everything. Programs do not have private storage baked into them the way Ethereum contracts do. Instead, programs read from and write to accounts that are passed in as arguments to each transaction. This makes Solana's state machine more explicit about data access, which is what enables its parallel execution engine.

Three different designs. Three different trade-offs. But all three are replicated state machines. The state is different. The transition rules are different. The replication mechanism is different. The concept is identical.

## Transitions: Valid Operations That Change State

A **transition** is an operation that moves the state machine from one valid state to the next. Not every proposed operation is valid. The transition function â€” the rules â€” determines which operations succeed and which are rejected.

When you send one ETH to another address, that is a transition. The transition function checks: does the sender have at least one ETH? Is the nonce correct? Is the signature valid? If all checks pass, the state updates â€” the sender's balance decreases, the receiver's balance increases, the sender's nonce increments. If any check fails, the state does not change. The transaction is invalid and is either rejected before inclusion or reverts during execution.

When you call a smart contract function, the transition is more complex. The Ethereum Virtual Machine loads the contract's bytecode, executes it with the provided inputs, reads from and writes to the contract's storage, potentially calls other contracts, and produces a new state. But the principle is the same: given the current state and a valid transaction, the transition function produces a deterministic new state.

"Deterministic" is the word that makes replication possible. If the transition function could produce different results depending on when or where it runs â€” if it could access a random number generator, read the current wall-clock time, or fetch data from an external API â€” then different nodes would compute different new states, and the replicated state machine would diverge. This is why blockchains cannot natively access external data. This is why oracles exist. This is why on-chain randomness is hard. Determinism is not a limitation born of laziness. It is the price of replication.

Every transaction you see on a block explorer is a transition that was proposed, validated, executed, and incorporated into the canonical state. Ethereum processed a record 2.88 million of these transitions in a single day in January 2026, per Etherscan data. Each one followed the exact same path: propose, validate, execute, update state. Each one produced the same result on every node in the network.

## Why Replication Is the Hard Problem

If you run a single state machine on a single server, everything is straightforward. The server processes transactions in the order they arrive. There is one copy of the state. There are no conflicts. This is how traditional databases work, and they work extremely well.

The moment you replicate the state machine, you introduce the fundamental challenge: how do you ensure that all copies process the same transactions in the same order?

This is the consensus problem, and it has been studied in distributed systems research since the 1980s. The reason it is hard is not computational â€” it is environmental. Networks are unreliable. Messages arrive late, out of order, or not at all. Participants may be offline, slow, or actively malicious. The Byzantine Generals Problem, formulated by Leslie Lamport in 1982, proved that achieving agreement among distributed participants is impossible if more than one-third of them are malicious. Every blockchain consensus protocol operates within this bound.

Bitcoin solved the consensus problem with Proof of Work. Miners compete to find a hash that satisfies a difficulty target. The winner gets to propose the next block â€” the next batch of transitions. Other nodes validate the block and accept it if valid. If two miners find valid blocks simultaneously, the network temporarily forks. The fork resolves as subsequent blocks are added, and the longest chain wins. This is elegant but slow â€” Bitcoin's block time is approximately ten minutes, and meaningful finality takes an hour.

Ethereum, after the Merge in September 2022, uses Proof of Stake with Casper FFG for finality. Validators stake ETH as collateral, propose and attest to blocks, and the protocol finalizes blocks after two epochs â€” approximately 12.8 minutes. Validators who attest to conflicting blocks have their stake slashed. The economic incentive replaces computational work.

Solana uses a combination of Proof of Stake and Proof of History â€” a cryptographic clock that orders events without requiring validators to communicate about ordering. This allows Solana to achieve much higher throughput because it reduces the coordination overhead. With the Alpenglow upgrade planned for 2026, Solana aims to reduce finality to 100 to 150 milliseconds through its new Votor and Rotor mechanisms, where a block can be finalized in a single round if 80 percent of stake votes in support.

Three different solutions to the same problem: how to get untrusted participants to agree on the order of state transitions. The problem is identical. The engineering trade-offs are different. But every blockchain, without exception, must solve this problem, because without ordered agreement, the replicated state machine diverges and ceases to function.

## The Spreadsheet Analogy (and Where It Breaks)

The closest everyday analogy is a shared spreadsheet â€” something like Google Sheets â€” where every participant has a copy and changes propagate to everyone. This analogy captures two important ideas: shared data that everyone can see, and changes that everyone receives. These are real properties of a blockchain.

But the analogy breaks in an important way. In Google Sheets, there is a central server that resolves conflicts. If two people edit the same cell at the same time, Google's server decides which edit wins using operational transformation. There is a single authority. You trust Google.

In a blockchain, there is no central server. There is no authority to resolve conflicts. Instead, the protocol itself â€” the consensus rules baked into the software every node runs â€” determines which transitions are valid and in what order they are applied. No single participant can override the protocol. No single participant can alter the state without the network validating the change.

This is what "trustless" actually means: not that trust is absent, but that it is distributed across the protocol rather than concentrated in an operator. You still trust something â€” you trust the protocol rules and the economic incentives that keep participants honest. But you do not trust any single party. The trust is in the mechanism, not in a person or company.

The analogy is useful for building initial intuition, but you must not let it carry too far. A blockchain is not a collaborative document. It is a computational engine where every participant independently verifies every operation. The overhead of that independent verification is the cost you pay for trustlessness. It is why blockchains are slower than databases. It is why transaction fees exist. It is why scaling is hard. Every optimization in blockchain engineering is, at its core, an attempt to reduce the cost of independent verification without sacrificing its guarantees.

## The Cost of Independent Verification

This cost deserves its own discussion, because it is the source of almost every performance complaint about blockchains.

When you write data to a traditional database, one server processes the write. Replication to other servers happens asynchronously â€” the write is confirmed before replicas catch up. The user gets speed. The trade-off is that if the primary server fails before replication completes, data can be lost.

When you submit a transaction to a blockchain, every full node in the network must independently execute that transaction and verify the result. On Ethereum, that means thousands of nodes each run the same computation. On Solana, hundreds of validators each process the same transaction. This is redundant by design. The redundancy is the security model.

But redundancy has a price. If one thousand nodes each spend one millisecond processing your transaction, the network has consumed one full second of total compute time for a single state transition. This is why blockchains charge fees â€” gas on Ethereum, priority fees on Solana. The fee is not arbitrary. It reflects the real cost of one thousand independent verifications.

It is also why blockchains have throughput limits. A single server can process hundreds of thousands of database writes per second because it only does the work once. A blockchain processes each operation thousands of times. The throughput ceiling is determined by how fast the slowest necessary participant can keep up, not by how fast the fastest one can go.

Understanding this trade-off â€” security through redundancy at the cost of throughput â€” is essential. It prevents you from asking the wrong question. The wrong question is "why are blockchains slow?" The right question is "what level of independent verification does my application actually require?" Some applications need every validator to verify every transition. Others need only a subset. Others can move most computation off-chain and only verify results on-chain. These are architectural choices that become clear once you understand what you are paying for and why.

## How This Model Unlocks Everything Else

Once you internalize the replicated state machine, every other blockchain concept becomes a natural consequence rather than an arbitrary feature.

Gas fees are the cost of executing transitions. Each transition consumes computational resources â€” CPU cycles, memory, storage. Gas is the unit of measurement. Gas prices are the market mechanism that prevents the state machine from being overwhelmed by transitions it cannot process fast enough.

Smart contracts are programs stored in the state that the transition function can execute. They are not separate from the state machine. They are part of it. When you deploy a contract, you are adding a new set of transition rules to the machine. When you call a contract, you are triggering a transition that the contract's code defines.

Finality is the point at which a transition is guaranteed to never be reversed. It is a property of the consensus mechanism, not of the transaction itself. A transaction is final when the consensus protocol guarantees that no reorganization of the chain will remove it.

Forks are what happen when the replicated state machine temporarily disagrees about state. Some nodes see one sequence of transitions, other nodes see a different sequence. The consensus protocol resolves the fork by converging on a single canonical history. Hard forks happen when the transition rules themselves change, and not all participants adopt the new rules.

Layer 2 rollups are state machines that batch transitions off the main chain and then post the results back to the main chain's state. They are replicated state machines that derive their security from another replicated state machine. Understanding this is the difference between using Layer 2s correctly and treating them as magic speed boosts.

Bridges are mechanisms that allow state transitions on one replicated state machine to be reflected in another. They are inherently dangerous because they require translating guarantees from one consensus domain to another, and that translation is where security assumptions weaken. Every major bridge exploit in 2022 through 2025 was, at its core, a failure at this translation boundary.

None of these concepts require memorization if you have the right mental model. They are all consequences of the same idea: a state machine, replicated across untrusted participants, kept consistent by a consensus protocol.

## Why Other Explanations Fail

You may have encountered other attempts to explain blockchains precisely. Some describe them as "append-only databases." Others call them "consensus networks." Still others use "distributed computing platforms." Each of these captures a fragment of the truth while missing the whole.

"Append-only database" correctly notes that you cannot delete or modify past records, but it implies that the primary operation is writing data. In reality, the primary operation is computing new state. The append-only log is a means of ensuring that all participants agree on the sequence of transitions â€” it is not the purpose of the system.

"Consensus network" correctly emphasizes the agreement mechanism, but it says nothing about what participants are agreeing on. A consensus network could agree on anything â€” the weather, the score of a game, the result of an election. What makes a blockchain specific is that participants agree on state transitions in a replicated state machine. The consensus is the mechanism. The state machine is the system.

"Distributed computing platform" correctly identifies that computation happens across many machines, but it fails to distinguish blockchain from any other distributed system. A cloud computing cluster is also a distributed computing platform. What makes a blockchain different is that the distribution is among untrusted parties who independently verify every computation. The distribution is not for performance. It is for trust elimination.

The replicated state machine model avoids all of these partial descriptions by capturing the complete picture in three words. Replicated: run by many independent participants. State: tracking a complete data snapshot. Machine: computing transitions according to deterministic rules. Every other accurate description of a blockchain is a special case of this one.

## Every Blockchain Is This Machine

Bitcoin is a replicated state machine where the state is a set of unspent transaction outputs, the transitions are value transfers, and consensus is achieved through proof-of-work hash competition with approximately ten-minute block times.

Ethereum is a replicated state machine where the state includes account balances, contract code, and contract storage, the transitions include arbitrary program execution via the EVM, and consensus is achieved through proof-of-stake with Casper FFG finality at approximately 12.8 minutes.

Solana is a replicated state machine where the state lives in accounts, the transitions include parallel program execution via the SVM, and consensus is achieved through proof-of-stake with proof-of-history ordering, targeting sub-second finality with Alpenglow.

Cosmos, Avalanche, Near, Aptos, Sui â€” different states, different transition functions, different consensus mechanisms. Same fundamental architecture.

## The Three Questions That Explain Any Chain

When you encounter a new blockchain five years from now, you will not need someone to explain it to you. You will ask three questions.

First: what is the state? What data does this system track? How is it organized? Is it accounts with balances, or UTXOs, or something else entirely? How large is the state today, and how fast is it growing? What are the storage requirements for a full node?

Second: what are the valid transitions? What operations can users perform? Is this a general-purpose computation platform or a specialized system? How are transitions validated? How much do they cost? How many can the system process per second?

Third: how is consensus achieved? What is the mechanism that keeps all copies of the state machine in sync? Is it proof-of-work, proof-of-stake, a BFT variant, or something else? How fast does consensus converge? When does a transition become final?

The answers to these three questions tell you everything you need to know about a blockchain's capabilities, limitations, and trade-offs. They tell you what applications it can support, what performance you can expect, and what security guarantees you can rely on.

This is the power of the right mental model. It does not just explain today's blockchains. It equips you to evaluate blockchains that do not exist yet. When the next breakthrough protocol launches â€” and in this industry, that happens regularly â€” you will not need to wait for explainer articles. You will read the documentation, find the answers to three questions, and understand the system.

The next subchapter goes deeper into the three pillars of the replicated state machine: state, transitions, and finality â€” the concepts that determine what a blockchain can guarantee and what it cannot.
