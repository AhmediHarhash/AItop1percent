Scope: Web3

# 1.6 â€” What "Programmable" Means: Smart Contracts

A developer sits at her terminal and runs a deployment command. A few seconds later, the transaction confirms. The code she wrote is now living on a blockchain â€” replicated across thousands of nodes, executable by anyone in the world, impossible to delete. She cannot patch it. She cannot roll it back. If there is a bug, it is a permanent bug, accessible to every attacker on the planet, guarding whatever funds users deposit into it.

She double-checks the audit report one more time and begins pointing the frontend at the contract's address.

This moment â€” when code becomes permanent, public, and autonomous â€” is the dividing line between a blockchain that transfers value and a blockchain that does anything. Without programmability, Bitcoin is a ledger. With programmability, Ethereum is a computer. That distinction created an entirely new category of software, unlocked hundreds of billions of dollars in economic activity, and introduced an entirely new category of risk.

Understanding smart contracts is understanding why blockchains matter beyond simple payments.

## What a Smart Contract Actually Is

A **smart contract** is a program stored on a blockchain that executes automatically when triggered by a transaction. It lives at a specific address on the chain, just like a user account, but instead of being controlled by a private key, it is controlled by its own code. When someone sends a transaction to a smart contract's address, the contract's code runs, reads the transaction's input data, updates its internal state according to its programmed logic, and produces a result.

The name is misleading on both counts. Smart contracts are not smart â€” they execute exactly the logic they were programmed with, no more, no less. They have no intelligence, no judgment, no ability to handle situations their creator did not anticipate. And they are not contracts in any legal sense â€” they are programs.

The term was coined by Nick Szabo in 1994 and has stuck despite being a constant source of confusion. When you hear "smart contract," think "on-chain program." The mental model is closer to a function that runs on a shared computer than to a legal agreement between parties.

## What Makes Smart Contracts Different

What makes smart contracts different from ordinary programs is where they run and what guarantees that execution provides.

An ordinary program runs on one computer, controlled by one operator who can modify it, shut it down, or alter its behavior at any time. A smart contract runs on every node in the network simultaneously. Every node executes the same code with the same inputs and arrives at the same outputs.

No single party can alter the contract's behavior, censor its execution, or prevent someone from interacting with it. The contract's logic is enforced by the consensus mechanism itself â€” the same mechanism that prevents double-spending and ensures the integrity of the ledger.

This is a radical departure from how software normally works. When you use a traditional application â€” a bank's website, a social media platform, a marketplace â€” you are trusting the operator to run the software honestly, to not change the rules without notice, to not selectively deny you service. When you use a smart contract, the rules are public, the execution is verifiable, and the behavior is not under anyone's control. The program runs as written, regardless of who wants it to stop.

## Why Programmability Changed Everything

Before smart contracts, blockchains could do exactly one thing: transfer native currency from one account to another. Bitcoin's scripting language allows some limited programmability â€” multi-signature requirements, time-locked transactions, basic conditional logic â€” but it was deliberately constrained. Satoshi Nakamoto designed Bitcoin for robustness and security, not for general-purpose computation. The scripting language is not Turing-complete, which means there are entire categories of programs you simply cannot write on Bitcoin.

Ethereum, launched in 2015, was designed from the start as a programmable blockchain. Vitalik Buterin's key insight was that if you give developers a general-purpose programming environment on top of a replicated state machine, they can build any application they can imagine â€” not just payments, but exchanges, lending protocols, insurance, gaming, identity systems, governance mechanisms, and categories that had not been invented yet.

This insight proved correct. Programmable blockchains enabled **decentralized finance** â€” lending, borrowing, trading, and market-making without intermediaries. They enabled **non-fungible tokens** â€” unique digital assets with provable ownership and provenance. They enabled **decentralized autonomous organizations** â€” governance structures where rules are enforced by code rather than by legal agreements.

They enabled **stablecoins** â€” programmable dollars that move at blockchain speed. They enabled **tokenization of real-world assets** â€” representing real estate, bonds, commodities, and equities as on-chain tokens. Every one of these categories exists because someone could write a program and deploy it to a shared, unstoppable computer.

## The Execution Environment

Smart contracts do not run directly on the blockchain's hardware the way a desktop application runs on your operating system. They run inside a **virtual machine** â€” a sandboxed execution environment that provides a consistent, deterministic layer between the contract code and the underlying hardware.

On Ethereum, this virtual machine is the **EVM** â€” the Ethereum Virtual Machine. When you deploy a smart contract to Ethereum, your high-level code, typically written in Solidity, gets compiled into EVM bytecode â€” a low-level instruction set that every Ethereum node can execute.

The EVM is a stack-based machine with a deliberately simple architecture. It supports basic arithmetic, cryptographic operations, storage reads and writes, and calls to other contracts. It does not support floating-point math, direct file system access, or network calls. These limitations are features, not bugs. They ensure that every node running the same contract with the same inputs produces exactly the same output, regardless of the underlying hardware.

Solana takes a different approach with its execution environment, the **SVM** â€” Solana Virtual Machine â€” built on Sealevel, a runtime that enables parallel transaction execution. While the EVM processes transactions sequentially â€” one after another, in the order they appear in the block â€” Sealevel identifies transactions that do not touch the same state and runs them simultaneously across multiple cores.

This parallelism is a major reason Solana achieves higher throughput than Ethereum's base layer. The tradeoff is complexity: developers must explicitly declare which pieces of state their program will access, so the runtime knows which transactions can safely run in parallel.

Other blockchains use other virtual machines. Cosmos chains often use the CosmWasm runtime. Aptos and Sui use Move, a language and runtime designed with resource-oriented programming and safety in mind. The virtual machine choice has deep consequences for developer experience, security properties, performance characteristics, and the kinds of bugs that are possible. But across all these environments, the core principle is the same: every node runs the same code, with the same inputs, and gets the same result.

## Why Every Computation Costs Money

On your laptop, running a function costs electricity â€” a fraction of a cent, invisible on your power bill. On a blockchain, running a function costs money â€” visible, explicit, paid by the person who triggers the transaction. This cost is not a design flaw. It is a fundamental requirement of a shared, permissionless computer.

Consider what happens when you call a smart contract function on Ethereum. Your transaction is broadcast to the network. Thousands of nodes receive it. Every single one of those nodes executes your function independently, using their own CPU cycles, their own memory, their own storage.

If computation were free, an attacker could deploy a contract with an infinite loop and force every node in the network to spin forever, grinding the chain to a halt. This is a denial-of-service attack, and the defense against it is **gas** â€” a metering system that assigns a cost to every computational operation.

On Ethereum, every operation the EVM can perform has a fixed gas cost. A simple addition costs 3 gas. Storing a 256-bit value costs 20,000 gas for a new storage slot or 5,000 gas to update an existing one. Calling another contract costs a base of 2,600 gas plus whatever that contract's execution consumes.

Each block has a gas limit â€” roughly 30 million gas as of early 2026 â€” which caps the total computation any single block can contain. The price of gas fluctuates based on demand: when many users are competing for block space, gas prices rise; when the network is quiet, they fall.

Solana uses a different model called **compute units**, but the principle is identical. Every instruction the SVM executes consumes compute units, each transaction has a compute budget, and users pay fees proportional to the resources they consume. The actual dollar costs are much lower on Solana than on Ethereum's base layer â€” fractions of a cent versus potentially several dollars during Ethereum congestion â€” but the architectural principle is the same: computation on a shared machine is a scarce resource, and pricing it correctly prevents abuse.

This pay-per-computation model has profound consequences for application design. On-chain storage is expensive, so developers minimize what they store. Complex computations are costly, so developers push heavy processing off-chain and use the blockchain only for verification and state commitment. Gas optimization is not a nice-to-have â€” it is a core competency for smart contract developers. A poorly optimized contract can cost users ten times more than a well-optimized one for the same functionality.

## Determinism: The Non-Negotiable Requirement

Smart contracts must be **deterministic** â€” given the same inputs and the same prior state, they must always produce the same output. Always. On every node. Without exception.

If two nodes execute the same transaction and arrive at different results, the consensus mechanism breaks. The nodes cannot agree on the new state. The replicated state machine, which depends on every replica processing identical state transitions, falls apart.

This requirement explains many of the constraints that surprise developers new to blockchain.

Smart contracts cannot generate random numbers using local system calls, because different nodes would generate different random values. Smart contracts cannot fetch data from external APIs, because the responses might differ between nodes or change between the time different nodes process the same block. Smart contracts cannot use floating-point arithmetic in most environments, because floating-point operations produce subtly different results on different hardware due to rounding behavior.

Every piece of data a smart contract needs must either be part of the transaction itself, already stored on-chain, or provided through a deterministic mechanism that every node can verify.

This is why **oracles** exist â€” external services that feed off-chain data onto the blockchain in a way that all nodes can agree on. If your contract needs to know the current price of ETH in dollars, it cannot look that up during execution. It reads a price that an oracle service has already committed to the blockchain in a previous transaction. We will explore oracles and their trust implications in Chapter 3.

## Composability: The Superpower

The most powerful property of smart contracts is one that was not designed intentionally â€” it emerged from the architecture. Because every contract lives on the same shared state machine and can call any other contract, complex systems can be assembled from simple building blocks. This property is called **composability**, and it is the reason DeFi exists.

Consider what composability looks like in practice. A developer builds a lending protocol â€” a contract where users deposit tokens and other users borrow them, paying interest. Another developer builds a decentralized exchange â€” a contract where users swap one token for another. A third developer builds a yield aggregator that automatically moves user funds between the lending protocol and the exchange to maximize returns.

The yield aggregator does not need permission from the lending protocol or the exchange. It does not need an API key, a partnership agreement, or a business development handshake. It simply calls the other contracts' public functions, because those functions are available to anyone on the blockchain.

This is composability at work: permissionless integration between independent protocols, all sharing the same execution environment, all operating on the same state. A new contract can interact with every existing contract on the chain from the moment it is deployed. The ecosystem becomes a combinatorial explosion of possibilities, where each new building block multiplies the design space for every builder who comes after.

DeFi as a category is the proof of composability's power. According to DefiLlama, total value locked across all chains peaked above 200 billion dollars in 2025, with over 100 billion remaining even after significant market corrections in early 2026. All of this value â€” lending markets, decentralized exchanges, stablecoin mechanisms, derivatives platforms, liquid staking protocols â€” is governed by smart contracts that freely interact with each other. No central coordinator decides which protocols can integrate with which. The composability is inherent in the architecture.

## The Dark Side of Composability

But composability also creates risk. When contracts depend on each other, a vulnerability in one can cascade through every contract that interacts with it.

The most devastating DeFi exploits have not targeted single contracts in isolation. They have exploited the interaction between contracts â€” using a flash loan from one protocol to manipulate a price oracle in another, then draining a third protocol that relied on that oracle for liquidation decisions.

Composability is a superpower and a systemic risk. It is the reason DeFi can exist at this scale and the reason DeFi hacks have cost billions of dollars. The same openness that lets any developer build on top of any protocol also lets any attacker exploit the dependencies between them.

This tension â€” between the creative power of permissionless integration and the systemic risk of interconnected failure â€” is one of the defining challenges of smart contract development. There is no clean answer. You cannot have composability without the risk. You can only manage the risk through careful design, thorough auditing, and a deep understanding of every contract your system depends on.

## Immutability and Its Consequences

When a smart contract is deployed, its code becomes part of the blockchain's state. On Ethereum, that code is stored at a specific address and cannot be changed. You cannot issue a hotfix. You cannot push a patch. You cannot roll back to a previous version. The code that is deployed is the code that runs, today, tomorrow, and for as long as the blockchain exists.

This immutability is a feature when things work correctly. It gives users a guarantee that the rules will not change. A lending protocol's interest rate formula will not be quietly adjusted to favor the protocol. A governance system's voting rules will not be altered to benefit insiders. The code is the code, verifiable by anyone, modifiable by nobody. This trust guarantee is the foundation of DeFi's value proposition â€” you do not need to trust the team, because you can read the contract.

But immutability is catastrophic when things go wrong.

In 2016, an attacker exploited a vulnerability in The DAO â€” an early Ethereum smart contract that had raised 150 million dollars â€” and drained roughly a third of its funds. The contract code was immutable. The vulnerability was permanent. The Ethereum community ultimately decided to hard-fork the chain and reverse the theft, a controversial decision that led to the creation of Ethereum Classic as a separate chain.

The incident demonstrated that code immutability and social immutability are different things â€” and that the gap between them is where governance lives.

## The Upgradeable Proxy Pattern

The industry responded to the immutability challenge by developing **upgradeable proxy patterns** â€” architectural designs where the contract users interact with, called the proxy, delegates execution to an implementation contract that can be swapped out.

This gives developers the ability to fix bugs and add features, but it reintroduces the trust assumption that immutability was supposed to eliminate. If a team can upgrade the implementation contract, they can change the rules. Users must trust that the team will use this power responsibly, which brings the system closer to a traditional application with a traditional trust model.

The best protocols navigate this tension deliberately. They deploy with upgradeable proxies during the early, high-risk phase of development, then progressively decentralize upgrade authority â€” first requiring a multi-signature wallet with multiple keyholders, then transferring upgrade authority to a DAO governance vote, and eventually renouncing upgrade authority entirely once the contract is battle-tested.

This **progressive decentralization** pattern acknowledges that perfect immutability from day one is impractical for complex software, while still working toward it as a long-term goal. The path from "the team can change anything" to "nobody can change anything" is a spectrum, and where a protocol sits on that spectrum at any given moment defines how much you need to trust the team behind it.

## The Audit Imperative

Smart contract bugs are not like web application bugs. When a web application has a vulnerability, the company takes the site down, patches the code, and redeploys. Users might be inconvenienced for a few hours. When a smart contract has a vulnerability, an attacker can drain every dollar that users have deposited, and the code cannot be patched because it is immutable.

The stakes are qualitatively different.

This is why smart contract auditing has become a critical practice â€” and a significant industry. Before a serious protocol deploys, it typically undergoes one or more audits by specialized security firms that review the code line by line, looking for reentrancy vulnerabilities, integer overflows, access control failures, oracle manipulation vectors, flash loan attack surfaces, and dozens of other vulnerability classes unique to the on-chain environment.

The cost of smart contract exploits underscores why this matters. Smart contract vulnerabilities and related attack vectors accounted for over 3.5 billion dollars in losses during 2024 alone. The year 2025 added further billions, including the 1.5 billion dollar Bybit breach. Cross-chain bridges â€” which rely on some of the most complex smart contract architectures in the ecosystem â€” have been disproportionately targeted, accounting for roughly 40 percent of all Web3 hacks and over 2.8 billion dollars in cumulative losses.

These are not hypothetical risks. They are documented, verifiable events that destroyed real funds belonging to real people.

Audits reduce risk but do not eliminate it. Auditors are human. They work under time pressure. They can miss vulnerabilities that a sufficiently creative attacker discovers. The most robust approach combines multiple audits from different firms, formal verification of critical code paths, extensive test suites, bug bounty programs that incentivize white-hat hackers to find and report vulnerabilities, and economic models that limit the potential damage from any single exploit.

Security in smart contract development is not a one-time gate. It is an ongoing practice, a culture, and a cost center that serious protocols budget for permanently.

## What Smart Contracts Cannot Do

Understanding what smart contracts can do is important. Understanding what they cannot do is equally important, and far less commonly taught.

Smart contracts cannot access the real world. They cannot call APIs, scrape websites, read sensor data, or interact with anything outside the blockchain's state. They are confined to the information that exists on-chain. If a contract needs real-world data â€” the price of gold, the outcome of an election, the temperature in Tokyo â€” that data must be brought on-chain by an external service, an oracle, before the contract can use it. This creates a trust dependency that many blockchain applications quietly rely on without acknowledging.

Smart contracts cannot initiate actions on their own. They are reactive, not proactive. A contract cannot wake up at midnight and trigger a liquidation. It needs an external transaction to poke it â€” a user, a bot, or an automated keeper service that calls the contract's function at the right time. This is why DeFi protocols have "keeper" networks â€” systems of bots that monitor conditions and trigger contract functions when specific thresholds are met. Without keepers, time-sensitive operations would never execute.

Smart contracts cannot keep secrets. Everything on a blockchain is public. Every variable in a contract's storage can be read by anyone, even if the developer marked it as "private" in the source code. The "private" keyword in Solidity controls code-level visibility, not data-level visibility. If your contract stores a secret key, a password, or any sensitive value, anyone can read it by querying the contract's storage directly. This surprises many developers coming from traditional environments where private variables are actually private.

Smart contracts cannot undo their effects. Once a contract executes a state transition and that transition is finalized in a block, it is done. There is no rollback button, no undo command, no dispute resolution built into the protocol. If a user sends funds to the wrong contract, or a contract distributes rewards incorrectly due to a logic error, the only remedy is to deploy a new contract or transaction that explicitly corrects the mistake â€” and that correction itself becomes a permanent part of the record.

## The Shift in Mental Model

Understanding smart contracts requires a shift in how you think about software.

In traditional development, code runs on servers you control, accesses databases you manage, and can be updated, rolled back, or shut down at any time. In smart contract development, code runs on a shared computer nobody controls, accesses state that everyone can read, and cannot be changed once deployed. The security model is inverted. The deployment model is inverted. The update model is inverted.

Everything you learned about moving fast and breaking things is exactly wrong.

The best smart contract developers think more like aerospace engineers than web developers. They design for constraints. They test exhaustively. They assume adversarial users. They budget for audits the way companies budget for insurance. They deploy incrementally, with limits on the amount of value the contract can hold until it has been battle-tested in production. They plan for the failure modes they can anticipate and design circuit breakers for the ones they cannot.

This shift â€” from "move fast" to "move carefully, because mistakes are permanent" â€” is the mental model adjustment that separates successful blockchain builders from expensive cautionary tales. The programmability that smart contracts provide is extraordinary. The responsibility that comes with it is equally extraordinary. Both must be understood together.

The next subchapter examines the other side of this picture â€” not what blockchains can do, but what they fundamentally cannot do. Understanding these hard boundaries is what prevents you from building systems that fight the architecture instead of working with it.
