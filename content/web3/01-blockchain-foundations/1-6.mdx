# 1.6 What "Programmable" Means: Smart Contracts
Scope: Web3

## The Core Shift from Data to State Machines
Programming a chain means you are changing state, not just storing values.

Mechanism. A smart contract encodes rules that transform shared state when valid transactions hit it.

Example. A swap function moves two token balances only when conditions are met.

Detection. Test contract logic against edge conditions, including reentrancy and sequence edges.

Mitigation. Assume state transitions can be targeted by adversarial order, not friendly test data.

Failure consequence. Logic that fails in edge ordering becomes exploitable at settlement points.

## Deterministic Execution Is Non Negotiable
Contracts must evaluate identically across nodes.

Mechanism. If same input gives different result, consensus cannot be reached.

Example. Contracts with external data assumptions without verified sources create non-deterministic branches.

Detection. Fuzz with different environment conditions while keeping input stable.

Mitigation. Keep external dependencies explicit and deterministic.

Failure consequence. Non-determinism leads to divergence and invalidation.

## Gas and Resource Limits as a Control, Not a Tax
Execution limits enforce bounded resource use.

Mechanism. Gas and storage constraints prevent infinite loops and abuse.

Example. A transaction with high complexity may stall if limits are not modeled.

Detection. Profile real workloads and peak-case execution.

Mitigation. Budget complexity and optimize critical paths before deployment.

Failure consequence. Unexpected gas behavior becomes a denial vector and user experience failure.

## Immutable Logic, Mutable Parameters
Contract code once deployed can be hard to change.

Mechanism. You trade upgrade flexibility for transparency and predictability.

Example. A bug in contract branching can require migration contracts and governance action.

Detection. Track upgrade and migration paths before launch.

Mitigation. Design upgrade hooks where governance and ops can safely intervene.

Failure consequence. No migration path turns small errors into chain-level incidents.

## Shared Storage and State Coupling
Contracts operate over shared state maps and event logs.

Mechanism. Poor storage design can create hidden coupling and unintended cross-effects.

Example. Two modules updating the same resource under conflicting assumptions can deadlock workflows.

Detection. Map storage reads and writes at boundary functions.

Mitigation. Isolate state boundaries and define ownership rules.

Failure consequence. State coupling becomes a silent operational failure source.

## Contract Security Is a Product Architecture Topic
Programming security is not just audit wording.

Mechanism. Your app architecture must include checks, constraints, and emergency response.

Example. Timelocks and role checks can reduce blast radius when assumptions fail.

Detection. Build failure mode simulations around privileged actions.

Mitigation. Add monitoring and multisig-style oversight for high-risk functions.

Failure consequence. Security gaps in contracts become direct financial incidents.

## Bridge
Now we step from capability to limits. Even powerful programmability does not remove protocol tradeoffs.
