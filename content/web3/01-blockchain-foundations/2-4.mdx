# 2.4 Finality: When Is a Transaction Actually Done
Scope: Web3

## Finality Is a Risk Window, Not a Tag
A single on-screen confirmation is not a guarantee.

Mechanism. Finality is the point at which the chain is unlikely to revert the state outcome.

Example. A payment can appear valid at first, then disappear if the chain branch changes.

Detection. Measure finality lag and reorg probability by chain and action type.

Mitigation. Classify actions by risk and enforce explicit confidence thresholds.

Failure consequence. Treating early state as final creates irreversible user-facing errors.

## Probabilistic Finality Mechanics
In probabilistic systems, certainty increases over time.

Mechanism. More blocks after a transaction reduce the cost of successful reversal.

Example. A low-value action may move after a short depth while high-value transfers wait longer.

Detection. Track depth versus reversal events for each class of operation.

Mitigation. Use depth-based release policies instead of one global rule.

Failure consequence. Uniform depth policies expose high-risk flows to unnecessary loss.

## Deterministic Finalization Paths
Some engines provide explicit checkpoints.

Mechanism. Once protocol conditions are met, a block can be marked finalized.

Example. Cross-domain settlement may wait for deterministic finalization before release.

Detection. Audit checkpoint lag and checkpoint participation.

Mitigation. Connect finalization type to withdrawal and settlement design.

Failure consequence. Overtrusting probabilistic data in deterministic workflows causes chain-wide retries.

## Reorg Depth and Application Design
Reorganizations are expected in the margins.

Mechanism. Temporary forks are resolved, but deep reversions indicate higher risk.

Example. A treasury state update from a shallow reorg can still trigger stale payouts.

Detection. Alert on unusual reorg depth and frequency.

Mitigation. Keep all irreversible actions after your deepest risk window.

Failure consequence. Shallow assumptions in critical flows cause costly unwind events.

## UX Versus Risk in State Labels
Product trust depends on transparent progression.

Mechanism. Status stages convert uncertainty into readable states.

Example. Pending, confirmed, and finalized labels tell users and systems where safety changed.

Detection. Track how often states are misread by support tickets and service errors.

Mitigation. Align labels with real chain behavior and not marketing language.

Failure consequence. Confused users increase disputes more than delayed transactions.

## Cross-Chain Finality Translation
Different chains expose different certainty schedules.

Mechanism. A fast source confirmation is not the same as safe destination settlement.

Example. Bridge relays may need extra challenge windows even when source appeared quick.

Detection. Measure relay latency and rollback behavior end to end.

Mitigation. Set bridge policies on the strictest chain behavior in the path.

Failure consequence. Bridge incidents often begin with incorrect finality translation.

## Practical Rule for Builders
State is processed through states, not binary outcomes.

Mechanism. Internal pipelines should consume transitions as separate safety steps.

Example. Internal ledger writes can happen earlier than user settlement release.

Detection. Audit code paths for irreversible transitions tied to only one checkpoint.

Mitigation. Add explicit gate functions and audit them in release criteria.

Failure consequence. One misplaced irreversible call can trigger chain-spanning outage.

## What to Watch Next
Now that you know how certainty works, the next section shows who supplies this reliability and what economics hold it in place.
