# 1.7 What Blockchains Cannot Do
Scope: Web3

## The Myth of Total Removal
Blockchains are powerful, not magical.

Mechanism. They coordinate trust and state order, but they do not erase physical, legal, or human constraints.

Example. A chain cannot guarantee zero user error, zero regulation friction, or absolute censorship immunity.

Detection. Audit which promises are product claims versus protocol guarantees.

Mitigation. Document your own non-blockchain assumptions as explicit risk assumptions.

Failure consequence. Overstated claims create legal and trust fallout.

## Privacy Is Not Automatic
Public state visibility and chain observability are often strengths and limits at the same time.

Mechanism. Public ledgers expose metadata that can still leak behavior.

Example. Wallet cluster timing can reveal usage patterns even when values are private.

Detection. Run privacy-impact tests on query and index patterns.

Mitigation. Separate pseudonymization and privacy-preserving layers where needed.

Failure consequence. Overreliance on chain opacity assumptions can break user trust later.

## Perfect Fairness Does Not Come Standard
Consensus rules can reduce but not eliminate strategic behavior.

Mechanism. Actor incentives and order flow create priority effects.

Example. Inclusion ordering can still reward higher fee strategies.

Detection. Monitor fee and inclusion variance over time.

Mitigation. Design fairness assumptions into UX and governance policy.

Failure consequence. Users perceive unfairness as system unfairness.

## Not Instant Scaling
Throughput is bounded by protocol design and infrastructure.

Mechanism. Consensus, signatures, and propagation create hard ceilings.

Example. A chain with high safety can still become expensive under sudden demand.

Detection. Benchmark peak throughput with realistic state complexity.

Mitigation. Use batching, sharding, or L2 architectures where appropriate.

Failure consequence. Ignoring ceilings means architecture failures during growth.

## Finality Is Not Immediate Safety
Even secure chains have risk windows.

Mechanism. Reorganizations and delayed finality require careful action gating.

Example. A confirmed-looking state can still be revised before finality.

Detection. Measure reorg depth and rollback frequency.

Mitigation. Set conservative gates for irreversible actions.

Failure consequence. Early irrevocable action on risky state creates losses.

## Governance and Legal Reality
Rule sets can change, and jurisdictions can act.

Mechanism. Protocol operations sit inside legal and social systems.

Example. A chain deployment can be healthy while user access is constrained.

Detection. Track legal changes and compliance updates tied to your deployment region.

Mitigation. Build jurisdiction-aware deployment plans.

Failure consequence. Governance shocks can stop growth faster than code bugs.

## Practical Conclusion
A chain is a strong primitive, not a universal solution.

Mechanism. You still need ops, privacy posture, and risk architecture around it.

Example. A tokenized reward system still needs audit, customer support, and incident response.

Detection. Compare incident plans to your actual chain risk profile.

Mitigation. Plan for non-protocol failure modes at release.

Failure consequence. Most production failures happen in the gap between protocol and operations.

## Bridge
Next section compares this system directly with traditional databases, so your choice is now less romantic and more operational.
