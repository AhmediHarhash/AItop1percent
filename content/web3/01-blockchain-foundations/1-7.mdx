Scope: Web3

# 1.7 â€” What Blockchains Cannot Do

Blockchains are powerful precisely because of what they refuse to do. Every limitation you are about to read is not a bug waiting to be fixed. It is a design choice that makes the security guarantees possible. The moment you understand the boundaries, you stop fighting the system and start designing with it.

Most newcomers learn what blockchains can do â€” decentralized execution, trustless settlement, programmable money â€” and then assume the technology is a general-purpose solution for everything. It is not. A blockchain is a highly specialized machine. It does a small number of things extraordinarily well, and it does everything else worse than the technology you already have.

The builders who succeed in Web3 are the ones who internalize the constraints before writing their first line of Solidity. The builders who fail are the ones who try to force-fit traditional application patterns onto a system that was never designed for them. This subchapter walks you through every major limitation, explains why each one exists, and shows you how these constraints shape the way real systems get built.

## The Oracle Problem: No Eyes on the Outside World

A blockchain can only see its own state. It knows every balance, every contract, every historical transaction that ever occurred on its own network. But it has absolutely no way to observe anything outside of itself. It cannot check the weather. It cannot verify a stock price. It cannot confirm that a package was delivered, that a flight was canceled, or that a sports team won a game.

This is called **the oracle problem**, and it is one of the most fundamental constraints in all of blockchain engineering. A smart contract that says "pay Alice if the temperature in Chicago exceeds 100 degrees" has no mechanism to check the temperature in Chicago. The blockchain does not have a thermometer. It does not have an API call. It does not have a browser. It exists in a hermetically sealed environment where the only truth it recognizes is the truth recorded in its own blocks.

The reason for this constraint is determinism. Every node in the network must be able to replay every transaction and arrive at the exact same result. If a smart contract could make an HTTP request to an external API, different nodes might get different responses. One node queries at 2:01 PM and gets a price of 3,241 dollars. Another queries at 2:02 PM and gets 3,243 dollars. The state machine diverges. Consensus breaks. The entire system fails.

This is not a theoretical concern. It is the reason the constraint exists at all. Deterministic execution is what makes it possible for thousands of independent machines to agree on the same state without trusting each other. Remove determinism and you remove the foundation that everything else rests on.

Oracles exist to bridge this gap. Projects like Chainlink, Pyth, and API3 operate networks of external data providers that feed information into the blockchain through transactions. The key word is "through transactions." The oracle does not give the smart contract the ability to look outside. Instead, a trusted party looks outside, writes what it sees into a transaction, and submits that transaction to the blockchain. The contract then reads the data from the transaction, treating it the same way it would treat any other on-chain data.

But oracles are not part of the blockchain itself. They are trusted intermediaries â€” which means every oracle introduces a point of trust into a system designed to eliminate trust. If the oracle feeds bad data, the smart contract executes faithfully on that bad data. The contract does exactly what it was told. It was just told the wrong thing.

This is why oracle security is one of the most active research areas in Web3. Oracle manipulation has been the attack vector behind hundreds of millions of dollars in DeFi exploits. An attacker who can manipulate the price feed that a lending protocol uses can create phantom collateral, borrow against it, and drain the protocol. The smart contract worked perfectly. The oracle was the point of failure.

## No Infinite Scale: Every Node Carries the Weight

Blockchains do not scale the way traditional web applications scale. When your web app gets more traffic, you spin up more servers. Each server handles a fraction of the load. Throughput grows linearly with hardware. This is horizontal scaling, and it is the foundation of every major internet service you use daily.

Blockchains work in the opposite direction. On a Layer 1 network like Ethereum, every full node must process every single transaction. Adding more nodes does not increase throughput â€” it increases redundancy. If the network processes fifteen transactions per second, then all ten thousand nodes are each independently verifying those same fifteen transactions.

This is the cost of decentralization. The throughput of the system is limited by what a single node can handle, because every node must handle all of it. You cannot shard the workload across nodes the way a traditional distributed system shards work across servers â€” because the whole point is that every node independently verifies the same computation. That redundancy is the security model. Remove it and you are back to trusting a single operator.

Ethereum's mainnet processes roughly fifteen to twenty transactions per second. Bitcoin processes about seven. Solana pushes this higher â€” into the thousands â€” but it does so by requiring significantly more powerful hardware for validators. A Solana validator needs high-end CPUs, hundreds of gigabytes of RAM, and fast NVMe storage. This reduces the number of people who can afford to run a node, which reduces decentralization. This is the trilemma at work. You can push one variable higher, but you pay for it somewhere else.

Layer 2 solutions like Arbitrum, Optimism, Base, and zkSync move transaction execution off the main chain and post compressed proofs back to Layer 1. This has been transformative. L2s can process hundreds or thousands of transactions per second while inheriting Ethereum's security for final settlement.

But even L2s have ceilings. They still depend on the L1 for data availability and finality. The L1 is the bottleneck that everything else hangs from. There is no version of blockchain architecture where throughput is unlimited. There is only a question of which trade-offs you accept to get more of it.

## No Cheap Storage: The Most Expensive Hard Drive on Earth

Storing data on a blockchain is extraordinarily expensive compared to any other storage system in existence. On Ethereum, writing one kilobyte of data to the chain costs roughly ten to fifty dollars depending on gas prices. Storing one megabyte costs thousands. Storing one gigabyte is financially absurd â€” you would spend more than the GDP of a small country.

This is not a pricing mistake. It is a direct consequence of the architecture. When you store data on Ethereum, that data is replicated across every full node in the network. As of early 2026, that means your one kilobyte of data is being stored on more than seven thousand machines worldwide, all of which must retain it indefinitely. You are not paying for one copy. You are paying for thousands of copies that can never be deleted.

The economics make the constraint obvious. AWS S3 charges roughly two cents per gigabyte per month. Ethereum charges thousands of dollars per megabyte â€” once, permanently. The cost differential is not ten times or a hundred times. It is millions of times more expensive per byte. This is not a market inefficiency. It is a reflection of the fact that on-chain storage carries the strongest durability and availability guarantees of any storage system ever built. You are paying for permanence backed by global consensus.

This is why no serious blockchain application stores large files on-chain. Images, videos, documents, user-generated content â€” none of this belongs on a blockchain. Instead, builders use off-chain storage systems like IPFS, which distributes files across a peer-to-peer network, or Arweave, which offers permanent storage with a one-time payment. The blockchain stores only a hash â€” a short cryptographic fingerprint â€” that points to the off-chain data and lets anyone verify that the data has not been tampered with. The hash is a few dozen bytes. The data it represents can be gigabytes. The blockchain provides the integrity guarantee. The storage system provides the capacity.

When you see an NFT "stored on the blockchain," what is actually on-chain is typically a token ID and a URL or content hash pointing to the image. The image itself lives on IPFS, or sometimes on a centralized server. If that server goes down or that IPFS node disappears, the NFT still exists on-chain as a token â€” but the art it represents becomes a broken link.

This disconnect between on-chain ownership and off-chain data is one of the most misunderstood aspects of NFTs, and it stems directly from the storage cost constraint. The blockchain guarantees that you own the token. It does not guarantee that the thing the token represents will always be accessible.

## No Undo: Transactions Are Permanent

When you send a transaction on a blockchain, it is final. There is no customer support line to call. There is no dispute resolution form. There is no reversal mechanism built into the protocol. If you send ten ETH to the wrong address, that ETH is gone. If a smart contract has a bug that drains funds, those funds are drained. The blockchain recorded exactly what you told it to record, and it will never change its mind.

This is a feature, not a flaw. Finality is what makes the system trustworthy. If any party could reverse transactions after the fact, the entire promise of censorship-resistant settlement would collapse. You would need a court, an appeals process, a dispute resolution body â€” in other words, all the intermediaries that blockchain was designed to eliminate.

But finality has consequences. And the most famous illustration is the DAO hack of 2016. The DAO was a decentralized investment fund built on Ethereum that raised the equivalent of 150 million dollars in ETH. An attacker found a reentrancy bug in the smart contract and exploited it to drain roughly 60 million dollars. The code had done exactly what the code said â€” the attacker simply found a way to make the code say something the developers did not intend.

What followed was one of the most contentious decisions in blockchain history. The Ethereum community chose to hard fork the network â€” to create a new version of the chain where the hack never happened. The stolen funds were returned. But a portion of the community refused the fork on principle, arguing that immutability meant immutability, even when the outcome was painful. They continued running the original chain, which became **Ethereum Classic**.

Two versions of reality, created by a philosophical disagreement about whether "no undo" should truly mean no undo. The community that forked to reverse the hack believed that human judgment should override code when the stakes are high enough. The community that stayed on the original chain believed that the moment you allow one exception, the guarantee of immutability becomes a promise instead of a property â€” and promises can be broken.

The lesson is not that blockchains should have an undo button. The lesson is that finality has consequences. Every smart contract you deploy is a promise the network will enforce exactly as written. You cannot patch it after deployment the way you patch a web application. You cannot roll back a database migration. If your contract has a vulnerability, the only mitigation is deploying a new contract and migrating users to it â€” assuming the damage has not already been done.

This is why smart contract auditing is not optional. This is why the most critical DeFi protocols undergo multiple independent audits before launch. And this is why the security section of this book exists. In a world with no undo, prevention is the only strategy.

## Not a Fast Database: Throughput in Perspective

If your application needs to handle thousands of operations per second with sub-millisecond latency, a blockchain is the wrong tool. This is not a temporary limitation that will be solved by the next upgrade. It is a structural property of how consensus works.

Ethereum L1 processes fifteen to twenty transactions per second. Bitcoin processes about seven. Even Solana, which is optimized for throughput, handles a few thousand real user transactions per second when you strip out the vote transactions that validators use for consensus.

Compare this to a traditional PostgreSQL database, which can handle tens of thousands of queries per second on modest hardware. Compare it to Redis, which handles hundreds of thousands. Compare it to the Visa network, which processes roughly 65,000 transactions per second at peak capacity.

The gap is not small. It is orders of magnitude. And it exists because a blockchain transaction is fundamentally different from a database query. A database query runs on one machine, trusts that machine, and returns a result. A blockchain transaction must be broadcast to thousands of machines, validated independently by each one, organized into a block, agreed upon through consensus, and then permanently recorded. Every step adds latency. Every step adds cost. The total processing time for a single Ethereum transaction is twelve seconds at minimum â€” the block time â€” and full finality takes roughly twelve to fifteen minutes.

Layer 2 networks have dramatically improved this. Transactions on Base or Arbitrum confirm in one to two seconds, and fees are fractions of a cent. But even L2s are not competing with databases on raw speed. They are competing on a different axis entirely: trust. A database is fast because one entity controls it. An L2 is slower because no single entity controls it, but its state can be verified against the L1 by anyone.

Speed versus verifiability. You choose based on what your application actually needs. If you need both â€” fast responses and verifiable state â€” you build a hybrid system. You put the user experience on a fast backend and settle critical state on-chain. This is what every successful Web3 application does.

## No Privacy by Default: Everything Is Visible

Every transaction on a public blockchain is visible to everyone. When you send ETH from one address to another, every node in the network â€” and every block explorer on the internet â€” can see the sender address, the receiver address, the amount, the timestamp, and the gas paid. This is true for every token transfer, every smart contract interaction, every DeFi trade, every NFT purchase.

The blockchain is not just a public ledger. It is the most public ledger ever created. Traditional financial records are held by banks and visible only to regulators. Blockchain records are held by everyone and visible to anyone with an internet connection.

Companies like Chainalysis and Elliptic have built entire businesses around analyzing blockchain transactions and tracing the flow of funds. Law enforcement uses these tools routinely. The FBI, the IRS, and Europol have all prosecuted cases using blockchain analytics. So do researchers, journalists, and anyone curious enough to type an address into Etherscan.

This radical transparency is a feature for some use cases and a severe limitation for others. It is excellent for verifying that a DeFi protocol holds the reserves it claims. It is terrible for a business that does not want its competitors to see every transaction it makes. It is useful for tracking stolen funds after a hack. It is problematic for individuals who believe financial privacy is a basic right.

Consider a payroll use case. If a company pays employees in stablecoins on-chain, every employee can see what every other employee earns. So can competitors, recruiters, and anyone else who identifies the company's wallet. The transparency that makes blockchain trustworthy for settlement makes it unusable for any activity where privacy matters.

Privacy-preserving technologies are evolving. Zero-knowledge proofs allow one party to prove a statement is true without revealing the underlying data â€” for example, proving you have sufficient funds for a transaction without revealing your total balance. Networks like Aztec on Ethereum and privacy features on Zcash use this cryptography. But as of early 2026, privacy is not a default property of most blockchain activity. It is an add-on, and it adds complexity, cost, and often regulatory scrutiny. Regulators worry that privacy features enable money laundering. Builders worry that without privacy, mainstream adoption is limited. This tension has no clean resolution yet.

## No Native Identity: Addresses Are Not People

A blockchain address is a string of characters derived from a cryptographic key pair. It is not a person. It is not an organization. It is not verified, validated, or authenticated against any real-world identity. Anyone can create as many addresses as they want, instantly, for free, without providing a name, an email, or a government ID.

This is **pseudonymity**, and it is a core property of public blockchains. Your address is visible. Your transactions are visible. But the connection between an address and a real human identity exists only if you â€” or someone else â€” deliberately creates it.

If you buy crypto on a centralized exchange with KYC verification and then withdraw to a self-custody wallet, the exchange knows the link between your identity and your withdrawal address. But the blockchain itself does not. On-chain, your address is just a string. The blockchain has no concept of "this address belongs to a person named John who lives in Berlin."

This creates real challenges for applications that need to know who they are dealing with. Lending protocols cannot run credit checks â€” they can only assess collateral. DAOs cannot verify that one person is not voting with fifty wallets, a problem known as **sybil attack**. Compliance-sensitive applications cannot satisfy know-your-customer requirements using on-chain data alone.

The entire field of decentralized identity â€” projects like Ethereum Name Service, Worldcoin's World ID, Polygon ID, and various soulbound token proposals â€” exists to bridge this gap. ENS maps human-readable names to blockchain addresses. World ID uses biometric verification to prove that an address belongs to a unique human. Soulbound tokens attach non-transferable credentials to addresses.

But none of these are native to the blockchain protocol itself. They are all layers built on top, each with their own trust assumptions and adoption challenges. The blockchain was designed to work without identity, and adding identity back in is one of the hardest unsolved problems in the space.

## No Built-In Governance: Code Is Law Until Humans Disagree

Smart contracts execute automatically based on their programmed logic. There is no appeals process built into the protocol. There is no arbitration mechanism. There is no court of last resort that can override a contract's execution. This is what the phrase "code is law" means in its literal sense â€” the code defines the rules, and the network enforces them without exception.

Until the humans who run the network decide otherwise.

The Ethereum Classic fork demonstrated this in 2016, but the pattern has repeated in subtler forms. Protocol upgrades, parameter changes, emergency patches â€” all of these require human coordination outside the blockchain itself. Ethereum's transition from proof of work to proof of stake in September 2022 was a governance decision made by core developers, client teams, and the broader community. No smart contract voted on it. No on-chain mechanism triggered it. Humans discussed it on forums, in calls, and in chat rooms for years, and then they changed the rules of the system.

DAOs attempt to formalize governance on-chain. Token holders vote on proposals, and smart contracts execute the results. But even the most sophisticated DAOs rely on off-chain discussion, off-chain coordination, and occasionally off-chain intervention when things go wrong.

The reality is that governance is fundamentally a human process. Blockchains can automate the execution of governance decisions, but they cannot automate the judgment, debate, and compromise that produce those decisions. The code runs the vote. The code does not run the conversation that precedes the vote, or the social dynamics that determine who proposes what, or the off-chain negotiation that happens when the vote result is politically unworkable. Code is law â€” but humans write the code, and humans decide when to change it.

## Transaction Costs: The Price of Decentralization

Every operation on a blockchain costs money. On Ethereum L1, a simple ETH transfer costs a few dollars. A complex smart contract interaction â€” a DeFi swap, a multi-token transaction, a contract deployment â€” can cost ten, fifty, or even hundreds of dollars during periods of high network demand.

In May 2023, during a memecoin frenzy, average Ethereum gas fees exceeded 100 gwei, pushing simple transactions above twenty dollars and complex ones past a hundred. Users were paying more in gas fees than the value of the tokens they were trading. The network was working exactly as designed â€” allocating scarce block space to the highest bidders â€” but the result was that ordinary users were priced out of the network entirely.

These costs are not arbitrary. They exist to prevent spam. If transactions were free, an attacker could flood the network with billions of meaningless transactions and grind it to a halt. Gas fees create a cost for every computation, which means attackers must pay for the damage they attempt. The fee market also allocates scarce block space â€” when demand exceeds supply, fees rise, and users who value inclusion most pay more.

Layer 2 networks have compressed these costs dramatically. A token swap on Base or Arbitrum costs between one and ten cents as of early 2026. Solana transactions cost fractions of a cent. But "cheap" is not "free," and even tiny fees change user behavior.

A traditional web application can handle a million API calls for a few dollars in server costs. A blockchain application that processed a million transactions on an L2 at five cents each would spend fifty thousand dollars. The economics are fundamentally different, and they shape what kinds of applications are viable on-chain. You will never see a blockchain-based chat application where every message is a transaction â€” not because it is technically impossible, but because the cost would be absurd.

## Why These Limits Exist: The Price You Pay for Guarantees

Every constraint in this subchapter â€” no external data, no infinite scale, no cheap storage, no undo, no speed, no privacy, no identity, no governance, no free transactions â€” exists because of the same underlying reason. These are the costs of the guarantees that make blockchains valuable in the first place.

Censorship resistance requires that no single party controls the system. That means every node processes everything, which limits throughput. Immutability requires that no one can alter history. That means no undo, ever. Trustless execution requires determinism. That means no external data access. Verifiability requires transparency. That means no privacy by default. Spam resistance requires costs. That means transaction fees.

You cannot remove a constraint without weakening a guarantee. Make transactions free, and you lose spam resistance. Add an undo mechanism, and you lose immutability. Allow external API calls, and you lose determinism. Give one party the ability to modify history, and you lose censorship resistance.

Every time someone tells you they have built a blockchain that solves all these problems, ask them which guarantee they sacrificed. The answer is always one of them. Sometimes the sacrifice is acceptable for the use case. Sometimes it defeats the purpose of using a blockchain at all. The point is that these trade-offs are inherent, not incidental. They are the physics of decentralized systems.

## The Builder's Framework: Design With Constraints

The builders who ship successful Web3 products are not the ones who try to make blockchains do everything. They are the ones who understand exactly what blockchains do well and design their systems to put only that work on-chain.

The framework is straightforward. Put value transfer, ownership records, and critical state transitions on the blockchain. Put everything else â€” user interfaces, large data storage, complex computation, real-time processing, private data â€” off-chain. Use the blockchain as the settlement layer and the source of truth for the things that matter most. Use traditional infrastructure for everything else.

This is not a compromise. It is good architecture. The best DeFi protocols, the most successful NFT platforms, the most resilient DAOs â€” they all follow this pattern. Uniswap executes swaps on-chain but serves its interface from a traditional web frontend. OpenSea records ownership on-chain but stores images and search indexes off-chain. MakerDAO manages its vaults on-chain but coordinates governance discussion on forums.

They use the blockchain for what it is uniquely good at: creating shared, verifiable, censorship-resistant state that no single party controls. And they use databases, APIs, cloud services, and traditional web infrastructure for everything else.

Understanding what blockchains cannot do is the foundation for understanding what they should do. The next subchapter takes this understanding further and gives you a concrete decision framework: when should you use a blockchain, and when should you use a database instead?
