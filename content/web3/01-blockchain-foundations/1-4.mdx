Scope: Web3

# 1.4 â€” Blocks, Transactions, and the Append-Only Log

The most common mistake in learning blockchain is starting with blocks. Open any introductory article, any YouTube explainer, any corporate whitepaper, and they lead with the same image: a chain of rectangles linked by arrows. Each rectangle is labeled "Block." Each arrow points backward. The reader nods, feels like they understand something, and walks away with a mental model that is almost entirely wrong. This is the **Block-First Fallacy** we named in subchapter 1.1, and it causes more confusion downstream than any other misconception in the space.

The fallacy works like this: you see the chain of blocks, you assume blocks are the fundamental unit, and you start thinking of blockchain as a data structure. But blockchain is not a data structure. It is a state machine. Blocks are not the fundamental unit. They are a packaging mechanism. A batch. A container.

The fundamental unit is the **transaction** â€” a signed instruction that changes the state of the machine. Everything a blockchain does, every balance update, every smart contract execution, every token transfer, begins with a transaction. Blocks exist for a practical reason: consensus protocols need to agree on batches of state transitions, not individual ones, because agreeing on things one at a time would be catastrophically slow.

If you understand transactions first and blocks second, everything about blockchain architecture becomes clearer. If you understand blocks first and transactions second, you spend months confused about why things work the way they do.

## What a Transaction Actually Is

A transaction is the smallest unit of intent on a blockchain. It is a signed message that says: "I want to change the state of this machine in a specific way." On a simple payment network, that change is a balance transfer. On a programmable blockchain like Ethereum or Solana, that change can be anything the state machine's rules allow â€” deploying a contract, swapping tokens, casting a governance vote, minting an NFT, or updating a piece of on-chain data.

Every transaction, regardless of which blockchain it lives on, shares a common anatomy. Think of it as a structured envelope containing everything the network needs to process the instruction.

There is a **sender** â€” the account initiating the state change, identified by a public address. There is a **receiver** â€” the account or contract that the transaction targets. There is a **value** â€” the amount of native currency being transferred, which can be zero if the transaction is purely a contract interaction. There is a **data field** â€” the instructions for what the receiving contract should do, empty for simple transfers but essential for any programmable interaction.

There is a **nonce** â€” a counter that tracks how many transactions this sender has previously submitted. The nonce serves a critical security function: it prevents replay attacks where someone could rebroadcast your old transaction and force you to pay twice. If you have sent 47 transactions from your account, the next valid transaction must carry nonce 48. A replayed transaction with nonce 45 gets rejected immediately.

And there is a **signature** â€” cryptographic proof that the sender actually authorized this transaction, created using their private key.

## Signatures: Trust Without Identity

The signature is what makes the entire system work without identity verification. Nobody needs to know who you are. Nobody needs to check your ID, verify your address, or call your bank. The cryptographic signature proves that whoever controls the private key for that account authorized this specific transaction with these specific parameters.

If the signature is valid, the transaction is legitimate. If it is not, the transaction is rejected. There is no middle ground, no appeal process, no customer service representative. The math either checks out or it does not.

This is how a network of strangers processes financial transactions without a single trusted intermediary. A bank verifies your identity and then authorizes your payments on your behalf. A blockchain verifies your cryptographic signature and then lets the network process your transaction on its own. The signature replaces the institution.

## The Mempool: Where Transactions Wait

When you submit a transaction, it does not immediately change the state of the blockchain. It enters the **mempool** â€” a waiting area where unconfirmed transactions sit until a validator picks them up and includes them in a block.

Think of the mempool as a queue at a busy restaurant. Your order has been placed, but the kitchen has not started cooking yet. The transaction is pending. It exists, but it has not been executed.

This distinction between submitted and confirmed is one of the most practically important concepts in blockchain development. Applications need to handle both states correctly. A wallet that shows a transaction as complete the moment it enters the mempool is lying to the user. A DeFi protocol that treats mempool transactions as final is exposing itself to front-running attacks, where other participants see the pending transaction and submit their own transactions to exploit the information.

The mempool is also public. On most blockchains, anyone can observe the mempool and see which transactions are waiting to be included. This transparency is a double-edged sword. It enables public auditability, but it also enables **MEV** â€” maximal extractable value â€” where sophisticated actors reorder, insert, or censor pending transactions to extract profit. We will explore MEV in detail later in this book.

## Why Transactions Get Grouped Into Blocks

If transactions are the fundamental unit, why do blocks exist at all? The answer is consensus efficiency.

A blockchain's consensus mechanism is the process by which thousands of independent nodes agree on the current state of the machine. This agreement is computationally and communicationally expensive. Every node needs to receive, validate, and store the agreed-upon state transitions.

If the network had to reach consensus on every single transaction individually â€” this transfer of 0.5 ETH, then that swap of 200 USDC, then this NFT mint â€” the overhead would be enormous. The network would spend more time agreeing than processing.

Blocks solve this by batching. Instead of agreeing on one transaction at a time, the network agrees on a group of transactions all at once. A validator collects pending transactions from the mempool, orders them, executes them against the current state, packages the results into a block, and proposes that block to the rest of the network. The other nodes verify the block â€” checking every transaction's signature, confirming the state transitions are valid, ensuring the block follows the chain's rules â€” and then accept or reject it as a unit.

This batching is not just a performance optimization. It is a structural requirement of the consensus model. Consensus protocols like proof of stake need a discrete, bounded unit to vote on. They need a thing that validators can propose, attest to, and finalize.

A continuous stream of individual transactions does not give the consensus mechanism anything concrete to agree on. A block does. It has a defined boundary: these transactions are in, those are not. It has a defined order: this transaction executes before that one. It has a defined result: the state after all these transactions have been applied is exactly this.

## The Append-Only Log

Here is where the architecture becomes elegant.

Each block contains a reference to the previous block â€” specifically, a cryptographic hash of the previous block's contents. This means block number 19,000,001 contains a fingerprint of block 19,000,000, which contains a fingerprint of block 18,999,999, and so on, all the way back to block zero, the **genesis block**. This chain of references is what creates the "chain" in blockchain.

The result is an **append-only log**. You can add new blocks to the end of the chain. You cannot edit, delete, or reorder blocks that are already in the chain.

Here is why. If you tried to change a transaction in block 15,000,000, the contents of that block would change. That would change its hash. That would break the reference in block 15,000,001. That would break the reference in block 15,000,002. And so on through every subsequent block. To alter history, you would need to rewrite not just the target block but every block that came after it â€” and convince more than half the network's validators to accept your rewritten version over the real one.

On a mature network like Ethereum or Bitcoin, this is economically and computationally infeasible. On Ethereum, it would require corrupting validators who have collectively staked tens of billions of dollars. On Bitcoin, it would require controlling more computational power than every honest miner in the world combined. The cost of rewriting history exceeds the value that could be stolen by doing so, which is the entire point.

## Immutability: The Core Guarantee

This append-only property is the source of blockchain's most powerful guarantee: **immutability**. Once a transaction is included in a finalized block, it becomes part of permanent history. No administrator can reverse it. No government can order it deleted. No database operator can edit it during a maintenance window.

The only way to "undo" a transaction is to submit a new transaction that reverses its effect â€” and that reversal itself becomes a permanent, auditable part of the record. History is never erased. It can only be extended.

Immutability is not absolute in the first few blocks, however. A block that was just proposed might still be reorganized â€” replaced by a competing block at the same height. This is why applications wait for multiple confirmations before treating a transaction as final.

On Bitcoin, six confirmations â€” roughly sixty minutes â€” is the traditional standard for large values. On Ethereum, finality comes through the consensus mechanism itself, with transactions reaching finality after about 12 to 15 minutes under normal conditions. On faster chains, finality can arrive in seconds. But across all these timelines, the principle is the same: once a block is finalized, it is permanent. The append-only log does not have an edit button.

## Block Time and What It Means for You

Different blockchains produce blocks at different speeds, and this single parameter has enormous downstream consequences for every application built on top of them.

Bitcoin produces a new block approximately every ten minutes. This was a deliberate design choice by Satoshi Nakamoto, optimized for security over speed. A ten-minute block time gives the network plenty of time for the block to propagate globally, for miners to validate it, and for consensus to stabilize.

But it means that a Bitcoin transaction takes at least ten minutes to get its first confirmation, and an hour for the traditional six-confirmation threshold. For a store of value or settlement layer, this is acceptable. For a payment at a coffee shop, it is not.

Ethereum produces a block every twelve seconds, a fixed interval established after the network's transition to proof of stake in September 2022. This means a transaction gets its first confirmation in twelve seconds and reaches finality in about twelve to fifteen minutes. That is fast enough for most DeFi interactions and significantly more responsive than Bitcoin, but still too slow for applications that need sub-second responsiveness.

Solana takes a radically different approach, producing blocks roughly every 400 milliseconds. This is possible because Solana's consensus mechanism, a combination of proof of stake and proof of history, was designed from the ground up for speed. The tradeoff is higher hardware requirements for validators, which limits who can run a node and therefore affects decentralization.

Solana consistently sustains 1,500 to 4,000 real transactions per second in normal operation, with peak tests pushing past 100,000 TPS in August 2025. Those peaks used lightweight test transactions rather than complex real-world operations, but they demonstrate the ceiling the architecture can reach.

Block time is not just a latency number. It shapes user experience, application architecture, DeFi protocol design, and even economic models. A swap on a decentralized exchange with twelve-second blocks feels different from a swap on a chain with 400-millisecond blocks. Arbitrage bots behave differently. Liquidation mechanics work differently. The entire tempo of the on-chain economy is set by this single parameter.

## Block Size, Throughput, and the Capacity Question

Every block has a size limit â€” a cap on how many transactions or how much computation it can contain. This limit exists because every node on the network must download, store, and process every block. If blocks were unlimited in size, the hardware requirements to run a node would escalate without bound, pricing out smaller participants and centralizing the network around a few well-resourced operators.

On Bitcoin, the block size limit is effectively about four megabytes under the SegWit rules, allowing roughly 2,000 to 3,000 transactions per block. At one block every ten minutes, that translates to about three to seven transactions per second.

On Ethereum, block capacity is measured in **gas** â€” a unit of computational effort â€” rather than raw bytes. Each block has a gas limit of approximately 30 million gas units. A simple ETH transfer costs 21,000 gas, so a block could theoretically hold about 1,400 simple transfers. In practice, because many transactions are more complex contract interactions that consume more gas, Ethereum processes roughly 15 to 30 transactions per second on its base layer.

These numbers sound small compared to traditional payment processors. Visa's network can handle thousands of transactions per second at peak capacity. But the comparison is misleading for two reasons.

First, every blockchain transaction is verified by every node in the network, not by a single data center. The security model is fundamentally different. Second, Layer 2 scaling solutions â€” rollups, sidechains, and payment channels â€” are designed to handle high-volume activity while periodically settling back to the base layer. The base layer provides security and finality. The upper layers provide speed and throughput. We will explore this architecture in depth in Chapter 4.

The relationship between block size and decentralization is one of the most consequential tradeoffs in blockchain design. Bigger blocks mean more throughput, but they also mean higher hardware requirements, fewer nodes, and more centralization. Smaller blocks mean more decentralization, but they also mean congestion, higher fees, and slower user experiences during peak demand.

Bitcoin's block size wars of 2015 to 2017 â€” one of the most contentious debates in cryptocurrency history â€” were fundamentally about this tradeoff. One faction wanted bigger blocks for more throughput. The other faction wanted small blocks to keep nodes accessible. The debate culminated in a chain split: Bitcoin kept small blocks, and Bitcoin Cash forked off with larger blocks. Bitcoin Cash never achieved the adoption its proponents hoped for, and the episode became a case study in how block size decisions encode values, not just engineering parameters.

Every blockchain makes this tradeoff differently, and understanding where a chain sits on this spectrum is essential for choosing the right platform for your application.

## The Chain as a Complete History

One of the most underappreciated properties of a blockchain is that it is a complete, replayable history of every state transition that has ever occurred on the network. The current state â€” every account balance, every contract's stored data, every token's current owner â€” is not stored as a snapshot. It is the result of executing every transaction in every block, in order, from the genesis block to the present.

This means you can reconstruct the current state of the entire network from nothing but the raw block data. Download every block from block zero to the latest block, replay every transaction in sequence, and you will arrive at exactly the same state that every other node holds.

This is not a theoretical property â€” it is how new nodes actually join the network. When you spin up a fresh Ethereum node, it downloads the chain's history and replays it, transaction by transaction, until it catches up to the present. For Ethereum, this process can take days because there are hundreds of millions of transactions to replay. Archive nodes that store every intermediate state â€” not just the final result but the state at every block height â€” require 14 to 18 terabytes of storage as of early 2026.

This replayability is the foundation of blockchain's auditability. You do not need to trust anyone's summary of what happened. You can verify it yourself by replaying the history.

Regulators, auditors, researchers, and forensic analysts all rely on this property. When a hack occurs and millions of dollars move through a chain of addresses, investigators trace the exact path by replaying the relevant transactions. When a DeFi protocol claims a certain yield over a certain period, anyone can verify the claim by replaying the contract's execution history. The data is there, permanently, for anyone to inspect. This is radically different from a traditional database, where history can be edited, deleted, or simply unavailable to external parties.

## What Validators Actually Do With Blocks

The process of creating a block is more involved than most explanations suggest.

In a proof-of-stake system like Ethereum, the protocol randomly selects a validator to propose the next block. That validator pulls pending transactions from its local mempool, orders them, executes them against the current state to ensure they are all valid, packages the results into a block structure with the appropriate header information, and broadcasts the proposed block to the network.

The ordering step is subtle but important. The validator chooses which transactions to include and in what order. This power is the source of MEV â€” the ability to profit by reordering transactions within a block. A validator could place their own transaction just before a large swap to capture the price impact, a practice called front-running. The Ethereum community has developed systems like Flashbots to make this ordering process more transparent and equitable, but the fundamental power of the block proposer to order transactions remains.

Proposing is only half the job. The rest of the network's validators must attest to the block â€” essentially voting that they have verified its contents and agree it should be added to the chain. On Ethereum, attestation happens through committees of validators assigned to each slot. Once enough attestations accumulate, the block is included in the canonical chain. After two epochs, roughly 12 to 15 minutes, the block reaches finality and cannot be reversed without an extraordinary consensus failure.

The validator's incentives matter enormously here. Validators earn rewards for proposing blocks and attesting correctly. They lose stake â€” a penalty called **slashing** â€” for proposing conflicting blocks, attesting to invalid state transitions, or going offline for extended periods. This economic incentive structure is what makes the system work without trust. Validators do not need to be honest out of goodness. They need to be honest because dishonesty is more expensive than honesty. We will explore this incentive design thoroughly in Chapter 2.

## The Transaction as the True Primitive

Everything in blockchain â€” every DeFi trade, every NFT sale, every governance vote, every stablecoin payment â€” starts as a transaction. The user signs an instruction. That instruction enters the mempool. A validator picks it up, packs it into a block with hundreds of other transactions. The block gets proposed, attested, and finalized. The state machine updates. The append-only log grows by one block.

Blocks are the batching mechanism. The chain is the ordering mechanism. The hash links are the integrity mechanism. But the transaction is the purpose. It is the unit of intent, the unit of state change, the unit of everything the user actually cares about.

When you send someone tokens, you care about the transaction. When you swap assets on a decentralized exchange, you care about the transaction. The block it lands in is an implementation detail â€” necessary for the system to function, but invisible to anyone who is not debugging infrastructure.

Understanding this hierarchy â€” transactions as the primitive, blocks as the batch, the chain as the ordered log, the hash links as the integrity guarantee â€” gives you a mental model that scales. Whether you are building on Bitcoin's simple UTXO model, Ethereum's account-based state machine, Solana's parallel execution engine, or any chain that launches tomorrow, the core architecture is the same. Signed instructions, batched into blocks, appended to an immutable log, verified by a distributed network.

The question that follows naturally from understanding the append-only log is: who exactly runs this distributed network? Blocks do not validate themselves. The state machine does not replicate itself. Somewhere, someone is running actual hardware â€” downloading blocks, executing transactions, storing state, and broadcasting results. The next subchapter examines exactly who those participants are, what motivates them, and why the number of nodes running the machine determines whether the system's promises are real or hollow.
