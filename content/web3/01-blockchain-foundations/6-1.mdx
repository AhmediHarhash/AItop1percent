Scope: Web3

# 6.1 â€” The Stack Has Layers

Every blockchain system you build sits on a stack. Not a single piece of software, not one monolithic chain â€” a stack of specialized layers, each handling a different job, each with its own tradeoffs, its own failure modes, and its own cost structure. If you do not understand the stack, you will build on it anyway and discover its constraints the hard way. Most teams do.

The concept is not complicated. Traditional web applications also have stacks â€” databases, application servers, load balancers, CDNs. You would never confuse a database with a CDN, and you would never ask your database to serve static assets. But in blockchain, teams routinely confuse layers. They blame "Ethereum" for high fees when the problem is their data availability strategy. They praise "Solana" for speed without understanding which execution tradeoffs make that speed possible. They deploy on an L2 without examining who sequences their transactions or where their data actually lives.

This chapter gives you the map. Five layers, clearly separated, with the role each one plays and the questions you need to ask before you commit your architecture to any of them.

## The Five Layers

The modular blockchain stack, as it exists in 2026, separates into five distinct layers. Each layer answers a different question.

**The settlement layer** answers: where does truth live? This is where transactions achieve finality â€” the point at which they cannot be reversed. Ethereum, Bitcoin, and Solana all function as settlement layers, but they provide different finality guarantees with different tradeoff profiles. When you choose a settlement layer, you are choosing the ultimate arbiter of your system's state.

**The execution layer** answers: where does computation happen? This is where smart contracts run, where state transitions are calculated, where the logic of your application actually executes. In a monolithic chain, execution and settlement happen on the same layer. In the modular world, they are separated. Rollups are execution layers that borrow their security from a settlement layer below them.

**The data availability layer** answers: can anyone verify the data? This is the layer most builders ignore until they get their first infrastructure bill. Every transaction produces data. That data needs to be available long enough for anyone to verify the execution was correct. Where that data lives and what it costs to store it determines your L2's economics more than almost any other decision.

**The sequencing layer** answers: who decides the order of transactions? Someone has to take the raw stream of user transactions and arrange them into an ordered sequence before execution. In most L2 rollups today, a single centralized sequencer does this job. That sequencer has enormous power â€” it decides who goes first, who waits, and whether certain transactions get included at all.

**The application layer** answers: what do users actually interact with? DeFi protocols, stablecoin transfers, NFT marketplaces, DAOs, real-world asset platforms â€” these are the applications that sit on top of the stack and give blockchain its purpose. Without this layer, the rest is infrastructure with no users.

## Why Modularity Happened

Blockchain did not start modular. Bitcoin is monolithic â€” it handles consensus, execution, data availability, and settlement on a single chain. Ethereum launched the same way. Every node did every job. That design is simple, secure, and brutally constrained.

Ethereum's base layer processes fifteen to twenty transactions per second. That is not a temporary limitation â€” it is a consequence of requiring every node to execute every transaction and store every piece of data. You cannot scale a monolithic chain without either increasing hardware requirements (which reduces decentralization) or reducing the amount of work each node does (which is what modularity achieves).

The insight that unlocked modularity was simple: not every layer needs the same security model. Settlement needs maximum security â€” it is the layer where disputes are resolved and truth is established. Execution can tolerate a weaker security model if there is a mechanism to verify its correctness against the settlement layer. Data availability can use an entirely different set of nodes optimized for throughput rather than computation. Sequencing can be handled by specialized infrastructure rather than the full validator set.

This is not theory. It is the architecture that dominates blockchain infrastructure in 2026. Ethereum settled into its role as the primary settlement layer. Rollups like Arbitrum, Base, and Optimism handle execution. Celestia and EigenDA provide alternative data availability. Espresso and Astria are building shared sequencing networks. The monolithic chain still exists â€” Solana is the most prominent example â€” but even Solana's ecosystem is developing modular extensions as it hits its own scaling walls.

## Monolithic Versus Modular: The Tradeoff That Defines Everything

A monolithic chain does everything on one layer. A modular stack splits responsibilities across specialized layers. Neither approach is universally better. Each makes a different bet about what matters most.

Monolithic chains bet on simplicity and composability. When everything runs on one chain, every smart contract can call every other smart contract in a single atomic transaction. There is no bridging, no cross-chain messaging, no fragmented liquidity. The developer experience is clean. The user experience is seamless. The tradeoff is throughput â€” you are limited by what a single chain can process.

Modular stacks bet on specialization and scale. By separating execution from settlement from data availability, each layer can be optimized independently. Execution layers can process thousands of transactions per second without waiting for settlement finality. Data availability layers can offer gigabytes of throughput without requiring execution capability. The tradeoff is complexity â€” you now have multiple layers that must communicate correctly, and failures in one layer can cascade to others.

The choice between monolithic and modular is not abstract. It determines your cost structure, your user experience, your security model, and your operational complexity. A DeFi protocol that needs atomic composability with dozens of other protocols has a strong argument for staying monolithic. A payments application that needs low fees and high throughput has a strong argument for a modular rollup. A gaming platform that generates enormous transaction volume but does not need financial-grade security has a strong argument for an appchain with its own execution and data availability layers.

## The Layer Confusion Problem

The most common architectural mistake in blockchain development is treating the stack as a single thing. Teams say "we are building on Ethereum" without specifying whether they mean Ethereum L1, an Ethereum rollup, or an appchain that settles to Ethereum. These are three radically different architectures with different cost profiles, different performance characteristics, and different security models.

In mid-2025, a team building a decentralized social media protocol launched directly on Ethereum L1. They designed their smart contracts to store user posts and social graphs on-chain. Within weeks, their users were paying five to fifteen dollars per post in gas fees during busy periods. The team's diagnosis was "Ethereum is too expensive." The actual problem was a layer confusion â€” they were using the settlement layer for application-level data storage. Moving their execution to an L2 and their data to a dedicated availability layer reduced costs by over ninety-nine percent.

This story repeats across the industry. Teams deploy compute-heavy logic on settlement layers. They store temporary data on layers designed for permanent state. They trust centralized sequencers without understanding what centralization means for their users. Every one of these mistakes comes from the same root cause: not understanding which layer does what.

## How to Read the Rest of This Chapter

The next seven subchapters walk through each layer in detail. For each one, you will learn what it does, who the major players are, what tradeoffs define it, and what questions you need to ask before choosing your approach.

Subchapter 6.2 covers the settlement layer â€” where finality lives and what it guarantees. Subchapter 6.3 covers the execution layer â€” where computation happens and how rollups changed the game. Subchapter 6.4 covers the data availability layer â€” the hidden cost driver that most teams discover too late. Subchapter 6.5 covers the sequencing layer â€” who orders your transactions and why it matters. Subchapter 6.6 covers the application layer â€” where blockchain becomes useful for real people. Subchapter 6.7 shows how the layers interact and where they break. Subchapter 6.8 maps the rest of this book onto the stack so you always know where you are.

You do not need to memorize every detail. But by the end of this chapter, you should be able to look at any blockchain architecture and identify which layer is doing which job â€” and whether the team that built it made that choice deliberately or stumbled into it by accident. That distinction, more than any other, separates architects from assemblers.

The settlement layer is where the stack begins, because settlement is where truth lives.
