Scope: Web3

# 4.8 â€” The Modular Blockchain Thesis

For most of blockchain's history, every chain tried to do everything. Bitcoin processes transactions, validates them, stores them, and reaches consensus â€” all in one piece of software, run by every node, on every block. Ethereum does the same. Solana does the same but faster. This architecture has a name: **monolithic**. One chain, one software stack, one set of nodes responsible for execution, consensus, settlement, and data availability simultaneously. If you want to change how any one of those functions works, you change the whole chain. If one function hits a bottleneck, the whole chain slows down.

The modular blockchain thesis says this is the wrong architecture. Not because monolithic chains are bad, but because forcing every function into a single layer creates tradeoffs that do not need to exist. What if execution happened on one layer, settlement on another, and data availability on a third â€” each optimized independently, each scaling without dragging the others down? That is the shift that has reshaped blockchain architecture between 2023 and 2026, and understanding it is essential to understanding where the industry is heading.

## What a Blockchain Actually Does: Four Functions

Before you can separate the layers, you need to understand what they are. Every blockchain performs four core functions, whether it does them all in one place or distributes them across specialized systems.

**Execution** is the process of running transactions â€” computing state changes, updating balances, executing smart contract logic. When you swap tokens on a decentralized exchange, execution is the step that calculates how many tokens you receive, deducts them from the liquidity pool, and credits your wallet. Execution is the function most users interact with directly, and it is the function most sensitive to throughput and latency.

**Settlement** is the process of finalizing those state changes â€” declaring that a transaction is irreversible and the resulting state is canonical. On Bitcoin, settlement happens through proof-of-work finality â€” after six confirmations, a transaction is considered settled. On Ethereum, settlement happens through proof-of-stake finality â€” after two epochs (roughly 13 minutes), the state is finalized by the validator set. Settlement is what gives a blockchain its security guarantee. Without it, every balance is provisional.

**Consensus** is how the network agrees on the order and validity of transactions. Which transactions go in which block, in what sequence, and whether each one follows the protocol rules. Consensus is deeply intertwined with settlement â€” the consensus mechanism is what produces finality â€” but the two are conceptually separable. A system can achieve consensus on ordering without immediately settling the result.

**Data availability** is the guarantee that the data needed to verify the chain's state is accessible to anyone who wants it. This is the function most people overlook, and as we covered in the previous subchapter, it is the one that creates the deepest bottlenecks. A block is only useful if its contents are available for verification. If a block producer publishes a header but withholds the transaction data, no one can independently verify whether the state transition was valid.

In a monolithic chain, every node performs all four functions on every block. In a modular architecture, each function can be handled by a different specialized system.

## How Ethereum Became Modular Without Calling Itself That

Ethereum did not start as a modular blockchain. When it launched in 2015, it was as monolithic as they come. Every node executed every transaction, validated every block, stored every byte of state, and participated in consensus. If you wanted to use Ethereum, you accepted its throughput limits â€” roughly 15 transactions per second â€” because there was nowhere else for execution to happen.

The shift began with rollups. Starting in 2020 with the first optimistic rollup deployments and accelerating through 2023 and 2024, Ethereum began outsourcing execution to Layer 2 networks. Arbitrum, Optimism, Base, zkSync, StarkNet â€” each of these is an execution layer that processes transactions off the Ethereum mainnet and posts compressed results back to Layer 1 for settlement.

This split was the first modular move: execution separated from settlement. Ethereum L1 stopped being the place where most transactions run. It became the place where their results are finalized and secured. By early 2026, Ethereum L2s collectively process the overwhelming majority of the ecosystem's transactions, while L1 handles settlement and security.

The second modular move was data availability. Before March 2024, rollups posted their transaction data as calldata on Ethereum L1 â€” expensive, permanent, stored by every node forever. Then EIP-4844 (Proto-Danksharding) introduced **blobs**: temporary data attachments that are available for verification for roughly 18 days and then pruned. Blobs gave rollups a cheaper way to post data without permanently bloating L1 state. The Pectra upgrade in May 2025 doubled the target blob count from three to six per block. Then the Fusaka upgrade in December 2025 deployed PeerDAS, which expanded capacity to 48 blobs per block. PeerDAS changed the data availability model fundamentally â€” nodes no longer need to download every blob. They sample random portions and use cryptographic proofs to verify the full dataset exists. This is **data availability sampling**, and it allows Ethereum's data throughput to scale without requiring every node to process every byte.

The result is that Ethereum in 2026 is a modular system in practice, even though no single announcement declared it one. Execution happens on L2s. Data availability is provided through blobs with PeerDAS sampling. Settlement and consensus remain on L1, secured by over a million validators staking more than 34 million ETH. Each layer has been optimized independently. L2s compete on execution speed and cost. The blob market provides cheap, temporary data availability. L1 provides the security anchor that makes it all credible.

## The Pure Modular Approach: Celestia and the DA Layer

Ethereum's modular evolution happened organically â€” a monolithic chain that gradually separated its functions. Celestia took the opposite approach: it was designed from the ground up to do one thing and nothing else. Celestia is a **data availability layer**. It does not execute transactions. It does not settle state. It does not run smart contracts. Its entire purpose is to provide cheap, scalable, verifiable data availability for other chains that need somewhere to publish their transaction data.

Celestia launched its mainnet in October 2023 and introduced a key innovation: data availability sampling at the protocol level. Light nodes on Celestia do not need to download all the data in a block. They sample small random portions and use a technique called **erasure coding** â€” where data is expanded with redundancy so that the original can be reconstructed from any sufficiently large subset â€” combined with **Namespaced Merkle Trees** to verify that the complete data is available. This means Celestia can increase its block size and throughput without proportionally increasing the work required by each node, which is the fundamental scaling breakthrough that monolithic chains cannot achieve without sacrificing decentralization.

More than 20 rollups launched on Celestia's data availability layer within its first year. Instead of posting data to Ethereum as blobs, these rollups post data to Celestia, typically at lower cost, and then settle their state on Ethereum or another settlement layer. The architecture looks like this: the rollup executes transactions, posts the data to Celestia for availability, and submits a state commitment to Ethereum for settlement. Three different systems, each doing what it does best.

EigenDA takes yet another approach. Built on EigenLayer's restaking protocol, EigenDA is a data availability service that inherits Ethereum's economic security. Ethereum validators who have already staked ETH can "restake" that same ETH to also secure EigenDA, meaning the cost of attacking EigenDA's data availability is backed by the same capital that secures Ethereum itself. EigenDA is not a separate blockchain â€” it is a service that runs on top of Ethereum's existing validator set. Its V2 release achieves 100 megabytes per second of data throughput, making it one of the highest-capacity DA solutions available.

Avail, which emerged from the Polygon ecosystem, positions itself as a universal data availability layer â€” not tied to Ethereum or any specific settlement chain. Avail uses its own proof-of-stake consensus with data availability sampling, aiming to serve rollups across multiple ecosystems rather than anchoring to any single one.

The competition between these DA layers â€” Ethereum's native blobs, Celestia, EigenDA, Avail â€” is one of the most consequential architectural races in the industry. The winner determines where rollups post their data, which in turn determines the economic flows, security guarantees, and cost structures of the entire modular stack.

## The Modular Stack in Practice

When you build an application in a modular world, you are not choosing "a blockchain." You are assembling a stack. Each layer is a separate decision with its own tradeoff profile.

For execution, you choose a rollup or execution environment. Arbitrum and Optimism use optimistic fraud proofs. zkSync and StarkNet use zero-knowledge validity proofs. Base is an optimistic rollup built by Coinbase with deep fiat on-ramp integration. Each has different cost profiles, finality times, developer tooling, and user bases. Your execution layer determines the user experience â€” transaction speed, gas costs, and the smart contract environment your application runs in.

For data availability, you choose where your rollup publishes its data. Ethereum blobs are the most secure option, backed by Ethereum's full validator set, but they have finite capacity â€” even with PeerDAS, blob space is limited, and demand from hundreds of rollups creates a fee market. Celestia is cheaper but introduces a separate trust assumption â€” you are trusting Celestia's validator set, not Ethereum's, for data availability. EigenDA inherits Ethereum's economic security through restaking but adds the complexity of a separate system. Your data availability choice determines cost and security.

For settlement, you choose where state is finalized. Most Ethereum L2s settle on Ethereum L1, which provides the highest security guarantee in the ecosystem. But settlement on Ethereum costs gas, and the settlement frequency affects finality time. Some chains settle on other L1s or even on L2s â€” a pattern sometimes called L3s â€” trading settlement security for lower costs.

For consensus, the rollup's sequencer determines transaction ordering. Most L2s currently run centralized sequencers â€” a single entity that orders transactions before they are batched and posted. Decentralizing sequencers is an active research area, but as of early 2026, centralized sequencing remains the norm for major rollups. This is a trust assumption that monolithic chain advocates correctly point to as a weakness of the current modular stack.

## The Tradeoffs of Going Modular

The modular thesis is not free. It solves some problems and creates others, and understanding both sides is what separates informed builders from hype followers.

The primary benefit is independent scaling. When execution is separate from data availability, you can scale execution (by adding more rollups or increasing rollup throughput) without needing to scale the settlement layer. You can scale data availability (by expanding blob capacity or using an external DA layer) without changing the execution environment. Each layer can be optimized by specialized teams focused on that specific problem, rather than by a single team trying to optimize everything at once.

The primary cost is complexity. In a monolithic chain, the security model is one thing: the chain itself. In a modular stack, the security model is a composition of assumptions: the settlement layer's security, the DA layer's security, the sequencer's honesty, the bridge between layers, the proof system's correctness. Each component adds a potential failure mode. Each interaction between components adds a potential attack surface. The total security is not the sum of its parts â€” it is limited by the weakest link.

Trust assumptions multiply. If you use an L2 that settles on Ethereum but posts data to Celestia, you are trusting Ethereum's validators for settlement, Celestia's validators for data availability, the L2's sequencer for transaction ordering, the bridge between Celestia and Ethereum for data commitments, and the L2's fraud proof or validity proof system for execution correctness. That is five distinct trust assumptions. On a monolithic chain like Solana, you trust one validator set for everything. Fewer assumptions, fewer attack surfaces â€” but also fewer opportunities for independent optimization.

The user experience becomes fragmented. Assets on different L2s are not natively interchangeable. Moving tokens from Arbitrum to Base requires a bridge. Different L2s have different gas tokens, different tooling, different block explorers. The industry is actively working on this â€” chain abstraction, intent-based bridging, and cross-chain messaging protocols aim to make the modular stack feel like a single system â€” but as of 2026, the seams are still visible to users.

Composability across layers is harder. On a monolithic chain, every smart contract can interact with every other smart contract in a single atomic transaction. On a modular stack, contracts on different L2s cannot compose atomically. A DeFi protocol on Arbitrum cannot flash-loan from a lending pool on Optimism within the same transaction. Shared sequencers and cross-chain messaging protocols are emerging to address this, but native monolithic composability remains an advantage for applications that depend on real-time interaction between contracts.

## Why Modular Won Anyway

Despite the added complexity, the modular approach has become the dominant architectural direction for Ethereum and the broader industry. The reason is simple: the alternative was worse.

Ethereum's L1 processes roughly 15 transactions per second. Even with aggressive protocol upgrades, monolithic Ethereum was never going to serve hundreds of millions of users at reasonable cost. The choice was between staying monolithic and accepting that Ethereum would only serve high-value DeFi transactions â€” where users would tolerate multi-dollar gas fees â€” or going modular and enabling low-cost execution for consumer applications, gaming, payments, and everything else.

Solana proved that a monolithic approach can achieve much higher throughput â€” thousands of transactions per second with sub-cent fees. But it did so by requiring enterprise-grade hardware for validators: 256 gigabytes of RAM minimum, high-end CPUs, 10-gigabit networking. The result is a validator set that, after the Solana Foundation's pruning in 2025, numbers around 800 staked validators â€” compared to Ethereum's million-plus. That is a decentralization tradeoff. Solana chose it consciously and it works for Solana's use cases, but it demonstrates exactly the trilemma constraint that the modular thesis aims to avoid.

The modular approach allows Ethereum to maintain its decentralization â€” anyone can run an L1 validator node on consumer hardware â€” while offloading execution to layers that can optimize for speed and cost. It is not that modular is "better" than monolithic. It is that modular allows a specific set of tradeoffs that Ethereum's community chose: maximum decentralization and security on L1, with scalability achieved through composition rather than raw throughput.

## What Modular Means for You

If you are building an application, the modular thesis changes your decision process. You are no longer choosing between Ethereum and Solana and Avalanche as if they are equivalent single things. You are choosing a stack â€” an execution layer, a DA layer, a settlement layer â€” and each choice affects your application's cost, security, finality, and user experience.

This is more complex than picking a monolithic chain and building on it. It is also more powerful, because it lets you match each layer to your application's specific requirements. A high-value DeFi protocol might execute on an Ethereum L2, post data to Ethereum blobs for maximum security, and settle on L1 â€” accepting higher costs for bulletproof settlement. A consumer gaming application might execute on a dedicated appchain, post data to Celestia for cheap availability, and settle on an L2 â€” optimizing for low cost at the expense of some security guarantees.

The modular thesis does not tell you which configuration is right. It tells you that the configuration exists as a design space, and your job as a builder is to navigate it deliberately rather than defaulting to whatever chain has the best marketing.

The next subchapter introduces the framework for that navigation: the Tradeoff Profile, a structured approach to choosing the right configuration for your specific application.
