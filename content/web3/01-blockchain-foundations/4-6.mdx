Scope: Web3

# 4.6 â€” Rollups: Optimistic vs ZK

Two architectures dominate the rollup landscape. Both solve the same problem â€” proving to Ethereum that a batch of off-chain transactions was executed correctly â€” but they solve it in opposite ways. Optimistic rollups assume every batch is valid and let anyone challenge that assumption after the fact. Zero-knowledge rollups prove every batch is valid upfront, using cryptographic math that Ethereum can verify in milliseconds. The choice between them is not abstract. It determines your withdrawal speed, your transaction cost, your developer experience, and the finality guarantees your users can rely on.

## Optimistic Rollups: Trust, Then Verify

**Optimistic rollups** take their name from their core assumption: the state transitions published by the sequencer are presumed correct unless someone proves otherwise. The rollup posts a batch of transactions and a new state root to Ethereum, and the L1 accepts it provisionally. Then a clock starts ticking.

During the **challenge window** â€” seven days on both Arbitrum and Optimism â€” any observer can submit a **fraud proof** to the L1 contract. A fraud proof is a demonstration that the posted state root does not match what you get when you actually re-execute the transactions in the batch. If someone submits a valid fraud proof within the window, the incorrect state is rolled back, the sequencer's bond is slashed, and the challenger receives a reward.

If nobody challenges the batch within seven days, the state transition is accepted as final. Ethereum treats it as settled, and withdrawals from L2 to L1 can be processed.

The economics of this design are elegant. In normal operation, nobody needs to submit fraud proofs because the sequencer is honest. The L1 never re-executes L2 transactions. The only cost is posting compressed transaction data to Ethereum. The fraud proof mechanism exists as a deterrent â€” the threat of challenge is what keeps the sequencer honest, not the actual execution of challenges.

This is analogous to how tax audits work. Most people file honest tax returns, not because every return is audited, but because any return could be audited. The cost of auditing every return would be prohibitive. The threat of audit, combined with penalties for fraud, is enough to maintain system integrity at a fraction of the cost.

## The Seven-Day Problem

The challenge window creates a practical problem that every optimistic rollup user encounters: withdrawals from L2 to L1 take seven days. You cannot move your assets back to Ethereum mainnet in less than a week because the system needs to wait until the challenge window closes to confirm that your withdrawal's underlying state is valid.

Seven days is an eternity in crypto. Markets move, opportunities expire, and emergencies do not wait for a challenge period. This constraint has spawned an entire ecosystem of **liquidity bridges** â€” services that front you L1 assets immediately in exchange for a fee, then collect the actual withdrawal when it settles seven days later. Across, Hop Protocol, Stargate, and others provide this service, essentially acting as market makers for time. You pay a premium â€” typically 0.1 to 0.5 percent â€” to avoid waiting.

The existence of these bridges means that the seven-day delay is not a hard user experience barrier for most transactions. If you need your ETH on L1 today, you can get it today, for a fee. But the fee is an ongoing cost of the optimistic architecture. It is a tax on every user who needs to exit the L2, and it creates a permanent economic moat for bridge operators.

For builders, the seven-day withdrawal period creates design constraints. If your application requires fast L2-to-L1 communication â€” say, an arbitrage bot that needs to move capital between layers in minutes â€” you either pay bridge fees on every cycle or you accept that optimistic rollups are not the right architecture for your use case.

## Optimistic Rollup Fraud Proofs: The Mechanism

The mechanics of fraud proof systems are worth understanding because they reveal the engineering tradeoffs beneath the surface.

Arbitrum uses an **interactive fraud proof** system. When a challenger disputes a state transition, the L1 does not re-execute the entire batch. Instead, the challenger and the sequencer engage in a back-and-forth narrowing process, called **bisection**, that identifies the single instruction where their execution diverges. Once the dispute is narrowed to a single computational step, the L1 re-executes that one step and determines who is correct. This approach minimizes L1 computation â€” instead of re-executing thousands of transactions, the L1 re-executes one instruction.

Optimism, in contrast, originally used a **non-interactive fraud proof** system â€” a single proof demonstrating the full re-execution of the disputed state transition. This approach is simpler but more expensive on-chain. As of 2025, Optimism transitioned to a multi-round interactive fault proof system that shares some structural similarities with Arbitrum's approach, though the implementations differ in detail.

In practice, fraud proofs on major optimistic rollups have been extremely rare. The economic incentive structure makes fraud unprofitable â€” the sequencer's bond is large enough that attempting to post a fraudulent state transition is a losing proposition even if the fraud were to go unchallenged. The fraud proof mechanism is a loaded gun on the table. Nobody wants to use it, but everyone behaves because it is there.

## Zero-Knowledge Rollups: Prove, Then Trust

**Zero-knowledge rollups** â€” often called **ZK rollups** â€” take the opposite approach. Instead of assuming validity and waiting for challenges, ZK rollups generate a cryptographic proof that the posted state transition is mathematically correct. This proof, called a **validity proof**, can be verified by Ethereum's L1 contract in milliseconds, even though generating it may take significant computational resources.

The name "zero-knowledge" is technically a misnomer in this context. Zero-knowledge proofs were originally designed to prove a statement without revealing any information beyond the statement's truth â€” for example, proving that you know a password without revealing the password. In ZK rollups, the proof is about computational integrity â€” proving that executing this batch of transactions produces this state root â€” not about hiding information. Most ZK rollups are fully transparent; anyone can see the transactions. The cryptographic technique is called "zero-knowledge" because of its mathematical lineage, but the rollup application uses it for verification, not privacy.

The practical difference is finality. Because the L1 can verify a validity proof immediately, there is no need for a challenge window. Once the proof is posted and verified, the state transition is final. Withdrawals from a ZK rollup to L1 can settle in hours rather than days. There is no seven-day wait. There is no need for liquidity bridges to front capital. The proof itself is the guarantee.

## ZK Rollup Architecture: The Major Players

The ZK rollup ecosystem includes several distinct architectures, each making different tradeoffs around EVM compatibility, performance, and proof systems.

**zkSync Era**, built by Matter Labs, uses a custom virtual machine that compiles Solidity and Vyper code through its own compiler toolchain. Developers can write standard Solidity smart contracts, but the bytecode is compiled into a format optimized for ZK proof generation rather than the standard EVM bytecode. This means most Solidity contracts can be ported, but edge cases exist â€” contracts that rely on specific EVM opcodes or low-level assembly may require modification. zkSync processes hundreds of transactions per second and has accumulated significant DeFi activity since its mainnet launch in March 2023.

**StarkNet**, built by StarkWare, takes a more radical approach. StarkNet uses its own programming language called **Cairo**, designed from the ground up for provable computation. Cairo is not Solidity. The syntax is different, the mental model is different, and the development experience is fundamentally distinct from EVM development. StarkNet supports Solidity developers through transpilation tools and growing Cairo interoperability, but building natively on StarkNet means learning a new language. The tradeoff is performance â€” Cairo's design enables more efficient proof generation than retrofitting ZK proofs onto EVM-compatible execution.

**Scroll** and **Linea** pursue the maximum compatibility approach, building what are classified as Type 2 ZK-EVMs. They aim for near-perfect bytecode equivalence with the Ethereum Virtual Machine, meaning you can deploy the exact same Solidity bytecode that runs on Ethereum mainnet without any code changes. You use the same tools â€” Hardhat, Foundry, MetaMask, Remix â€” and expect the same behavior. The tradeoff is that generating ZK proofs for EVM-equivalent execution is computationally harder than proving execution in a VM designed for provability. Proof generation times and costs are higher for Type 2 implementations than for custom VMs like Cairo.

This spectrum â€” from fully custom VMs optimized for proving to fully EVM-compatible bytecode execution â€” represents a fundamental engineering tradeoff. Custom VMs generate proofs faster and cheaper but require developers to learn new tools or accept compilation differences. EVM-compatible implementations offer seamless migration from L1 but pay for that compatibility with more expensive proof generation.

## The Proving Cost Problem

Generating a ZK proof is computationally expensive. The prover â€” the system that generates the validity proof for a batch of transactions â€” requires specialized hardware and significant compute time. As of early 2026, proving costs remain one of the largest operating expenses for ZK rollup operators, though the situation has improved dramatically.

In the early days of ZK rollups, generating a proof for a single batch could take minutes and cost significant amounts in hardware and electricity. By 2026, proving times have collapsed from minutes to seconds for many batch sizes. This improvement comes from a combination of better proof systems, hardware acceleration using GPUs and custom ASICs, and more efficient circuit designs. The trend is clear: proving costs are falling rapidly, and the hardware ecosystem for ZK proving is maturing as dedicated proving infrastructure becomes a market in its own right.

But the cost is not zero, and it likely never will be. Generating a ZK proof is inherently more expensive than simply asserting a state transition and waiting for challenges. This means ZK rollup transactions carry a per-transaction proving cost that optimistic rollups do not. For very cheap transactions â€” sub-cent operations on gaming platforms or social applications â€” the proving cost can represent a significant fraction of the total fee.

The counterargument is that the proving cost buys you something valuable: instant finality without a seven-day wait. For applications where withdrawal speed matters â€” high-frequency trading, cross-chain arbitrage, institutional settlement â€” the proving cost is a worthwhile trade for immediate finality. For applications where withdrawal speed does not matter â€” a staking protocol where funds are locked for months â€” the proving cost is pure overhead.

## The Compatibility Spectrum

Vitalik Buterin published a taxonomy of ZK-EVM types in 2022 that remains the canonical framework for understanding the compatibility-performance tradeoff. The taxonomy runs from Type 1 through Type 4.

**Type 1** aims for full Ethereum equivalence â€” not just EVM compatibility, but identical behavior at the consensus level. A Type 1 ZK-EVM could theoretically verify Ethereum blocks themselves. No production rollup has achieved this as of early 2026, though Taiko has made significant progress toward this goal.

**Type 2** aims for full EVM equivalence at the smart contract level. You can deploy the same bytecode and expect the same behavior. Scroll and Linea fall into this category. The tradeoff is proving efficiency â€” making ZK proofs for fully EVM-compatible execution is computationally demanding.

**Type 3** is almost EVM-equivalent, with a few minor incompatibilities that reduce proving cost. Some precompiled contracts or opcodes may behave slightly differently. Most applications work without changes, but edge cases exist.

**Type 4** compiles high-level languages like Solidity to a custom VM designed for proving. zkSync Era is the canonical example. Developer experience is close to standard Solidity development, but the underlying execution differs.

The industry trend is moving toward higher compatibility types. Proving technology improvements are making Type 2 implementations increasingly practical. By 2026, the gap between Type 2 and Type 4 proving costs has narrowed significantly. The long-term trajectory suggests that full EVM equivalence will eventually be achievable without prohibitive proving overhead, but that endpoint has not been reached yet.

## How the Tradeoffs Shape Your Decision

The choice between optimistic and ZK rollups is not about which technology is "better." It is about which tradeoff profile matches your application.

Choose an optimistic rollup if your application benefits from the deepest liquidity and the broadest developer ecosystem. Arbitrum and Optimism/Base have first-mover advantages in DeFi and consumer applications. Their tooling is mature, their documentation is extensive, and their ecosystems have the most applications. The seven-day withdrawal delay is real but manageable through bridges, and for most applications, users rarely withdraw to L1 at all.

Choose a ZK rollup if your application requires fast finality between L2 and L1. If your users need to move assets between layers frequently, the immediate finality of ZK proofs eliminates the bridge fees and time delays that optimistic rollups impose. If your application handles institutional settlements where seven-day delays are contractually unacceptable, ZK rollups are the natural fit.

Choose a ZK rollup if you anticipate that privacy features will be important. The zero-knowledge cryptographic primitives underlying ZK rollups can be extended to support transaction privacy â€” hiding sender, receiver, or amount information while still proving correctness. This capability is architecturally native to ZK systems and significantly harder to retrofit onto optimistic rollups.

The practical reality of early 2026 is that optimistic rollups lead in DeFi TVL, user adoption, and developer ecosystem size. ZK rollups lead in finality speed, theoretical security properties, and long-term scalability potential. The two families are converging â€” optimistic rollups are exploring ZK-based fraud proofs, and ZK rollups are achieving better EVM compatibility â€” but the architectural distinction remains meaningful for builders making infrastructure decisions today.

## The Convergence Trend

The line between optimistic and ZK rollups is blurring. Optimism has explored incorporating ZK proofs as a faster alternative to the seven-day challenge window. If a ZK proof can verify a batch's correctness in minutes rather than waiting seven days for challenges, the withdrawal delay problem largely disappears. This would give optimistic rollups the developer ecosystem advantage they already have, combined with the finality speed of ZK rollups.

Meanwhile, ZK rollups are improving EVM compatibility to the point where migration from L1 or optimistic L2s requires minimal code changes. If a ZK rollup offers the same developer experience as an optimistic rollup, plus faster finality, the architectural choice shifts toward ZK.

The likely end state â€” though predicting timelines in crypto is an exercise in humility â€” is that the distinction between optimistic and ZK rollups becomes an implementation detail rather than an architectural decision. Both families will post compressed data to Ethereum. Both will generate proofs of correctness. The proofs may take different forms, but the user-facing properties â€” cost, speed, security â€” will converge.

That convergence has not happened yet. For builders making decisions in 2026, the tradeoffs remain real, the ecosystems remain distinct, and the choice matters. But understanding both architectures deeply enough to make that choice is exactly what separates builders who pick infrastructure deliberately from builders who follow whatever chain has the loudest marketing.

Both rollup architectures share a cost that dominates their economics: posting data to Ethereum. The cost of that data posting is not determined by the rollup's execution speed or proof system. It is determined by something far more fundamental â€” where and how the rollup makes its transaction data available. Data availability is the hidden bottleneck that most builders never think about, and the next subchapter explains why it matters more than anything else in your L2 cost structure.
