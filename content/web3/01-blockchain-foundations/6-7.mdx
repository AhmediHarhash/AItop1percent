Scope: Web3

# 6.7 â€” How the Layers Interact (and Where They Break)

A user taps "Swap" on a decentralized exchange running on Base. The frontend constructs a transaction and sends it to the user's wallet. The wallet signs it and submits it to Base's sequencer. The sequencer receives the transaction, orders it among hundreds of others arriving in the same second, and includes it in the next batch. The user gets a soft confirmation â€” the sequencer's promise that the swap will be included. The sequencer compresses the batch and posts it as a blob to Ethereum's data availability layer. Ethereum validators include that blob in the next L1 block. The state root â€” a cryptographic summary of all the state changes in the batch â€” is posted to the settlement contract on Ethereum. For the next seven days, anyone can challenge the batch with a fraud proof. Nobody does. The swap is settled. Final. Irreversible.

That journey â€” from tap to finality â€” crossed every layer of the stack. It touched the application layer, the sequencing layer, the data availability layer, and the settlement layer. Each layer added latency. Each added cost. Each depended on the layer below it functioning correctly. Understanding this lifecycle is what turns a list of stack layers into an architecture you can reason about.

## The Full Transaction Lifecycle

Break the lifecycle into five stages, because each stage introduces a different type of latency, a different cost component, and a different failure risk.

**Stage one: user intent to signed transaction.** The user interacts with a frontend, which constructs a transaction â€” the target contract address, the function being called, the parameters, and the gas settings. The wallet presents this for signature. This stage takes anywhere from one to thirty seconds, depending on whether the wallet simulates the transaction, whether the user needs to review details, and whether the wallet is a hot wallet or a hardware device requiring physical confirmation. The cost here is zero in terms of on-chain fees, but the UX quality of this stage determines whether the user completes the action or abandons it.

**Stage two: submission to sequencer and soft confirmation.** The signed transaction reaches the sequencer's mempool. The sequencer orders it, typically in a first-come-first-served manner with some priority fee logic, and issues a soft confirmation â€” an off-chain promise that the transaction will be included in the next batch. This stage takes under two seconds on most major rollups. The cost to the user is the L2 gas fee, which covers execution and contributes to the sequencer's margin. The trust assumption here is significant: the soft confirmation is only as reliable as the sequencer's honesty and uptime.

**Stage three: batch compression and DA posting.** The sequencer accumulates transactions over a batching interval â€” anywhere from a few seconds to several minutes, depending on the rollup's configuration and traffic volume â€” then compresses the batch and posts it to the DA layer. If the DA layer is Ethereum blobs, the sequencer submits a blob-carrying transaction to Ethereum's mempool and waits for L1 inclusion. If the DA layer is Celestia or EigenDA, the sequencer posts to that network's submission endpoint. This stage adds anywhere from thirty seconds to several minutes of latency, depending on L1 block times and congestion. The cost is the DA fee â€” the per-byte or per-blob charge that the DA layer imposes â€” and this is typically the largest single cost component in the entire lifecycle.

**Stage four: settlement and proof verification.** For optimistic rollups, the state root is posted to the settlement contract on Ethereum along with the DA commitment. The seven-day challenge window begins. For ZK rollups, the validity proof is generated â€” a computationally intensive process that can take minutes to hours depending on the proof system and the batch size â€” and then verified by the settlement contract on Ethereum. This stage adds the most latency to true finality. For optimistic rollups, final settlement takes seven days. For ZK rollups, it takes as long as proof generation and L1 verification require â€” typically minutes to hours.

**Stage five: finality.** Once the challenge window passes without dispute (optimistic) or the validity proof is verified (ZK), the state transition is final. It is backed by Ethereum's economic security. Reversing it would require corrupting Ethereum's consensus â€” a cost measured in tens of billions of dollars.

## Where Latency Accumulates

Each layer adds time, and the total latency from user action to true finality is longer than most users realize.

The user-facing latency â€” the time from tapping "Swap" to seeing a confirmation in their wallet â€” is dominated by stage two. Soft confirmation from the sequencer takes one to two seconds on most rollups. This is the number that matters for UX, and it is why rollups feel fast. But soft confirmation is not settlement. It is a promise.

The DA posting latency â€” stage three â€” is invisible to most users but critical for operators. If the sequencer fails to post a batch within its expected interval, soft confirmations that users already received are not yet backed by available data. In extreme cases, a sequencer crash after issuing soft confirmations but before posting the batch could mean those transactions are lost entirely, requiring resubmission.

The settlement latency â€” stage four â€” is the elephant in the room. Seven days for optimistic rollups. Minutes to hours for ZK rollups. This latency matters for bridges, which cannot safely release funds on the destination chain until the source chain transaction is settled. It matters for cross-rollup composability, because atomic interactions between two rollups require both to reach a common settlement state. It matters for institutional users who need finality guarantees before considering a transfer complete.

The total stack latency from user intent to irreversible finality on an optimistic rollup is roughly seven days. On a ZK rollup, it ranges from minutes to hours. The user experiences two seconds. The system takes days. This asymmetry between perceived and actual finality is one of the most important architectural properties of the modular stack.

## Where Costs Accumulate

The cost of a transaction is not a single number. It is a sum of charges from multiple layers, and understanding the breakdown reveals where optimization opportunities exist.

Execution cost is the gas consumed by running the smart contract logic. On L2 rollups, this is typically small â€” fractions of a cent for simple operations. The execution layer is the cheapest component of the stack for most applications.

DA cost is the price of posting transaction data to the DA layer. This is typically the largest component. On Ethereum blobs, the cost depends on blob demand â€” during low-demand periods, it can be near zero. During high-demand periods, blob fees spike. On dedicated DA layers like Celestia, the cost is more predictable but introduces a different security model.

Settlement cost is the gas consumed by posting the state root or verifying the proof on Ethereum L1. For optimistic rollups, this is a single L1 transaction per batch â€” relatively cheap when amortized across thousands of L2 transactions in the batch. For ZK rollups, proof verification is more computationally expensive on-chain, though this cost is also amortized across the batch.

Sequencer margin is the difference between what the user pays and what the sequencer pays in DA and settlement costs. This is the sequencer's revenue. It is not a visible line item, but it is embedded in every transaction fee.

The practical implication: if you want to reduce your users' costs, look at DA first. DA dominates the cost stack for most rollups. Switching from Ethereum blobs to Celestia can reduce DA costs by 50 times or more. Increasing batch sizes reduces per-transaction DA costs by amortizing the fixed posting cost across more transactions. Compressing transaction data more aggressively before posting reduces the total bytes charged by the DA layer. Execution optimization â€” writing more gas-efficient smart contracts â€” helps, but it is optimizing the smallest cost component.

## Failure Cascades: When One Layer Breaks

The modular stack's biggest operational risk is that failures do not stay contained within a single layer. They cascade.

In August 2025, Base's sequencer experienced a failover failure that halted block production for 33 minutes. During those 33 minutes, no transactions were processed. DeFi positions could not be managed. Liquidations could not fire. Users with leveraged positions on Base-native lending protocols had no way to add collateral or close positions as prices moved against them. The sequencer outage was a sequencing-layer failure, but its consequences propagated instantly to every application on the chain.

This is the **sequencer-to-application cascade**. When the sequencer stops, the entire rollup stops. Unlike a monolithic L1 where hundreds of validators provide redundancy, a rollup with a single sequencer has a single point of failure. The escape hatch â€” forced inclusion through L1 â€” exists, but it takes minutes to hours and requires the user to interact directly with Ethereum's base layer, which most users cannot do.

The **DA-to-sequencer coupling** is another cascade path. The sequencer posts batches to the DA layer. If the DA layer becomes congested â€” Ethereum blob fees spike, or a dedicated DA layer experiences downtime â€” the sequencer faces a choice. It can continue accepting transactions and issuing soft confirmations while delaying DA posting, which increases the risk that a sequencer crash loses unposted transactions. Or it can slow down transaction acceptance until DA posting catches up, which degrades user experience. Neither option is free of consequences.

The **settlement-to-bridge cascade** affects cross-chain operations. A bridge that transfers assets from one rollup to another typically waits for settlement finality on the source chain before releasing assets on the destination chain. If settlement is delayed â€” a proof generation failure for a ZK rollup, or an extended challenge on an optimistic rollup â€” the bridge holds funds longer than expected. Users who expected their bridged assets to arrive in minutes find them locked for hours or days.

In October 2025, a major AWS outage in the US-EAST-1 region exposed how deeply the modular stack depends on centralized cloud infrastructure. Sequencers, RPC nodes, indexers, and frontends running on the affected AWS region all went down simultaneously. The blockchains themselves â€” the validator networks â€” largely continued producing blocks. But the infrastructure that users depend on to interact with those blockchains was offline. This was not a blockchain failure. It was an infrastructure failure. But from the user's perspective, the distinction did not matter. They could not access their funds.

## Cross-Layer Trust Assumptions

Each layer operates under a different trust model, and those models do not always compose cleanly.

The settlement layer has the strongest trust assumptions. Ethereum's security comes from hundreds of thousands of validators staking tens of billions of dollars. Corrupting settlement requires an economically irrational attack.

The DA layer has weaker but still substantial trust assumptions. Ethereum blobs inherit the same validator set. Dedicated DA layers like Celestia have their own, smaller validator sets. If you use Celestia for DA but Ethereum for settlement, you are trusting two different validator sets with different economic security levels for different parts of the same transaction.

The sequencing layer, for most rollups, has the weakest trust assumptions in the stack. You are trusting a single company to include your transaction, order it fairly, and post the batch to the DA layer. The trust is operational â€” you trust the company's reputation, uptime commitment, and legal accountability. It is not cryptographic or economic in the way settlement trust is.

The application layer adds yet another trust model. You trust the frontend to construct the correct transaction. You trust the DNS system to resolve the correct website. You trust the wallet to simulate the transaction honestly. These are traditional web security trust assumptions, and they apply fully to Web3 applications despite the decentralized infrastructure below.

The important point is that the total security of a user's transaction is bounded by the weakest trust assumption in the stack. A transaction secured by Ethereum's settlement, posted to Celestia's DA, ordered by a centralized sequencer, and initiated through a phishing frontend is only as secure as the phishing frontend. Security does not average across layers. It bottlenecks at the weakest one.

## Common Architectural Mistakes

Two mistakes dominate how teams design for the modular stack, and they point in opposite directions.

**Over-modularizing** is the trap for teams that read about modularity and decide every component should be separate. They deploy their own appchain for execution, use a dedicated DA layer, plan for a shared sequencer, and build a custom bridge back to Ethereum for settlement. The result is an architecture with five independent infrastructure dependencies, each of which can fail, each of which needs monitoring, and each of which adds latency and cost. For a team building a small DeFi application that processes a few thousand transactions per day, this is like renting a fleet of trucks to deliver a single package. The infrastructure cost and operational complexity dwarf the application's actual needs.

**Under-modularizing** is the opposite trap. Teams deploy on Ethereum L1 because "it is the most secure" without asking whether their application needs L1 security. They pay ten to fifty dollars per transaction in gas fees during congestion because they never evaluated whether an L2 would provide sufficient security at a fraction of the cost. They store application data on-chain â€” user profiles, metadata, social graph information â€” because they conflate "decentralized" with "everything on the settlement layer." The result is an application that is expensive to use, slow to interact with, and architecturally overbuilt for its actual trust requirements.

The right approach starts with the application's requirements and works downward. What finality guarantee does your application actually need? What throughput does it require? What is the maximum per-transaction cost your users will tolerate? What are your actual trust requirements â€” not your aspirational ones? The answers to these questions determine which layers you need, which implementations you choose for each layer, and where a simpler architecture serves you better than a more modular one.

## Observability Across the Stack

Monitoring a modular stack is harder than monitoring a monolithic chain, and most teams underestimate this.

On a monolithic chain like Solana, you have one system to monitor. Block production, transaction throughput, error rates, gas prices â€” all observable from a single vantage point. On a modular stack, you need to monitor the sequencer's uptime and batching behavior, the DA layer's posting success and fee levels, the settlement layer's proof verification and finality status, and the application layer's frontend availability and wallet connectivity. Each layer has its own metrics, its own alerting thresholds, and its own failure signatures.

The gap in observability tooling is real. Block explorers like Etherscan and Arbiscan show you the end state â€” which transactions were included, what the gas cost was. They do not show you the intermediate states â€” how long the transaction sat in the sequencer's mempool, when the batch was posted to the DA layer, whether DA posting was delayed by congestion. Cross-layer observability â€” tracing a single transaction from frontend to finality across all stack layers â€” is still an emerging capability in 2026. Projects like Conduit and Caldera provide dashboards for rollup operators, but end-to-end transaction tracing across the full modular stack remains immature.

If you are operating a rollup or building an application on one, invest in cross-layer monitoring before you need it. The incident that takes your application offline at 3 AM will not announce which layer failed. You will need instrumentation that can tell you whether the problem is your frontend, your sequencer, your DA posting pipeline, or the settlement layer â€” and you will need it fast.

You now understand what each layer does, how they connect, and where the connections break. The rest of this book explores each layer in depth â€” from the cryptography that makes settlement possible to the business models that make applications sustainable. The final subchapter maps that journey for you.
