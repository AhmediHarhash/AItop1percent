# 2.7 Consensus Failures and Network Attacks
Scope: Web3

## The Baseline Attack Model
The strongest threat class is control over consensus power.

Mechanism. If enough power is captured, ordering and ordering fairness degrade.

Example. A concentrated actor can bias inclusion without rewriting the protocol at once.

Detection. Watch concentration changes and unusual consensus participation concentration.

Mitigation. Add concentration thresholds and incident escalation paths.

Failure consequence. Your first production anomaly can become a market-level incident.

## Cost to Attack and Cost to Defend
Security is always a budget equation.

Mechanism. An attack succeeds when expected gain outruns sustained attack cost.

Example. Weak liveness or reward conditions can shift that balance faster than governance expects.

Detection. Recompute cost-to-attack assumptions around token and participation moves.

Mitigation. Treat these numbers as dynamic and revisit before heavy releases.

Failure consequence. Static assumptions become stale exactly when adversaries test them.

## Eclipse and Partition Patterns
Node isolation is one of the easiest ways to mislead a local view.

Mechanism. If a set of nodes sees altered peer sets, their local history can diverge.

Example. Regional routing events can isolate a region and delay the full view.

Detection. Monitor peer churn and region-specific block arrival patterns.

Mitigation. Strengthen peer diversity and regionally spread relay paths.

Failure consequence. A local view mistake can be enough to create bad settlements.

## Long-Range and History Revision Risks
Old keys and stale checkpoints can be abused if governance assumptions weaken.

Mechanism. Without fresh checkpoints and social alignment, history recovery can become contentious.

Example. A long dormant validator group can still attempt opportunistic reinterpretation.

Detection. Track checkpoint process quality and recovery playbooks.

Mitigation. Require timely, transparent checkpointing in operational procedure.

Failure consequence. Recovery uncertainty compounds during stress.

## Selfish Strategies and Withholding
Withholding blocks or data can shape eventual branch advantage.

Mechanism. Strategic actors may optimize private information advantage before public release.

Example. Delay tactics can improve private ordering outcomes without immediate chain breakage.

Detection. Correlate propagation asymmetry with block inclusion outcomes.

Mitigation. Add propagation monitoring and outlier analysis.

Failure consequence. Users face fairness anomalies first, not clear attacks.

## Liveness Disruption Attacks
Attacks do not need to rewrite history to hurt product.

Mechanism. Denial of liveness reduces throughput and increases user-perceived failure.

Example. Proposal or attestation withholding can reduce settlement speed.

Detection. Watch sustained empty slots and repeated timeout patterns.

Mitigation. Build graceful degradation for slow mode behavior.

Failure consequence. Downtime and trust loss can arrive before security breach.

## Collusion and Governance Capture
Concentrated actors can coordinate around block production influence.

Mechanism. Even without majority takeover, aligned operators can influence ordering.

Example. Repeatable exclusion of certain transaction classes can emerge.

Detection. Track inclusion variance by class and operator group.

Mitigation. Maintain concentration governance checks and transparency.

Failure consequence. Product fairness claims collapse fast under repeated bias.

## Routing Attacks as Hidden Infrastructure Risk
Consensus security assumes some level of network integrity.

Mechanism. Routing manipulation can distort view timing and message order.

Example. Hijacked or degraded paths can isolate observers while chain still looks healthy locally.

Detection. Combine network telemetry with blockchain telemetry in incidents.

Mitigation. Use multi-path and independent monitoring for mission flows.

Failure consequence. You fix application bugs while the transport layer fails.

## Building a Defense Stack
No single control covers all threats.

Mechanism. Economic penalties, fork rules, monitoring, and response must work together.

Example. An attack can move from one layer to another as each layer saturates.

Detection. Use correlated dashboards for economics, nodes, and network behavior.

Mitigation. Define attack playbooks by attack family.

Failure consequence. Layered attacks bypass siloed response.

## Smaller Networks and Higher Sensitivity
Scale changes risk visibility.

Mechanism. Fewer observers and fewer operators reduce detection quality.

Example. A small ecosystem can miss a major attack until it is already actionable.

Detection. Track external monitoring depth and independent review cadence.

Mitigation. Increase mandatory safeguards in smaller deployments.

Failure consequence. Small systems often discover threats when impact is already high.

## Section Closeout
The final work of this section is turning these risks into design constraints.

Mechanism. Every risk model must become a product decision, not an emergency document.

Example. You should be able to state your first mitigation before the first incident.

Detection. Require attack-scenario review in launch checklists.

Mitigation. Make threat models a release gate.

Failure consequence. Incidents then become learning events in production rather than design events.

The next file shows where this risk profile enters pricing and architecture for builders.
